<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>d0000-networking-priority</title>
  <style>

code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">

@import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wdth,wght@0,14..32,75..100,100..900;1,14..32,75..100,100..900&family=JetBrains+Mono:ital,wght@0,400;0,500;0,600;1,400&display=swap')@supports (display: block) {  }

:root {

--cpp-alliance-red: #A91C21;
--cpp-alliance-red-dark: #8a171b;
--cpp-alliance-red-light: #c42328;

--primary: var(--cpp-alliance-red);
--primary-hover: var(--cpp-alliance-red-dark);
--text: #2c2c2c;
--text-secondary: #4a4a4a;
--text-muted: #6b6b6b;
--bg: #ffffff;
--bg-secondary: #f7f7f7;
--bg-code: #f7f7f7;
--border: #e0ddd8;
--border-light: #eae7e2;

--syntax-keyword: #7b3294;
--syntax-type: #0077aa;
--syntax-function: #2266bb;
--syntax-string: #448844;
--syntax-number: #b35900;
--syntax-comment: #8a8a8a;
--syntax-preprocessor: #aa3344;
--syntax-operator: #555555;

--font-body: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
--font-mono: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;

--content-width: 257mm; 
--spacing-xs: 0.25rem;
--spacing-sm: 0.5rem;
--spacing-md: 1rem;
--spacing-lg: 1.5rem;
--spacing-xl: 2rem;
--spacing-xxl: 3rem;

--transition: 0.2s ease;
}

*, *::before, *::after {
box-sizing: border-box;
}
html {
font-size: 15px;
scroll-behavior: smooth;
-webkit-text-size-adjust: 100%;
}
body {
margin: 0;
padding: var(--spacing-xl) var(--spacing-lg);
background-color: var(--bg);
color: var(--text);
font-family: var(--font-body);
font-size: 1rem;
font-weight: 400;
line-height: 1.55;
font-variation-settings: "wdth" 75, "opsz" 16;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}

body {
max-width: var(--content-width);
margin-left: auto;
margin-right: auto;
}

.paper-header {
display: flex;
align-items: center;
justify-content: space-between;
padding-bottom: var(--spacing-lg);
margin-bottom: var(--spacing-xl);
border-bottom: 3px solid var(--text);
}
.cpp-alliance-logo img {
height: 70px;
width: auto;
float:right
}
.paper-header .header-text {
font-family: var(--font-body);
font-size: 0.95rem;
font-weight: 400;
font-style: italic;
color: var(--text-muted);
letter-spacing: 0.05em;
text-transform: uppercase;
}

.document-info {
background: var(--bg-secondary);
border-left: 4px solid var(--primary);
border-radius: 0 4px 4px 0;
padding: var(--spacing-lg);
margin-bottom: var(--spacing-xxl);
}
.document-info p {
margin: var(--spacing-xs) 0;
font-size: 0.9rem;
line-height: 1.6;
}
.document-info strong {
color: var(--text-secondary);
min-width: 160px;
display: inline-block;
font-variation-settings: 'wght' 550, 'wdth' 75;
}

h1, h2, h3, h4, h5, h6 {
font-family: var(--font-body);
font-variation-settings: 'wght' 575, 'wdth' 75;
line-height: 1.3;
color: var(--text);
margin-top: var(--spacing-xxl);
margin-bottom: var(--spacing-md);
}
h1 {
font-size: 1.5rem;
color: var(--text);
border-bottom: 3px solid var(--text);
padding-bottom: var(--spacing-sm);
margin-top: 0;
}
h2 {
font-size: 1.2rem;
border-bottom: 1px solid var(--border);
padding-bottom: var(--spacing-xs);
}
h3 {
font-size: 1.10rem;
color: var(--text);
}
h4 {
font-size: 1.05rem;
color: var(--text-secondary);
}
h5, h6 {
font-size: 1rem;
color: var(--text-secondary);
}

p {
margin-top: 0;
margin-bottom: var(--spacing-md);
hyphens: auto;
}
strong {
font-variation-settings: 'wght' 550, 'wdth' 75;
color: var(--text);
}
em {
font-family: var(--font-body);
font-style: oblique 10deg;
font-synthesis: none;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}
small {
font-size: 0.875rem;
color: var(--text-muted);
}

a {
color: var(--primary);
text-decoration: none;
border-bottom: 1px solid transparent;
transition: border-color var(--transition), color var(--transition);
}
a:hover, a:focus {
color: var(--primary-hover);
border-bottom-color: var(--primary-hover);
}
a:focus {
outline: 2px solid var(--primary);
outline-offset: 2px;
}

code {
font-family: var(--font-mono);
font-size: 0.8em;
background-color: var(--bg-code);
color: var(--syntax-preprocessor);
padding: 0.2em 0.45em;
border-radius: 3px;
white-space: nowrap;
}

pre {
background-color: var(--bg-code);
border-left: 4px solid var(--primary);
border-radius: 0 4px 4px 0;
padding: var(--spacing-lg);
margin: var(--spacing-lg) 0;
overflow-x: auto;
line-height: 1.55;
tab-size: 4;
box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.04);
}
blockquote pre{
border-left: none; background-color: white;
}
pre code {
background: none;
border: none;
padding: 0;
font-size: 0.82rem;
font-weight: 400;
color: var(--text);
white-space: pre;
}


pre .keyword,
pre .k,
pre .kw,
pre .kd,
pre .kn,
pre .kr {
color: #7b3294;
font-weight: 500;
}

pre .type,
pre .kt,
pre .nc,
pre .nn {
color: #0077aa;
}

pre .built_in,
pre .bp {
color: #0077aa;
}

pre .function,
pre .fn,
pre .nf,
pre .fm {
color: #2266bb;
}

pre .string,
pre .s,
pre .s1,
pre .s2 {
color: #448844;
}

pre .number,
pre .n,
pre .mi,
pre .mf,
pre .mh {
color: #b35900;
}

pre .comment,
pre .c,
pre .c1,
pre .cm,
pre .cp {
color: #8a8a8a;
font-style: italic;
}

pre .preprocessor,
pre .meta {
color: #aa3344;
}

pre .operator,
pre .o,
pre .p {
color: #666666;
}

pre .punctuation {
color: #555555;
}

pre .variable,
pre .v,
pre .nv {
color: #994444;
}

pre .constant,
pre .kc,
pre .nb {
color: #b35900;
}

pre .attribute,
pre .attr {
color: #448844;
}

pre .namespace {
color: #0077aa;
}

blockquote {
margin: var(--spacing-lg) 0;
padding: var(--spacing-md) var(--spacing-lg);
background-color: var(--bg-secondary);
border-left: 4px solid var(--primary);
border-radius: 0 4px 4px 0;
color: var(--text-secondary);
font-style: italic;
}
blockquote p {
margin: 0;
}
blockquote p + p {
margin-top: var(--spacing-sm);
}

blockquote.note {
border-left-color: #0277aa;
background-color: #eef6fa;
}
blockquote.warning {
border-left-color: #dd8800;
background-color: #fef8ee;
}
blockquote.danger {
border-left-color: var(--cpp-alliance-red);
background-color: #fdf2f2;
}

ul, ol {
margin: 0 0 var(--spacing-md) 0;
padding-left: var(--spacing-xl);
}
li {
margin-bottom: var(--spacing-xs);
}
li > ul, li > ol {
margin-top: var(--spacing-xs);
margin-bottom: 0;
}

dl {
margin: var(--spacing-md) 0;
}
dt {
font-weight: 700;
color: var(--text);
margin-top: var(--spacing-sm);
}
dd {
margin-left: var(--spacing-xl);
color: var(--text-secondary);
}

table {
width: 100%;
border-collapse: collapse;
margin: var(--spacing-lg) 0;
font-size: 0.92rem;
}
thead {
background-color: var(--bg-secondary);
color: white;
}
.document-info table thead {
background-color: transparent;
color: var(--body-text);
}
.document-info table colgroup col:first-child {
width:1% !important;
}
.document-info table colgroup col:last-child {
width:99% !important;
}
.document-info table {
margin: 0;
}
.document-info table td:first-child, .document-info table th:first-child {
min-width:75px;
}
th {
background-color: var(--text-secondary);
font-weight: 700;
text-align: left;
padding: var(--spacing-sm) var(--spacing-md);
}
.document-info th {
background-color: transparent;
}
td {
padding: var(--spacing-sm) var(--spacing-md);
border-bottom: 1px solid var(--border);
}
.document-info table td {
padding: var(--spacing-sm) var(--spacing-md);
border-bottom: none;
}
tbody tr:nth-child(even) {
background-color: var(--bg-secondary);
}

table.compact th,
table.compact td {
padding: var(--spacing-xs) var(--spacing-sm);
font-size: 0.875rem;
}

hr {
border: none;
height: 1px;
margin: var(--spacing-xxl) 0;
}

figure {
margin: var(--spacing-lg) 0;
text-align: center;
}
img {
max-width: 100%;
height: auto;
border-radius: 3px;
}
figcaption {
margin-top: var(--spacing-sm);
font-size: 0.875rem;
color: var(--text-muted);
font-style: italic;
}

.text-center { text-align: center; }
.text-right { text-align: right; }
.text-muted { color: var(--text-muted); }
.text-primary { color: var(--primary); }
.mt-0 { margin-top: 0; }
.mb-0 { margin-bottom: 0; }
.mt-lg { margin-top: var(--spacing-lg); }
.mb-lg { margin-bottom: var(--spacing-lg); }
.visually-hidden {
position: absolute;
width: 1px;
height: 1px;
padding: 0;
margin: -1px;
overflow: hidden;
clip: rect(0, 0, 0, 0);
white-space: nowrap;
border: 0;
}

.toc {
background-color: var(--bg-secondary);
border-radius: 4px;
padding: var(--spacing-lg);
margin: var(--spacing-xl) 0;
}
.toc-title {
font-size: 1.05rem;
font-weight: 700;
color: var(--text);
margin: 0 0 var(--spacing-md) 0;
padding-bottom: var(--spacing-sm);
border-bottom: 2px solid var(--text);
}
.toc ul {
list-style: none;
padding-left: 0;
margin: 0;
}
.toc li {
margin: var(--spacing-xs) 0;
}
.toc ul ul {
padding-left: var(--spacing-lg);
}
.toc a {
color: var(--text-secondary);
font-size: 0.92rem;
}
.toc a:hover {
color: var(--primary);
}

.revision-history {
font-size: 0.9rem;
}
.revision-history th {
background-color: var(--text-secondary);
}

.wording {
background-color: var(--bg-secondary);
border-radius: 4px;
padding: var(--spacing-lg);
margin: var(--spacing-lg) 0;
}
.wording-add {
background-color: #eef6ee;
border-color: #66aa66;
}
.wording-remove {
background-color: #fdf2f2;
border-color: var(--cpp-alliance-red);
text-decoration: line-through;
}
ins {
background-color: #d4edda;
text-decoration: none;
padding: 0 2px;
}
del {
background-color: #f8d7da;
text-decoration: line-through;
padding: 0 2px;
}

@media print {
html {
font-size: 12pt;
}
body {
max-width: none;
padding: 0;
margin: 0;
color: #000;
background: #fff;
}
.paper-header {
border-bottom-color: #000;
}

h1, h2, h3, h4, h5, h6 {
page-break-after: avoid;
break-after: avoid;
}
pre, blockquote, table, figure {
page-break-inside: avoid;
break-inside: avoid;
}

a[href^="http"]::after {
content: " (" attr(href) ")";
font-size: 0.8em;
color: #666;
word-break: break-all;
}

.no-print {
display: none !important;
}

pre {
background-color: #f5f5f5 !important;
white-space: pre-wrap;
word-wrap: break-word;
}
pre code {
color: #333 !important;
}

thead {
background-color: #ddd;;
color: #000;
-webkit-print-color-adjust: exact;
print-color-adjust: exact;
}
.document-info table thead {
background-color: transparent;
color: var(--body-text);
}
}

@page {
size: A4 portrait; 
margin: 20mm;
@top-center {
content: "WG21 Proposal";
font-family: "Inter", sans-serif;
font-size: 10pt;
color: #666;
}
@bottom-center {
content: counter(page);
font-family: "Inter", sans-serif;
font-size: 10pt;
}
}


@media screen and (min-width: 1200px) {
html {
font-size: 16px;
}
body {
padding: var(--spacing-xxl) var(--spacing-xl);
}
.cpp-alliance-logo img {
height: 70px;
}
}

@media screen and (max-width: 1199px) and (min-width: 769px) {
:root {
--content-width: 720px;
}
html {
font-size: 15px;
}
}

@media screen and (max-width: 768px) {
:root {
--content-width: 100%;
}
html {
font-size: 14px;
}
body {
padding: var(--spacing-lg);
}
h1 {
font-size: 1.6rem;
}
h2 {
font-size: 1.2rem;
}
.cpp-alliance-logo img {
height: 55px;
}
}

@media screen and (max-width: 600px) {
html {
font-size: 13px;
}
body {
padding: var(--spacing-md);
}
h1 {
font-size: 1.4rem;
}
h2 {
font-size: 1.1rem;
}
pre {
padding: var(--spacing-md);
font-size: 0.78rem;
}
table {
font-size: 0.85rem;
}
th, td {
padding: var(--spacing-xs) var(--spacing-sm);
}
.paper-header {
flex-direction: column;
text-align: center;
gap: var(--spacing-md);
}
.cpp-alliance-logo img {
height: 45px;
}
}

@media (prefers-reduced-motion: reduce) {
* {
transition: none !important;
animation: none !important;
}
html {
scroll-behavior: auto;
}
}

:focus-visible {
outline: 2px solid var(--primary);
outline-offset: 2px;
}
:focus:not(:focus-visible) {
outline: none;
}
</style>
</head>
<body>
<div class="document-info">
<table>
<thead>
<tr>
<th>Document</th>
<th>D4008R0</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date:</td>
<td>2026-02-09</td>
</tr>
<tr>
<td>Reply-to:</td>
<td>Vinnie Falco &lt;vinnie.falco@gmail.com&gt;</td>
</tr>
<tr>
<td>Audience:</td>
<td>All of WG21</td>
</tr>
</tbody>
</table>
</div>
<h1 id="the-c-standard-cannot-connect-to-the-internet">The C++ Standard
Cannot Connect to the Internet</h1>
<h2 id="abstract">Abstract</h2>
<p>This paper discusses a key observation: The C++ Standard cannot
connect to the Internet. The problem is not missing sockets. Third-party
networking libraries exist. The problem is that C++ lacks a standard
asynchronous execution model designed for I/O, which prevents
asynchronous algorithms from composing across library boundaries. Every
other major programming language solved this problem by standardizing an
async I/O foundation, and the result was an explosion of higher-level
frameworks. C++ has no such ecosystem because there is no agreed-upon
foundation to build on. This paper examines the evidence, proposes three
tests that a standard async model should meet, and asks the committee to
consider whether networking deserves higher priority than it currently
receives.</p>
<hr />
<h2 id="the-observation">1. The Observation</h2>
<p>This paper discusses a key observation: The C++ Standard cannot
connect to the Internet.</p>
<p>This is not for lack of trying. Third-party networking libraries
exist and are widely used. <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a>
has been in production for over twenty years. But Asio itself ships as
two incompatible published versions, Boost.Asio and <a href="https://github.com/chriskohlhoff/asio">standalone Asio</a>, with
different namespaces and different build configurations. This is the
coordination problem in miniature: even the most popular, most mature
C++ networking library cannot agree with itself on a single
interface.</p>
<p>The deeper problem is not sockets. It is the absence of a standard
asynchronous execution model for I/O.</p>
<p>If a programmer wants to write a composable async algorithm, for
example an HTTP conversation, a WebSocket message exchange, or an
asynchronous file transfer with optional compression, what execution
model should they use? There is no answer. There are Asio completion
tokens, Meta’s <a href="https://github.com/facebook/folly/blob/main/folly/experimental/coro/README.md">folly::coro</a>,
<a href="https://doc.qt.io/qt-6/signalsandslots.html">Qt signals and
slots</a>, custom callback systems, promise/future chains, and ad-hoc
event loops. Each is an island. Algorithms expressed in one model cannot
compose with algorithms from another.</p>
<p>Not every committee member works with network programming daily. WG21
is full of experts in language design, template metaprogramming,
numerics, concurrency, safety, and many other domains. This paper is
written from a networking practitioner’s perspective, for colleagues who
may not have the same daily experience with this problem. It aims to
explain, with evidence, why the networking gap matters and what it
costs.</p>
<hr />
<h2 id="the-tower-of-abstraction">2. The Tower of Abstraction</h2>
<p>Every major programming language standardized an async foundation. In
some cases this was a full I/O model in the standard library. In others
it was a narrow composability trait that third-party runtimes build on.
Either way, the standardized foundation enabled tall towers of
abstraction. The foundation came first. The frameworks followed.</p>
<p><strong>Python</strong> standardized <code>asyncio</code> in Python
3.4 (2014) via <a href="https://peps.python.org/pep-3156/">PEP 3156</a>,
providing both the async model and I/O integration in the standard
library. The ecosystem built upward. <a href="https://github.com/django/django">Django</a> (86.7k GitHub stars),
the web framework “for perfectionists with deadlines,” sits atop this
foundation.</p>
<p><strong>JavaScript</strong> standardized <code>Promise</code> in
ES2015 (June 2015) and <code>async</code>/<code>await</code> in ES2017
(<a href="https://tc39.es/proposal-async-await/">TC39 proposal</a>). The
language standard defines the composability primitive; the I/O runtime
comes from the host environment (Node.js, browsers, Deno). Because every
runtime implements the same <code>Promise</code> contract, libraries
like <a href="https://github.com/expressjs/express">Express.js</a>
(68.7k stars) and <a href="https://github.com/vercel/next.js">Next.js</a> (137.6k stars)
compose across all of them.</p>
<p><strong>Go</strong> shipped goroutines, channels, and
<code>net/http</code> in the standard library from day one (2009). The
<code>net/http</code> package is imported by <a href="https://pkg.go.dev/net/http">1,705,800 known packages</a>. The
entire Go microservices ecosystem is built on this foundation.</p>
<p><strong>Rust</strong> stabilized
<code>async</code>/<code>await</code> in Rust 1.39 (November 2019; <a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable/">Rust
blog announcement</a>) and standardized the <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>
trait in <code>std</code>. The I/O runtime is not in the standard
library — <a href="https://github.com/tokio-rs/tokio">Tokio</a> (31k
stars) fills that role. But because every runtime implements the same
<code>Future</code> trait, libraries like <a href="https://github.com/hyperium/hyper">hyper</a> and <a href="https://github.com/tokio-rs/axum">Axum</a> (24.9k stars) are
runtime-agnostic. Rust standardized the narrow composability contract,
and the ecosystem built on it.</p>
<p><strong>Java</strong> has had <code>java.net</code> in the standard
library since JDK 1.0 (1996). The ecosystem built upward. <a href="https://github.com/spring-projects/spring-boot">Spring Boot</a>
(79.9k stars) sits atop this foundation.</p>
<p><strong>C#</strong> shipped <code>async</code>/<code>await</code> and
the <code>Task</code> type in C# 5.0 (2012; <a href="https://dotnetcurry.com/csharp/869/async-await-csharp-dotnet">overview</a>),
with a built-in thread pool and I/O completion in the standard library.
The ecosystem built upward. <a href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> (37.7k
stars) sits atop this foundation.</p>
<p>In every case, standardization of an async foundation — whether a
full I/O model or a narrow composability trait — enabled the ecosystem
to build upward. The frameworks came after the foundation. The combined
GitHub stars of these higher-level frameworks exceed 500,000.</p>
<p><strong>C++</strong> added coroutines in C++20 but standardized
neither an async I/O model nor a composability trait for async
operations. The language machinery is there. The foundation is not. C++
bottoms out at <a href="https://github.com/boostorg/asio">Boost.Asio</a>
(1.5k stars, third party, no standard status), or raw POSIX/Winsock.
There is no Django, no Express, no Spring Boot of C++. Not because C++
programmers are less capable, but because there is no standard
foundation to build on.</p>
<hr />
<h2 id="the-coordination-problem">3. The Coordination Problem</h2>
<p>The C++ standard exists to solve coordination problems. <a href="https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2000r4.pdf">P2000R4</a>
(“Direction for ISO C++”) was created specifically to address concerns
about C++ “losing coherency due to proposals based on differing and
sometimes mutually contradictory design philosophies.” The standard
provides a shared foundation so that independently developed libraries
can interoperate.</p>
<p>The async I/O domain is the textbook case where that foundation is
missing.</p>
<p>Without a standard async model for I/O, every library invents its
own. <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a>
uses completion tokens. Meta’s <a href="https://github.com/facebook/folly/blob/main/folly/experimental/coro/README.md">folly::coro</a>
is “a developer-friendly asynchronous C++ framework based on the
Coroutines TS.” <a href="https://doc.qt.io/qt-6/signalsandslots.html">Qt</a> uses signals
and slots, described as “Qt’s central communication mechanism between
objects, serving as an alternative to callbacks.” Beyond these, there
are custom callback systems, promise/future chains, and ad-hoc event
loops in countless codebases.</p>
<p>Algorithms written for one model cannot compose with another. An HTTP
library built on Asio completion tokens cannot be used by code built on
folly::coro. A TLS wrapper using Qt’s event loop cannot plug into <a href="https://www.boost.org/doc/libs/release/libs/beast/">Boost.Beast</a>.
Each library is an island.</p>
<p>This fragmentation is the direct cause of the shallow abstraction
tower. Nobody builds Django-scale frameworks in C++ because the
foundation is not agreed upon.</p>
<h3 id="the-no-dependencies-culture">The “No Dependencies” Culture</h3>
<p>C++ libraries routinely advertise “no external dependencies” or
“header-only” as a selling point. <a href="https://github.com/nlohmann/json">nlohmann/json</a> (48.8k stars)
advertises “no external dependencies beyond a C++11 compliant compiler.”
<a href="https://github.com/yhirose/cpp-httplib">cpp-httplib</a> (16k
stars) bills itself as “a C++ header-only HTTP/HTTPS server and client
library” with no dependencies. <a href="https://github.com/fmtlib/fmt">fmt</a> (23.2k stars) highlights
“no external dependencies.”</p>
<p>This cultural norm is a symptom of the missing foundation. In a
healthy ecosystem, depending on shared infrastructure is normal. In
Python, depending on <code>asyncio</code> is not a liability. In C++,
depending on Boost.Asio is treated as a burden.</p>
<p>John Lakos’s <em>Large-Scale C++ Software Design</em> (<a href="https://informit.com/store/large-scale-c-plus-plus-software-design-9780201633627">Addison-Wesley,
1996</a>) established that well-structured systems with clear
hierarchical dependencies are “fundamentally easier and more economical
to maintain, test, and reuse.” The “no dependencies” instinct inverts
this principle. It treats isolation as a virtue when shared foundations
would be more productive.</p>
<p>The absence of a standard async model makes this dysfunction worse.
Since no foundation exists, every library must reinvent it or avoid
async entirely.</p>
<hr />
<h2 id="how-we-got-here">4. How We Got Here</h2>
<p>In 2014, the C++ committee decided to “adopt existing practice” for
networking, basing a proposal on <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a>
(<a href="https://wg21.link/p3185r0">P3185R0</a> documents this
history). Chris Kohlhoff published a <a href="https://github.com/chriskohlhoff/networking-ts-impl">reference
implementation of the Networking TS</a>.</p>
<p>By 2021, the executor debate had consumed the effort. On 2021-09-28,
SG1 polled whether “one grand unified model” for asynchronous execution
was needed. The result was no consensus: 4 SF, 9 WF, 5 N, 5 WA, 1 SA. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2453r0.html">P2453R0</a>
documents these polls. Nobody objected to portable socket wrappers. The
schism was entirely about the execution model.</p>
<p>The committee chose <a href="https://wg21.link/p2300">P2300</a>
(<code>std::execution</code>), a sender/receiver framework. It is now in
the C++26 working draft.</p>
<p>C++26 is about to ship <code>std::execution</code>, an asynchronous
execution model. The committee decided it needed a standard async
framework. That instinct was correct. But the framework that landed was
designed for GPU and parallel computing (section 5.1 presents the
evidence). The <a href="https://nvidia.github.io/stdexec/">stdexec
documentation</a> confirms: “Interop with networking is being explored
for C++29.” Networking is not a first-class citizen in the async model
the committee chose. It is an afterthought.</p>
<p>The committee spent a decade on this path. The Networking TS was
proposed in 2014. It is now 2026. The C++ standard still cannot connect
to the internet.</p>
<p>This is not blame. The domain is genuinely difficult. The instinct to
find a universal model is natural. But the cost of the delay is real.
The committee recognized the need for a standard async model, and that
recognition was right. The question is whether the model that landed
serves the most important use case.</p>
<hr />
<h2 id="three-tests-for-a-standard-async-model">5. Three Tests for a
Standard Async Model</h2>
<p>If C++ is going to standardize an asynchronous execution model, it
should meet three criteria. This section proposes those criteria and
evaluates <code>std::execution</code> against each.</p>
<h3 id="it-should-put-networking-first">5.1 It Should Put Networking
First</h3>
<p>Networking is not just another feature. It is the infrastructure
through which modern institutions coordinate. Samo Burja’s <em>Great
Founder Theory</em> (<a href="https://www.samoburja.com/gft/">samoburja.com/gft</a>) describes
“social technology” as a coordination mechanism that can be documented
and taught. The internet is the most consequential social technology of
our era. Every other major programming language standardized an async
foundation for networking — whether a full I/O model or a narrow
composability trait (section 2). None of them ship a sender/receiver
execution framework. C++ ships neither. When a language cannot
participate in building the coordination infrastructure that
civilization depends on, the gap is not merely technical. It is
strategic.</p>
<p>GPU users already have CUDA, which requires NVIDIA’s non-standard
compiler. The <code>__device__</code>, <code>__global__</code>, and
<code>&lt;&lt;&lt;&gt;&gt;&gt;</code> syntax are not valid C++ (<a href="https://docs.nvidia.com/cuda/cuda-programming-guide/05-appendices/cpp-language-extensions.html">CUDA
C/C++ Language Extensions</a>). Adding <code>std::execution</code> to
the standard provides no benefit to GPU users that <a href="https://vcpkg.link/ports/stdexec">stdexec on vcpkg</a> does not
already provide.</p>
<p><code>std::execution</code>’s design priorities explicitly target GPU
computing. <a href="https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html">P2300R10</a>
section 1.1 frames the motivation around “GPUs in the world’s fastest
supercomputer.” Section 1.3.2’s second end-user example is “Asynchronous
inclusive scan,” a GPU parallel primitive using <code>bulk</code>. The
<code>bulk</code> algorithm has no networking analog.</p>
<p><strong>Networking creates towers. GPU does not.</strong> The tower
of abstraction argument only works if standardization actually enables
higher-level libraries to proliferate. For networking, the evidence is
overwhelming: sockets lead to HTTP, which leads to REST, which leads to
web frameworks, which lead to full-stack applications. Django, Express,
Spring Boot, Axum (500k+ combined GitHub stars) all sit atop
standardized async I/O foundations. Each layer builds on the one
below.</p>
<p>The GPU ecosystem is wide but not tall. CUDA leads to cuDNN, cuBLAS,
cuFFT, OptiX, and custom kernels. Each library uses the foundation
directly. There is no stacking. There is no “Django of GPU.” GPU
workloads are domain-specific: custom kernels for physics simulations,
ML training loops, rendering pipelines. The use cases do not compose
upward the way networking use cases do.</p>
<p>Standardizing <code>std::execution</code> for GPU would not produce
the ecosystem benefit that standardizing an async I/O model for
networking would. The return on investment is asymmetric: networking
standardization enables exponential ecosystem growth (towers), while GPU
standardization enables linear growth at best (more libraries at the
same level).</p>
<h3 id="it-should-be-built-on-c20-coroutines">5.2 It Should Be Built on
C++20 Coroutines</h3>
<p>C++20 gave C++ a language-level mechanism for writing async code that
looks like sync code. The <a href="https://wg21.link/p0912r5">C++20
coroutines proposal</a> (P0912R5) was a deliberate language design
choice. <code>co_await</code>, <code>co_return</code>, and
<code>co_yield</code> are keywords in the language. A standard async I/O
framework should build on this foundation, not work around it.</p>
<p><code>std::execution</code> shipped in C++26 without a coroutine task
type. <a href="https://wg21.link/p3552">P3552</a> (“Add a Coroutine Task
Type”) is still in flight, listing 12 unsolved design objectives. The
primary way users are expected to write async code was not included in
the framework.</p>
<p>There is a deeper problem. <a href="https://wg21.link/p4007">D4007R0</a> (“std::execution Needs More
Time”) documents that <code>std::execution</code>’s backward-flow
context model provides the allocator after the coroutine frame is
already allocated. Eric Niebler characterizes the issue in <a href="https://wg21.link/p3826">P3826R3</a>: “The receiver is not known
during early customization. Therefore, early customization is
irreparably broken.” This is a fundamental incompatibility with
coroutine-based I/O, where the allocator must be known at frame
allocation time.</p>
<p>Alternative models are coroutines-first and do not have this problem.
<a href="https://wg21.link/p4003">D4003</a> (IoAwaitables) flows context
forward through coroutine chains, with the allocator known at the launch
site. <a href="https://github.com/tzcnt/TooManyCooks">TooManyCooks</a>
is a C++20 coroutine runtime built around <code>tmc::task</code> as the
core type. <a href="https://github.com/cppalliance/capy">Capy</a> is a
coroutine-first execution model with forward-flowing context. Each of
these designs treats coroutines as the primary user interface for async
code, not as an afterthought bolted onto a different execution
model.</p>
<h3 id="it-should-be-narrow">5.3 It Should Be Narrow</h3>
<p>Successful C++ abstractions capture one essential property. Iterators
abstract over traversal: “One seldom needs to know the exact type of
data on which an algorithm works since most algorithms work on many
similar types” (<a href="https://stepanovpapers.com/Stepanov-The_Standard_Template_Library-1994.pdf">Stepanov,
“The Standard Template Library,” 1994</a>). Allocators abstract over
memory strategy (<a href="https://en.cppreference.com/w/cpp/named_req/Allocator">cppreference:
Allocator</a>). RAII abstracts over resource lifetime (<a href="https://en.cppreference.com/w/cpp/language/raii">cppreference:
RAII</a>). Each leaves everything else to the user.</p>
<p><code>std::execution</code> abstracts over scheduling, context
propagation, error handling, cancellation, algorithm dispatch, and
hardware backend selection simultaneously. <a href="https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html">P2300R10</a>
section 1.2 lists priorities including “diversity of execution
resources,” “cancellation,” “error propagation,” “where things execute,”
and “manage lifetimes asynchronously.” That is not one essential
property. That is six.</p>
<p>The specification size tells the story. The C++26 <code>[exec]</code>
section (<a href="https://eel.is/c++draft/exec">eel.is/c++draft/exec</a>) spans 16
major subsections (33.1 through 33.16) with thousands of lines of
normative wording. By contrast, <a href="https://wg21.link/p4003">D4003</a>’s IoAwaitables wording section
is roughly 680 lines. D4003’s own non-normative note states:</p>
<blockquote>
<p>“The wording below is not primarily intended for standardization. Its
purpose is to demonstrate how a networking-focused, use-case-first
design produces a dramatically leaner specification footprint. Compare
this compact specification against the machinery required by
P2300/P3826.”</p>
</blockquote>
<p>A narrow model designed for networking requires a fraction of the
specification that a wide model designed for everything requires. This
matters for implementers, for reviewers, and for the long-term
maintainability of the standard. (For a fuller treatment of the
narrow-vs-wide argument, see <a href="on-universal-models.md">On
Universal Models</a> section 4.)</p>
<p>Ten or more companion papers are still fixing
<code>std::execution</code>’s design in the 2025-2026 mailings,
addressing lifetimes, exception safety, diagnostics, memory bloat,
forward progress guarantees, and a missing task type. A framework with
this many open design questions has not yet demonstrated the stability
that standardization requires.</p>
<h3 id="the-standard-might-not-even-need-sockets">5.4 The Standard Might
Not Even Need Sockets</h3>
<p>A further observation: if the standard adopts an async execution
model that is opinionated on buffer-oriented I/O, it might not need to
standardize sockets at all. Users would choose a third-party library for
the transport (Asio sockets, io_uring, platform APIs), but they could
express the bulk of their algorithms abstractly against standard buffer
concepts. Those algorithms would be sharable across the ecosystem
regardless of the transport underneath.</p>
<p>This is the model already demonstrated in practice.</p>
<p><strong>Boost.HTTP</strong> follows a Sans-I/O architecture. Its
documentation states: “The library itself does not perform any I/O
operations or asynchronous flow control. Instead, it provides interfaces
for consuming and producing buffers of data and events.” It works with
“any I/O framework (Asio, io_uring, platform APIs)” (<a href="https://github.com/cppalliance/http">Boost.HTTP</a>).</p>
<p><strong>Boost.Capy</strong> provides buffer-oriented stream concepts
(<code>ReadStream</code>, <code>WriteStream</code>,
<code>BufferSource</code>, <code>BufferSink</code>) with type-erased
wrappers. Its documentation states: “It is not a networking library, yet
it is the perfect foundation upon which networking libraries, or any
libraries that perform I/O, may be built.” Algorithms written against
<code>any_stream</code> have “zero knowledge of Asio” and achieve
“complete portability with no Asio dependency in algorithm code” (<a href="https://github.com/cppalliance/capy">Boost.Capy</a>).</p>
<p>Both Boost.HTTP and Boost.Capy are still in active development. The
designs are early and may change. We are showing this work before it is
finished because C++26 is about to ship, and the window for
reconsidering the execution model direction is closing. These libraries
are presented not as finished proposals but as evidence that the
approach is viable. The pattern they demonstrate, writing I/O algorithms
against abstract buffer concepts independent of the transport, is what
matters. The specific libraries are proof of concept, not the final
answer.</p>
<p>The pattern is clear: standardize the buffer-oriented async I/O
concepts and type-erased wrappers. Let the ecosystem provide the
transports. The algorithms compose because they share the standard
concepts, not because they share a specific socket implementation. This
is a dramatically smaller standardization surface than either
<code>std::execution</code> or full networking. And it solves the
coordination problem: if everyone writes algorithms against the same
buffer concepts, those algorithms interoperate regardless of the
transport.</p>
<hr />
<h2 id="conclusion">6. Conclusion</h2>
<p>The committee recognized the need for a standard async model. That
recognition was right. The question is one of priority.</p>
<p>GPU computing has CUDA, oneTBB, Kokkos, Taskflow, and stdexec on
vcpkg. That ecosystem is thriving without the standard’s help.
Networking has no standard foundation at all. The tower of abstraction
that every other language enjoys does not exist in C++.</p>
<p>The committee’s energy is finite. Directing it toward the problem
that only the standard can solve, an agreed-upon async I/O model that
enables composable algorithms across library boundaries, would serve
more C++ programmers than any other single investment the committee
could make.</p>
<p>C++20 gave us coroutines. The building blocks are in the language.
Twenty years of Asio practice and emerging libraries like Capy and
IoAwaitables show that the design space is rich and worth exploring. The
work is not finished, but the direction is clear.</p>
<p>The C++ Standard cannot connect to the Internet. It should.</p>
<hr />
<h2 id="references">References</h2>
<ol type="1">
<li><p>Boost.Asio.
https://www.boost.org/doc/libs/release/doc/html/boost_asio.html</p></li>
<li><p>Standalone Asio. https://github.com/chriskohlhoff/asio</p></li>
<li><p>folly::coro. Meta.
https://github.com/facebook/folly/blob/main/folly/experimental/coro/README.md</p></li>
<li><p>Qt Signals and Slots.
https://doc.qt.io/qt-6/signalsandslots.html</p></li>
<li><p>PEP 3156. “Asynchronous IO Support Rebooted: the asyncio Module.”
https://peps.python.org/pep-3156/</p></li>
<li><p>Django. https://github.com/django/django</p></li>
<li><p>TC39 Async/Await Proposal.
https://tc39.es/proposal-async-await/</p></li>
<li><p>Express.js. https://github.com/expressjs/express</p></li>
<li><p>Next.js. https://github.com/vercel/next.js</p></li>
<li><p>Go net/http package. https://pkg.go.dev/net/http</p></li>
<li><p>Rust Blog. “Async-await on stable Rust!” 2019.
https://blog.rust-lang.org/2019/11/07/Async-await-stable/</p></li>
<li><p>Tokio. https://github.com/tokio-rs/tokio</p></li>
<li><p>Axum. https://github.com/tokio-rs/axum</p></li>
<li><p>Spring Boot.
https://github.com/spring-projects/spring-boot</p></li>
<li><p>C# async/await overview.
https://dotnetcurry.com/csharp/869/async-await-csharp-dotnet</p></li>
<li><p>ASP.NET Core. https://github.com/dotnet/aspnetcore</p></li>
<li><p>Boost.Asio (GitHub). https://github.com/boostorg/asio</p></li>
<li><p>P2000R4. “Direction for ISO C++.” WG21, 2022.
https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2000r4.pdf</p></li>
<li><p>nlohmann/json. https://github.com/nlohmann/json</p></li>
<li><p>cpp-httplib. https://github.com/yhirose/cpp-httplib</p></li>
<li><p>fmt. https://github.com/fmtlib/fmt</p></li>
<li><p>Lakos, John. <em>Large-Scale C++ Software Design.</em>
Addison-Wesley, 1996.
https://informit.com/store/large-scale-c-plus-plus-software-design-9780201633627</p></li>
<li><p>Boost.Beast.
https://www.boost.org/doc/libs/release/libs/beast/</p></li>
<li><p>P3185R0. “A proposed direction for C++ Standard Networking based
on IETF TAPS.” WG21. https://wg21.link/p3185r0</p></li>
<li><p>Networking TS reference implementation. Kohlhoff.
https://github.com/chriskohlhoff/networking-ts-impl</p></li>
<li><p>P2453R0. “2021 October Library Evolution and Concurrency
Networking and Executors Poll Outcomes.” WG21, 2022.
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2453r0.html</p></li>
<li><p>P2300R10. Dominiak et al. “std::execution.” WG21, 2024.
https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html</p></li>
<li><p>stdexec. NVIDIA. https://nvidia.github.io/stdexec/</p></li>
<li><p>Burja, Samo. <em>Great Founder Theory.</em> 2020.
https://www.samoburja.com/gft/</p></li>
<li><p>NVIDIA CUDA C/C++ Language Extensions.
https://docs.nvidia.com/cuda/cuda-programming-guide/05-appendices/cpp-language-extensions.html</p></li>
<li><p>stdexec on vcpkg. https://vcpkg.link/ports/stdexec</p></li>
<li><p>P0912R5. “Merging Coroutines into C++20.” WG21.
https://wg21.link/p0912r5</p></li>
<li><p>P3552. “Add a Coroutine Task Type.” WG21.
https://wg21.link/p3552</p></li>
<li><p>D4007R0. Falco. “std::execution Needs More Time.” WG21, 2026.
https://wg21.link/p4007</p></li>
<li><p>P3826R3. Niebler. “Fix Sender Algorithm Customization.” WG21,
2026. https://wg21.link/p3826</p></li>
<li><p>D4003. Falco et al. “IoAwaitables: A Coroutines-Only Execution
Model.” WG21. https://wg21.link/p4003</p></li>
<li><p>TooManyCooks. https://github.com/tzcnt/TooManyCooks</p></li>
<li><p>Capy. https://github.com/cppalliance/capy</p></li>
<li><p>Stepanov. “The Standard Template Library.” 1994.
https://stepanovpapers.com/Stepanov-The_Standard_Template_Library-1994.pdf</p></li>
<li><p>cppreference. “Allocator (named requirement).”
https://en.cppreference.com/w/cpp/named_req/Allocator</p></li>
<li><p>cppreference. “RAII.”
https://en.cppreference.com/w/cpp/language/raii</p></li>
<li><p>C++26 Working Draft, [exec] section.
https://eel.is/c++draft/exec</p></li>
<li><p>Boost.HTTP. https://github.com/cppalliance/http</p></li>
</ol>
</body>
</html>

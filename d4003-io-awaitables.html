<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>d4003-io-awaitables</title>
  <style>

code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
  <style type="text/css">
body {
max-width: 980px;
margin: 0 auto;
padding: 45px;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Noto Sans, Helvetica, Arial, sans-serif;
font-size: 16px;
line-height: 1.5;
color: #1f2328;
background-color: #fff;
}

h1, h2, h3, h4, h5, h6 {
margin-top: 24px;
margin-bottom: 16px;
font-weight: 600;
line-height: 1.25;
}
h1 { font-size: 2em; padding-bottom: 0.3em; border-bottom: 1px solid #d1d9e0; }
h2 { font-size: 1.5em; padding-bottom: 0.3em; border-bottom: 1px solid #d1d9e0; }
h3 { font-size: 1.25em; }
h4 { font-size: 1em; }

p {
margin-top: 0;
margin-bottom: 16px;
}

a {
color: #0969da;
text-decoration: none;
}
a:hover {
text-decoration: underline;
}

code {
padding: 0.2em 0.4em;
margin: 0;
font-size: 85%;
white-space: break-spaces;
background-color: rgba(175, 184, 193, 0.2);
border-radius: 6px;
font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
}

pre {
padding: 16px;
overflow: auto;
font-size: 85%;
line-height: 1.45;
background-color: #f6f8fa;
border-radius: 6px;
margin-bottom: 16px;
}
pre code {
padding: 0;
margin: 0;
font-size: 100%;
background-color: transparent;
border-radius: 0;
}

table {
border-collapse: collapse;
border-spacing: 0;
width: auto;
max-width: 100%;
overflow: auto;
margin-bottom: 16px;
}
th, td {
padding: 6px 13px;
border: 1px solid #d1d9e0;
}
th {
font-weight: 600;
background-color: #f6f8fa;
}
tr:nth-child(2n) {
background-color: #f6f8fa;
}

blockquote {
margin: 0 0 16px 0;
padding: 0 1em;
color: #59636e;
border-left: 0.25em solid #d1d9e0;
}

ul, ol {
margin-top: 0;
margin-bottom: 16px;
padding-left: 2em;
}
li + li {
margin-top: 0.25em;
}

hr {
height: 0.25em;
padding: 0;
margin: 24px 0;
background-color: #d1d9e0;
border: 0;
}

img {
max-width: 100%;
box-sizing: border-box;
}

em {
font-style: italic;
}
strong {
font-weight: 600;
}
</style>
</head>
<body>
<table>
<colgroup>
<col style="width: 58%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr>
<th>Document</th>
<th>BOOST1000</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date:</td>
<td>2026-01-21</td>
</tr>
<tr>
<td>Reply-to:</td>
<td>Vinnie Falco &lt;vinnie.falco@gmail.com&gt;<br>Steve Gerbino
&lt;steve@gerbino.co&gt;<br>Amlal El Mahrouss
&lt;amlalelmahrouss@icloud.com&gt;<br>Mungo Gill
&lt;mungo.gill@me.com&gt;</td>
</tr>
<tr>
<td>Audience:</td>
<td>Boost, C++</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="ioawaitables-a-coroutines-first-execution-model">IoAwaitables: A
Coroutines-First Execution Model</h1>
<h2 id="abstract">Abstract</h2>
<p>This paper asks: <em>what would an execution model look like if
designed from the ground up for coroutine-only asynchronous
I/O?</em></p>
<p>An execution model answers how asynchronous work is scheduled and
dispatched, where operation state is allocated and by whom, and what
customization points allow users to adapt the framework’s behavior. We
propose a <strong>coroutines-only</strong> execution model optimized for
CPU-bound I/O workloads. The framework introduces the
<em>IoAwaitable</em> protocol: a system for associating a coroutine with
an executor, stop token, and allocator, and propagating this context
forward through a coroutine chain which can end at an operating system
API boundary where asynchronous operations are performed.</p>
<p>We compare our use-case-first driven design against
<code>std::execution</code> (<a href="https://wg21.link/p2300">P2300</a>) and observe significant
divergence. Analysis of <a href="https://wg21.link/p2300">P2300</a> and
its evolution (<a href="https://wg21.link/p3826">P3826</a>) reveals a
framework driven by GPU and parallel workloads—<a href="https://wg21.link/p3826">P3826</a>’s focus is overwhelmingly
GPU/parallel with no networking discussion. Core networking
concerns—strand serialization, I/O completion contexts, platform
integration—remain unaddressed. The query-based context model that <a href="https://wg21.link/p3826">P3826</a> attempts to fix is unnecessary
when context propagates forward through coroutine machinery.</p>
<p>Our framework demonstrates what emerges when networking requirements
drive the design rather than being adapted to a GPU-focused
abstraction.</p>
<hr />
<h2 id="introduction">1. Introduction</h2>
<p>The C++ standardization effort has produced
<code>std::execution</code> (<a href="https://wg21.link/p2300">P2300</a>), a sender/receiver framework
for structured concurrency. Its design accommodates heterogeneous
computing—GPU kernels, parallel algorithms, and hardware accelerators.
The machinery is substantial: domains select algorithm implementations,
queries determine completion schedulers, and transforms dispatch work to
appropriate backends.</p>
<p>But what does asynchronous I/O actually need?</p>
<p>A network server completes read operations on I/O threads, resumes
handlers on application threads, and serializes access to connection
state. A file system service batches completions through io_uring,
dispatches callbacks to worker pools, and manages buffer lifetimes
across suspension points. These patterns repeat across every
I/O-intensive application. None of them require domain-based algorithm
dispatch. TCP servers do not run on GPUs. Socket reads have one
implementation per platform, not multiple hardware backends.</p>
<p><strong>This paper explores what emerges when I/O requirements drive
the design.</strong></p>
<p>We find that two operations for resuming coroutines suffice:
<code>dispatch</code> for continuations and <code>post</code> for
independent work. The choice between them is correctness, not
performance. Using dispatch while holding a mutex invites deadlock.
Using post for every continuation wastes cycles bouncing through queues.
But primitives alone don’t solve the composition problem. In a chain
like <code>async_http_request → async_read → socket</code>, who decides
which allocator to use? Who determines which executor runs the
completion? How are operations canceled? The answers are discovered from
studying the use case:</p>
<ul>
<li><p><strong>The application decides executor policy.</strong> Thread
affinity, strand serialization, priority scheduling; these are
deployment decisions. A read operation doesn’t care which thread pool it
runs on. The application architecture determines where completions
should resume.</p></li>
<li><p><strong>The application sends stop signals.</strong> Cancellation
flows downward from application logic, not upward from I/O operations. A
timeout, user abort, or graceful shutdown originates at the application
layer and propagates to pending operations. The socket doesn’t decide
when to cancel itself.</p></li>
<li><p><strong>The application decides allocation policy.</strong>
Memory strategies: recycling pools, bounded allocation, per-tenant
budgets; these are a property of the coroutine chain, not the I/O
operation. A socket doesn’t care about memory policy; the context in
which it runs does.</p></li>
<li><p><strong>The execution context owns its I/O objects.</strong> A
socket registered with epoll on thread A cannot have completions
delivered to thread B’s epoll. The physical coupling is inherent. The
call site cannot know which event loop the socket uses—only the socket
knows.</p></li>
</ul>
<p>Execution context flows naturally <em>forward</em> through async
operation chains. The executor, stop token, and allocator propagate from
caller to callee at each suspension point. This forward flow addresses
the late-binding challenge differently than <code>std::execution</code>:
context is known at launch site, not discovered through receiver queries
after the work graph is built. Our goal is not to replace
<code>std::execution</code> for GPU workloads—it is to demonstrate that
networking deserves a purpose-built abstraction rather than adaptation
to a framework optimized for different requirements.</p>
<blockquote>
<p><strong>Convention.</strong> Throughout this document we use the
following type alias:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> coro <span class="op">=</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
</blockquote>
<hr />
<h2 id="understanding-asynchronous-io">2. Understanding Asynchronous
I/O</h2>
<p>Not every committee member or library reviewer works with network
programming daily, and the challenges that shape I/O library design may
not be immediately obvious from other domains. This section provides the
background needed to evaluate the design decisions that follow. The
concepts presented here draw heavily from Christopher Kohlhoff’s
pioneering work on Boost.Asio, which has served the C++ community for
over two decades, and from Gor Nishanov’s C++ coroutines that now enable
elegant expression of asynchronous control flow. Readers already
familiar with event loops, completion handlers, and executor models may
skip ahead to §3.</p>
<h3 id="the-problem-with-waiting">2.1 The Problem with Waiting</h3>
<p>Network I/O operates on a fundamentally different timescale than
computation. A CPU executes billions of instructions per second; reading
a single byte from a local network takes microseconds, and from a remote
server, milliseconds. The disparity is stark:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Approximate Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU instruction</td>
<td>0.3 ns</td>
</tr>
<tr>
<td>L1 cache access</td>
<td>1 ns</td>
</tr>
<tr>
<td>Main memory access</td>
<td>100 ns</td>
</tr>
<tr>
<td>Local network round-trip</td>
<td>500 μs</td>
</tr>
<tr>
<td>Internet round-trip</td>
<td>50-200 ms</td>
</tr>
</tbody>
</table>
<p>When code calls a blocking read on a socket, the thread waits—doing
nothing—while the network delivers data. During a 100ms network
round-trip, a modern CPU could have executed 300 billion instructions.
Blocking I/O wastes this potential.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Blocking I/O: thread waits here</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> buf<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">ssize_t</span> n <span class="op">=</span> recv<span class="op">(</span>fd<span class="op">,</span> buf<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>buf<span class="op">),</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// Thread blocked</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>process<span class="op">(</span>buf<span class="op">,</span> n<span class="op">);</span></span></code></pre></div>
<p>For a single connection, this inefficiency is tolerable. For a server
handling thousands of connections, it becomes catastrophic.</p>
<h3 id="the-thread-per-connection-trap">2.2 The Thread-Per-Connection
Trap</h3>
<p>The natural response to blocking I/O is to spawn a thread per
connection. Each thread blocks on its own socket; while one waits,
others make progress.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> handle_client<span class="op">(</span>socket client<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> buf<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">[</span>ec<span class="op">,</span> n<span class="op">]</span> <span class="op">=</span> client<span class="op">.</span>read_some<span class="op">(</span>buf<span class="op">);</span> <span class="op">!</span>ec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        process<span class="op">(</span>buf<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Spawn a thread for each connection</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    socket client <span class="op">=</span> accept<span class="op">(</span>listener<span class="op">);</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread<span class="op">(</span>handle_client<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>client<span class="op">)).</span>detach<span class="op">();</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This works—until it doesn’t. Each thread consumes memory (typically
1MB for the stack) and creates scheduling overhead. Context switches
between threads cost thousands of CPU cycles. At 10,000 connections, you
have 10,000 threads consuming 10GB of stack space, and the scheduler
spends more time switching between threads than running actual code.</p>
<p>The <a href="http://www.kegel.com/c10k.html">C10K
problem</a>—handling 10,000 concurrent connections—revealed that
thread-per-connection doesn’t scale. Modern servers handle millions of
connections. Something else is needed.</p>
<h3 id="event-driven-io">2.3 Event-Driven I/O</h3>
<p>The solution is to invert the relationship between threads and I/O
operations. Instead of one thread per connection, use a small number of
threads that multiplex across many connections. The operating system
provides mechanisms to wait for <em>any</em> of a set of file
descriptors to become ready:</p>
<ul>
<li><strong>Linux</strong>: <code>epoll</code> — register interest in
file descriptors, wait for events</li>
<li><strong>Windows</strong>: I/O Completion Ports (IOCP) — queue-based
completion notification</li>
<li><strong>BSD/macOS</strong>: <code>kqueue</code> — unified event
notification</li>
</ul>
<p>These mechanisms enable the <strong>proactor pattern</strong>:
instead of blocking until an operation completes, you <em>initiate</em>
an operation and receive notification when it finishes. The thread is
free to do other work in the meantime.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>io_context ioc<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>socket sock<span class="op">(</span>ioc<span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sock<span class="op">.</span>open<span class="op">();</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Initiate an async operation - returns immediately</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>ec<span class="op">]</span> <span class="op">=</span> <span class="cf">co_await</span> sock<span class="op">.</span><span class="fu">connect</span><span class="op">(</span>endpoint<span class="op">(</span>ipv4_address<span class="op">::</span>loopback<span class="op">(),</span> <span class="dv">8080</span><span class="op">));</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Execution resumes here when the connection completes</span></span></code></pre></div>
<p>The <code>io_context</code> is the heart of this model. It maintains
a queue of pending operations and dispatches completions as they arrive
from the OS. Calling <code>ioc.run()</code> processes this queue:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>io_context ioc<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ... set up async operations ...</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ioc<span class="op">.</span>run<span class="op">();</span>  <span class="co">// Process completions until no work remains</span></span></code></pre></div>
<p>A single thread calling <code>run()</code> can service thousands of
connections. For CPU-bound workloads, multiple threads can call
<code>run()</code> on the same context, processing completions in
parallel.</p>
<h3 id="completion-handlers-and-coroutines">2.4 Completion Handlers and
Coroutines</h3>
<p>Early asynchronous APIs used callbacks to handle completions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Callback-based async (traditional style)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>socket<span class="op">.</span>async_read<span class="op">(</span>buffer<span class="op">,</span> <span class="op">[](</span>error_code ec<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>ec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Process data, then start another read...</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        socket<span class="op">.</span>async_read<span class="op">(</span>buffer<span class="op">,</span> <span class="op">[](</span>error_code ec<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// More nesting...</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span></code></pre></div>
<p>This “callback hell” inverts control flow, making code hard to follow
and debug. Error handling becomes scattered across nested lambdas. State
must be explicitly captured and managed.</p>
<p>C++20 coroutines restore sequential control flow while preserving the
efficiency of asynchronous execution:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Coroutine-based async (modern style)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;&gt;</span> handle_connection<span class="op">(</span>socket sock<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> buf<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">[</span>ec<span class="op">,</span> n<span class="op">]</span> <span class="op">=</span> <span class="cf">co_await</span> sock<span class="op">.</span>read_some<span class="op">(</span>buf<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>ec<span class="op">)</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">co_await</span> process_data<span class="op">(</span>buf<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>co_await</code> keyword suspends the coroutine until the
operation completes, then resumes execution at that point. The code
reads sequentially, but executes asynchronously. The
<code>task&lt;&gt;</code> return type represents a coroutine that can be
awaited by a caller or launched independently.</p>
<h3 id="the-execution-context">2.5 The Execution Context</h3>
<p>I/O objects must be associated with an execution context that manages
their lifecycle and delivers completions. A <code>socket</code> created
with an <code>io_context</code> is registered with that context’s
platform reactor (epoll, IOCP, etc.). This binding is physical—the
socket’s file descriptor is registered with specific kernel
structures.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>io_context ioc<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>socket sock<span class="op">(</span>ioc<span class="op">);</span>  <span class="co">// Socket bound to this context</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>sock<span class="op">.</span>open<span class="op">();</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">// The socket&#39;s completions will be delivered through ioc</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>ec<span class="op">]</span> <span class="op">=</span> <span class="cf">co_await</span> sock<span class="op">.</span><span class="fu">connect</span><span class="op">(</span>endpoint<span class="op">);</span></span></code></pre></div>
<p>This binding has implications: - A socket cannot migrate between
contexts - Completions are delivered to the context that owns the socket
- The context must remain alive while operations are pending</p>
<p>The <code>io_context</code> abstracts platform differences. On
Windows, it wraps an I/O Completion Port. On Linux, it wraps epoll (or
io_uring). Application code remains portable while the implementation
leverages platform-specific optimizations.</p>
<h3 id="executors">2.6 Executors</h3>
<p>An <strong>executor</strong> determines where and how work runs. It
answers: when an async operation completes, which thread should run the
completion handler? Should it run immediately, or be queued for
later?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ex <span class="op">=</span> ioc<span class="op">.</span>get_executor<span class="op">();</span></span></code></pre></div>
<p>The executor provides two fundamental operations:</p>
<p><strong><code>dispatch</code></strong> — Run work immediately if
safe, otherwise queue it. When the I/O context thread detects a
completion, it typically dispatches the waiting coroutine inline for
minimal latency.</p>
<p><strong><code>post</code></strong> — Always queue work for later
execution. Use this when you need a guarantee that the work won’t run
until after the current function returns—for example, when holding a
lock.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Dispatch: may run inline</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>ex<span class="op">.</span>dispatch<span class="op">(</span>continuation<span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Post: always queued</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>ex<span class="op">.</span>post<span class="op">(</span>new_work<span class="op">);</span></span></code></pre></div>
<p>The distinction matters for correctness. Dispatching while holding a
mutex could cause the completion handler to run immediately, potentially
deadlocking if it tries to acquire the same mutex. Posting guarantees
the handler runs later, after the lock is released.</p>
<h3 id="strands-serialization-without-locks">2.7 Strands: Serialization
Without Locks</h3>
<p>When multiple threads call <code>ioc.run()</code>, completions may
execute concurrently. If two coroutines access shared state, you need
synchronization. Mutexes work but introduce blocking—the very thing
async I/O tries to avoid.</p>
<p>A <strong>strand</strong> provides an alternative: it guarantees that
handlers submitted through it never execute concurrently, without using
locks.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>strand my_strand<span class="op">(</span>ioc<span class="op">.</span>get_executor<span class="op">());</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Entire coroutine runs serialized through the strand</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span>my_strand<span class="op">)(</span>handle_connection<span class="op">(</span>sock<span class="op">));</span></span></code></pre></div>
<p>Handlers on a strand execute in FIFO order, one at a time. Multiple
strands can make progress concurrently on different threads, but within
a single strand, execution is sequential. This enables safe concurrent
access to connection state without explicit locking.</p>
<h3 id="cancellation">2.8 Cancellation</h3>
<p>Long-running operations need a way to stop gracefully. A connection
might timeout. A user might close a window. A server might be shutting
down.</p>
<p>C++20’s <code>std::stop_token</code> provides cooperative
cancellation:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stop_source source<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stop_token token <span class="op">=</span> source<span class="op">.</span>get_token<span class="op">();</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Launch a coroutine with a stop token</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span>ex<span class="op">,</span> token<span class="op">)(</span>long_running_operation<span class="op">());</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Later, request cancellation</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>source<span class="op">.</span>request_stop<span class="op">();</span></span></code></pre></div>
<p>The stop token propagates through the coroutine chain. At the lowest
level, I/O objects observe the token and cancel pending operations with
the appropriate OS primitive (<code>CancelIoEx</code> on Windows,
<code>IORING_OP_ASYNC_CANCEL</code> on Linux). The operation completes
with an error, and the coroutine can handle it normally.</p>
<p>Cancellation is cooperative—no operation is forcibly terminated. The
I/O layer requests cancellation, the OS acknowledges it, and the
operation completes with an error code. This keeps resource cleanup
predictable and avoids the hazards of abrupt termination.</p>
<h3 id="moving-forward">2.9 Moving Forward</h3>
<p>With these fundamentals in hand—event loops, executors, strands, and
cancellation—you have the conceptual vocabulary to understand the design
decisions in the sections that follow. These patterns form the bedrock
of modern C++ networking: every high-performance server, every
responsive client application, builds on some combination of
non-blocking I/O, completion handlers, and execution contexts.</p>
<p>If you’re eager to experiment, the <a href="https://github.com/cppalliance/corosio">Corosio</a> library
implements these concepts in production-ready code. It provides sockets,
timers, TLS, and DNS resolution—all built on the coroutine-first model
we’ll explore in depth. The <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a>
documentation and its many community tutorials offer additional paths to
hands-on learning. Building a simple echo server or chat application is
one of the best ways to internalize how these pieces fit together.</p>
<p>The rest of this paper examines what an execution model looks like
when these networking requirements drive the design from the ground
up.</p>
<hr />
<h2 id="what-networking-needs">3. What Networking Needs</h2>
<p>Networking has specific requirements that differ from parallel
computation. A socket read has <strong>one implementation per
platform</strong>—there’s no algorithm selection, no hardware
heterogeneity to manage. There are other important concerns:</p>
<ul>
<li><strong>Platform implementation</strong>: Integration with IOCP,
epoll, io_uring</li>
<li><strong>Strand serialization</strong>: Ordering guarantees for
concurrent access</li>
<li><strong>Thread affinity</strong>: Handlers must resume on the
correct thread</li>
<li><strong>Inline vs queued</strong>: Choosing whether continuations
run immediately or are deferred</li>
<li><strong>Stack depth control</strong>: Bounding recursion through
trampolining or deferred dispatch</li>
</ul>
<p>Strip these requirements down to their essence. What primitive do
they all depend on? <strong>Something that runs work</strong>. An
<em>executor</em>. Completion contexts, strands, and thread affinity are
all built on executors. I/O objects must be bound to an executor’s
context to work correctly. <a href="https://wg21.link/p2762">P2762</a>
acknowledges this reality in §4.1:</p>
<blockquote>
<p>“It was pointed out networking objects like sockets are specific to a
context: that is necessary when using I/O Completion Ports or a TLS
library and yields advantages when using, e.g., io_uring(2).”</p>
</blockquote>
<h3 id="the-executor">3.1 The Executor</h3>
<p>An executor is to functions what an allocator is to memory: while an
allocator controls <em>where</em> objects live, an executor controls
<em>how</em> functions run. Examining decades of asynchronous I/O
patterns reveals that a minimal executor needs only two operations. The
first operation handles work that continues the current operation—a
completion handler that should run as part of the same logical flow. The
second handles work that must begin independently—a task that cannot
start until after the initiating call returns. These two cases have
distinct correctness requirements, captured by <code>dispatch</code> and
<code>post</code>.</p>
<h4 id="dispatch"><code>dispatch</code></h4>
<p>When an I/O operation completes at the operating system level, the
suspended coroutine must resume. The kernel has signaled that data is
ready or a connection is established; now user code must process the
result. In this context, resuming the coroutine immediately, on the
current thread and without queuing, is both safe and efficient. No locks
are held by the I/O layer. The completion is a natural continuation of
the event loop’s work.</p>
<p>This pattern is captured by <code>dispatch</code>. It resumes the
provided coroutine immediately if doing so is safe within the executor’s
rules, or queues it otherwise. For a strand, “safe” means no other
coroutine is currently executing on that strand. For a thread pool, it
might mean the caller is already on a pool thread. The executor decides;
the caller simply requests execution.</p>
<p>This is the common case for I/O completions. The event loop calls
<code>dispatch</code> with the coroutine, and in the typical case the
coroutine resumes inline without touching any queue. The result is
minimal latency and zero allocation for the dispatch itself.</p>
<h4 id="post"><code>post</code></h4>
<p>Sometimes inline execution is not just inefficient but incorrect.
Consider code that initiates an async operation while holding a mutex,
expecting the lock to be released before the completion runs. Or a
destructor that launches cleanup work and must return before that work
begins. These patterns require a guarantee: the coroutine will not
execute before the call returns.</p>
<p>The <code>post</code> operation provides this guarantee. It always
queues coroutines for later execution, never running inline. The caller
can rely on control returning before the coroutine begins. This makes
<code>post</code> suitable for breaking call chains, avoiding
reentrancy, and ensuring ordering when the caller’s state must settle
before continuation.</p>
<p>The cost is queue insertion and eventual dequeue—cycles that
<code>dispatch</code> avoids when inline execution is safe. But when
correctness requires deferred execution, <code>post</code> is the only
sound choice.</p>
<h3 id="the-stop_token">3.2 The <code>stop_token</code></h3>
<p>C++20 introduced <code>std::stop_token</code> as a cooperative
cancellation mechanism. A <code>stop_source</code> owns the cancellation
state; the token provides a read-only view that can be queried or used
to register callbacks. When <code>stop_source::request_stop()</code> is
called, all associated tokens observe the cancellation and registered
callbacks fire.</p>
<p>Cancellation flows downward. The application—not the I/O
operation—decides when to stop. A timeout, user abort, or graceful
shutdown originates at the application layer and propagates to pending
operations. The socket doesn’t decide when to cancel itself; it receives
a stop request from above.</p>
<p>In our model, the stop token is injected at the coroutine launch site
and propagated through the entire chain. Consider:</p>
<pre><code>http_client → http_request → write → write_some → socket</code></pre>
<p>The top-level caller provides a <code>stop_token</code>. Each
coroutine in the chain receives it and passes it forward. At the end of
the chain, the I/O object—the socket—receives the token and can act on
it.</p>
<p>This is where the operating system enters. Modern platforms provide
cancellation at the kernel level:</p>
<ul>
<li><strong>Windows IOCP</strong>: <code>CancelIoEx</code> cancels
pending overlapped operations on a specific handle</li>
<li><strong>Linux io_uring</strong>: <code>IORING_OP_ASYNC_CANCEL</code>
cancels a previously submitted operation by its user data</li>
<li><strong>POSIX</strong>: <code>close()</code> on the file descriptor,
though less graceful, interrupts blocking operations</li>
</ul>
<p>When the stop token signals cancellation, the I/O object registers a
callback that invokes the appropriate OS primitive. The pending
operation completes with an error—typically
<code>operation_aborted</code>—and the coroutine chain unwinds normally
through its error path.</p>
<p>This design keeps cancellation cooperative and predictable. No
operation is forcibly terminated mid-flight. The I/O layer requests
cancellation; the OS acknowledges it; the operation completes with an
error; the coroutine handles the error. Each layer respects the
boundaries of the next.</p>
<h3 id="the-allocator">3.3 The Allocator</h3>
<p>Neither callbacks nor coroutines achieve competitive performance
without allocation control. Early testing showed that fully type-erased
callbacks—using <code>std::function</code> at every composition
boundary—allocated hundreds of times per invocation and ran an order of
magnitude slower than native templates. Non-recycling coroutine
configurations perform so poorly, dominated by heap allocation overhead,
that they are not worth benchmarking.</p>
<p><strong>Recycling is mandatory for performance.</strong> Thread-local
recycling—caching recently freed memory for immediate reuse—enables zero
steady-state allocations. Callbacks achieve this through “delete before
dispatch”: deallocate operation state before invoking the completion
handler. Coroutines achieve it through frame pooling: custom
<code>operator new/delete</code> recycles frames across operations.</p>
<p>But thread-local recycling optimizes for throughput, not all
applications. Different deployments have different needs:</p>
<ul>
<li><strong>Memory conservation</strong>: Embedded systems or
resource-constrained environments may prefer bounded pools over
unbounded caches</li>
<li><strong>Per-tenant limits</strong>: Multi-tenant servers need
allocation budgets per client to prevent resource exhaustion</li>
<li><strong>Debugging and profiling</strong>: Development builds may
want allocation tracking that production builds eliminate</li>
</ul>
<p>Coroutines are continuously created—every <code>co_await</code> may
spawn new frames. An execution model must make allocation a first-class
customization point that controls <em>all</em> coroutine allocations,
not just selected operations. Without this, memory policy becomes
impossible to enforce.</p>
<p><strong>The allocator must be present at invocation.</strong>
Coroutine frame allocation has a fundamental timing constraint:
<code>operator new</code> executes before the coroutine body. When a
coroutine is called, the compiler allocates the frame first, then begins
execution. Any mechanism that injects context later—receiver connection,
<code>await_transform</code>, explicit method calls—arrives too
late.</p>
<p><a href="https://wg21.link/p2762">P2762</a> acknowledges that the
receiver-based model brings scheduler and operation together “rather
late”—at <code>connect()</code> time, after the work graph is already
built:</p>
<blockquote>
<p>“When the scheduler is injected through the receiver the operation
and used scheduler are brought together rather late, i.e., when
<code>connect(sender, receiver)</code>ing and when the work graph is
already built.”</p>
</blockquote>
<p>For coroutines, this timing is fundamentally incompatible with frame
allocation. The allocator must be discoverable from the coroutine’s
launch site before the coroutine frame is created.</p>
<h3 id="backward-flow-in-stdexecution">3.4 Backward Flow in
<code>std::execution</code></h3>
<p>The <code>std::execution</code> model (<a href="https://wg21.link/p2300">P2300</a>) uses a <strong>backward
flow</strong> where context—scheduler, allocator, stop token—is
discovered by querying the receiver’s environment <em>after</em>
connection. For GPU workloads, where the work graph is constructed
before execution begins, this model works well.</p>
<p>For networking, there is a timing problem lurking. We explore the
consequences in §4.7.</p>
<hr />
<h2 id="our-solution-the-ioawaitable-protocol">4. Our Solution: The
<em>IoAwaitable</em> Protocol</h2>
<p>The <em>IoAwaitable</em> protocol is a family of concepts layered on
top of each other, working together to deliver what coroutines and
networking need for correctness and performance:</p>
<p><img role="img" aria-label src="data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iLTggLTggMTE0MS4yOTY4NzUgNTAiIHN0eWxlPSJtYXgtd2lkdGg6IDExNDEuM3B4OyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBpZD0ibXktc3ZnIj48c3R5bGU+I215LXN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7ZmlsbDojMzMzO30jbXktc3ZnIC5lcnJvci1pY29ue2ZpbGw6IzU1MjIyMjt9I215LXN2ZyAuZXJyb3ItdGV4dHtmaWxsOiM1NTIyMjI7c3Ryb2tlOiM1NTIyMjI7fSNteS1zdmcgLmVkZ2UtdGhpY2tuZXNzLW5vcm1hbHtzdHJva2Utd2lkdGg6MnB4O30jbXktc3ZnIC5lZGdlLXRoaWNrbmVzcy10aGlja3tzdHJva2Utd2lkdGg6My41cHg7fSNteS1zdmcgLmVkZ2UtcGF0dGVybi1zb2xpZHtzdHJva2UtZGFzaGFycmF5OjA7fSNteS1zdmcgLmVkZ2UtcGF0dGVybi1kYXNoZWR7c3Ryb2tlLWRhc2hhcnJheTozO30jbXktc3ZnIC5lZGdlLXBhdHRlcm4tZG90dGVke3N0cm9rZS1kYXNoYXJyYXk6Mjt9I215LXN2ZyAubWFya2Vye2ZpbGw6IzMzMzMzMztzdHJva2U6IzMzMzMzMzt9I215LXN2ZyAubWFya2VyLmNyb3Nze3N0cm9rZTojMzMzMzMzO30jbXktc3ZnIHN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7fSNteS1zdmcgLmxhYmVse2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtjb2xvcjojMzMzO30jbXktc3ZnIC5jbHVzdGVyLWxhYmVsIHRleHR7ZmlsbDojMzMzO30jbXktc3ZnIC5jbHVzdGVyLWxhYmVsIHNwYW4sI215LXN2ZyBwe2NvbG9yOiMzMzM7fSNteS1zdmcgLmxhYmVsIHRleHQsI215LXN2ZyBzcGFuLCNteS1zdmcgcHtmaWxsOiMzMzM7Y29sb3I6IzMzMzt9I215LXN2ZyAubm9kZSByZWN0LCNteS1zdmcgLm5vZGUgY2lyY2xlLCNteS1zdmcgLm5vZGUgZWxsaXBzZSwjbXktc3ZnIC5ub2RlIHBvbHlnb24sI215LXN2ZyAubm9kZSBwYXRoe2ZpbGw6I0VDRUNGRjtzdHJva2U6IzkzNzBEQjtzdHJva2Utd2lkdGg6MXB4O30jbXktc3ZnIC5mbG93Y2hhcnQtbGFiZWwgdGV4dHt0ZXh0LWFuY2hvcjptaWRkbGU7fSNteS1zdmcgLm5vZGUgLmthdGV4IHBhdGh7ZmlsbDojMDAwO3N0cm9rZTojMDAwO3N0cm9rZS13aWR0aDoxcHg7fSNteS1zdmcgLm5vZGUgLmxhYmVse3RleHQtYWxpZ246Y2VudGVyO30jbXktc3ZnIC5ub2RlLmNsaWNrYWJsZXtjdXJzb3I6cG9pbnRlcjt9I215LXN2ZyAuYXJyb3doZWFkUGF0aHtmaWxsOiMzMzMzMzM7fSNteS1zdmcgLmVkZ2VQYXRoIC5wYXRoe3N0cm9rZTojMzMzMzMzO3N0cm9rZS13aWR0aDoyLjBweDt9I215LXN2ZyAuZmxvd2NoYXJ0LWxpbmt7c3Ryb2tlOiMzMzMzMzM7ZmlsbDpub25lO30jbXktc3ZnIC5lZGdlTGFiZWx7YmFja2dyb3VuZC1jb2xvcjojZThlOGU4O3RleHQtYWxpZ246Y2VudGVyO30jbXktc3ZnIC5lZGdlTGFiZWwgcmVjdHtvcGFjaXR5OjAuNTtiYWNrZ3JvdW5kLWNvbG9yOiNlOGU4ZTg7ZmlsbDojZThlOGU4O30jbXktc3ZnIC5sYWJlbEJrZ3tiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLCAyMzIsIDIzMiwgMC41KTt9I215LXN2ZyAuY2x1c3RlciByZWN0e2ZpbGw6I2ZmZmZkZTtzdHJva2U6I2FhYWEzMztzdHJva2Utd2lkdGg6MXB4O30jbXktc3ZnIC5jbHVzdGVyIHRleHR7ZmlsbDojMzMzO30jbXktc3ZnIC5jbHVzdGVyIHNwYW4sI215LXN2ZyBwe2NvbG9yOiMzMzM7fSNteS1zdmcgZGl2Lm1lcm1haWRUb29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO21heC13aWR0aDoyMDBweDtwYWRkaW5nOjJweDtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEycHg7YmFja2dyb3VuZDpoc2woODAsIDEwMCUsIDk2LjI3NDUwOTgwMzklKTtib3JkZXI6MXB4IHNvbGlkICNhYWFhMzM7Ym9yZGVyLXJhZGl1czoycHg7cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4OjEwMDt9I215LXN2ZyAuZmxvd2NoYXJ0VGl0bGVUZXh0e3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6MThweDtmaWxsOiMzMzM7fSNteS1zdmcgOnJvb3R7LS1tZXJtYWlkLWZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjt9PC9zdHlsZT48Zz48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMiIgbWFya2VyV2lkdGg9IjEyIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjYiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LXBvaW50RW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDAgTCAxMCA1IEwgMCAxMCB6Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTIiIG1hcmtlcldpZHRoPSIxMiIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSI0LjUiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LXBvaW50U3RhcnQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDAgNSBMIDEwIDEwIEwgMTAgMCB6Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSIxMSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydCIgaWQ9Im15LXN2Z19mbG93Y2hhcnQtY2lyY2xlRW5kIj48Y2lyY2xlIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiByPSI1IiBjeT0iNSIgY3g9IjUiLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9Ii0xIiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0IiBpZD0ibXktc3ZnX2Zsb3djaGFydC1jaXJjbGVTdGFydCI+PGNpcmNsZSBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgcj0iNSIgY3k9IjUiIGN4PSI1Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1LjIiIHJlZlg9IjEyIiB2aWV3Qm94PSIwIDAgMTEgMTEiIGNsYXNzPSJtYXJrZXIgY3Jvc3MgZmxvd2NoYXJ0IiBpZD0ibXktc3ZnX2Zsb3djaGFydC1jcm9zc0VuZCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMjsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUuMiIgcmVmWD0iLTEiIHZpZXdCb3g9IjAgMCAxMSAxMSIgY2xhc3M9Im1hcmtlciBjcm9zcyBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LWNyb3NzU3RhcnQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDI7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5Ii8+PC9tYXJrZXI+PGcgY2xhc3M9InJvb3QiPjxnIGNsYXNzPSJjbHVzdGVycyIvPjxnIGNsYXNzPSJlZGdlUGF0aHMiPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjbXktc3ZnX2Zsb3djaGFydC1wb2ludEVuZCkiIHN0eWxlPSJmaWxsOm5vbmU7IiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayBMUy1Jb0F3YWl0YWJsZSBMRS1Jb0F3YWl0YWJsZVRhc2siIGlkPSJMLUlvQXdhaXRhYmxlLUlvQXdhaXRhYmxlVGFzay0wIiBkPSJNMjA4LjYyNSwxN0wyMTIuNzkyLDE3QzIxNi45NTgsMTcsMjI1LjI5MiwxNywyMzIuNzQyLDE3QzI0MC4xOTIsMTcsMjQ2Ljc1OCwxNywyNTAuMDQyLDE3TDI1My4zMjUsMTciLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtcG9pbnRFbmQpIiBzdHlsZT0iZmlsbDpub25lOyIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsgTFMtSW9Bd2FpdGFibGVUYXNrIExFLUlvTGF1bmNoYWJsZVRhc2siIGlkPSJMLUlvQXdhaXRhYmxlVGFzay1Jb0xhdW5jaGFibGVUYXNrLTAiIGQ9Ik01MzcuNjU2LDE3TDU0MS44MjMsMTdDNTQ1Ljk5LDE3LDU1NC4zMjMsMTcsNTYxLjc3MywxN0M1NjkuMjIzLDE3LDU3NS43OSwxNyw1NzkuMDczLDE3TDU4Mi4zNTYsMTciLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtcG9pbnRFbmQpIiBzdHlsZT0iZmlsbDpub25lOyIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsgTFMtSW9MYXVuY2hhYmxlVGFzayBMRS10YXNrIiBpZD0iTC1Jb0xhdW5jaGFibGVUYXNrLXRhc2stMCIgZD0iTTg4NC4yODEsMTdMODg4LjQ0OCwxN0M4OTIuNjE1LDE3LDkwMC45NDgsMTcsOTA4LjM5OCwxN0M5MTUuODQ4LDE3LDkyMi40MTUsMTcsOTI1LjY5OCwxN0w5MjguOTgxLDE3Ii8+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWxzIj48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2hpdGUtc3BhY2U6IG5vd3JhcDsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48L2c+PGcgY2xhc3M9Im5vZGVzIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMDQuMzEyNSwgMTcpIiBkYXRhLWlkPSJJb0F3YWl0YWJsZSIgZGF0YS1ub2RlPSJ0cnVlIiBpZD0iZmxvd2NoYXJ0LUlvQXdhaXRhYmxlLTAiIGNsYXNzPSJub2RlIGRlZmF1bHQgZGVmYXVsdCBmbG93Y2hhcnQtbGFiZWwiPjxyZWN0IGhlaWdodD0iMzQiIHdpZHRoPSIyMDguNjI1IiB5PSItMTciIHg9Ii0xMDQuMzEyNSIgcnk9IjAiIHJ4PSIwIiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTk2LjgxMjUsIC05LjUpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjE5IiB3aWR0aD0iMTkzLjYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPklvQXdhaXRhYmxlPC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5OC4xNDA2MjUsIDE3KSIgZGF0YS1pZD0iSW9Bd2FpdGFibGVUYXNrIiBkYXRhLW5vZGU9InRydWUiIGlkPSJmbG93Y2hhcnQtSW9Bd2FpdGFibGVUYXNrLTEiIGNsYXNzPSJub2RlIGRlZmF1bHQgZGVmYXVsdCBmbG93Y2hhcnQtbGFiZWwiPjxyZWN0IGhlaWdodD0iMzQiIHdpZHRoPSIyNzkuMDMxMjUiIHk9Ii0xNyIgeD0iLTEzOS41MTU2MjUiIHJ5PSIwIiByeD0iMCIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMzIuMDE1NjI1LCAtOS41KSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIxOSIgd2lkdGg9IjI2NC4wMzEyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPklvQXdhaXRhYmxlVGFzazwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3MzUuOTY4NzUsIDE3KSIgZGF0YS1pZD0iSW9MYXVuY2hhYmxlVGFzayIgZGF0YS1ub2RlPSJ0cnVlIiBpZD0iZmxvd2NoYXJ0LUlvTGF1bmNoYWJsZVRhc2stMiIgY2xhc3M9Im5vZGUgZGVmYXVsdCBkZWZhdWx0IGZsb3djaGFydC1sYWJlbCI+PHJlY3QgaGVpZ2h0PSIzNCIgd2lkdGg9IjI5Ni42MjUiIHk9Ii0xNyIgeD0iLTE0OC4zMTI1IiByeT0iMCIgcng9IjAiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTQwLjgxMjUsIC05LjUpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjE5IiB3aWR0aD0iMjgxLjYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPklvTGF1bmNoYWJsZVRhc2s8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAyOS43ODkwNjI1LCAxNykiIGRhdGEtaWQ9InRhc2siIGRhdGEtbm9kZT0idHJ1ZSIgaWQ9ImZsb3djaGFydC10YXNrLTMiIGNsYXNzPSJub2RlIGRlZmF1bHQgZGVmYXVsdCBmbG93Y2hhcnQtbGFiZWwiPjxyZWN0IGhlaWdodD0iMzQiIHdpZHRoPSIxOTEuMDE1NjI1IiB5PSItMTciIHg9Ii05NS41MDc4MTI1IiByeT0iMCIgcng9IjAiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODguMDA3ODEyNSwgLTkuNSkiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMTkiIHdpZHRoPSIxNzYuMDE1NjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+aW9fdGFzayZsdDtUJmd0Ozwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=" alt /></p>
<p>To help readers understand how these requirements fit together, this
paper provides the <code>io_awaitable_support</code> CRTP mixin (§8.1)
as a non-normative reference implementation. It is not proposed for
standardization—implementors may write their own machinery—but examining
it clarifies how the protocol works in practice. The mixin also provides
the <code>this_coro::executor</code> and
<code>this_coro::stop_token</code> accessors, which allow coroutines to
retrieve their bound context without suspending.</p>
<h3 id="ioawaitable">4.1 IoAwaitable</h3>
<p>The <em>IoAwaitable</em> concept allows a coroutine to receive
<strong>context</strong>: the three things a coroutine needs for I/O—the
executor, the stop token, and the allocator. Context propagates
<strong>forward</strong> from caller to callee using a well-defined,
easy to understand protocol. Most importantly, this protocol <em>does
not require templates</em> in the definition of its coroutine machinery.
Because the protocol uses type-erased wrappers like
<code>executor_ref</code> rather than template parameters, context types
do not leak into the awaitable’s type
signature—<code>task&lt;T&gt;</code> remains simply
<code>task&lt;T&gt;</code>, not
<code>task&lt;T, Executor, StopToken, Allocator&gt;</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span> <span class="kw">typename</span> A <span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> IoAwaitable <span class="op">=</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span><span class="op">(</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        A a<span class="op">,</span> coro h<span class="op">,</span> executor_ref ex<span class="op">,</span> <span class="bu">std::</span>stop_token token <span class="op">)</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        a<span class="op">.</span>await_suspend<span class="op">(</span> h<span class="op">,</span> ex<span class="op">,</span> token <span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>The key insight: <code>await_suspend</code> receives the executor and
stop token as parameters, injected by the caller’s
<code>await_transform</code>. The allocator propagates via
<code>thread_local</code> storage during a narrow execution window with
specific guarantees, ensuring availability at frame allocation time
(more on this later).</p>
<h4 id="satisfying-ioawaitable">Satisfying IoAwaitable</h4>
<p>The <em>IoAwaitable</em> concept is the foundation of the protocol.
Any type that can be <code>co_await</code>ed and participates in context
propagation must satisfy this concept.</p>
<p><strong>Requirements:</strong></p>
<ol type="1">
<li>Implement
<code>await_suspend(std::coroutine_handle&lt;&gt; cont, executor_ref ex, std::stop_token token)</code></li>
<li>Store or forward the executor and stop token as needed</li>
<li>Return a <code>std::coroutine_handle&lt;&gt;</code> for symmetric
transfer (or <code>void</code>/<code>bool</code> per standard
rules)</li>
<li>Implement <code>await_ready()</code> and <code>await_resume()</code>
per standard awaitable requirements</li>
</ol>
<p><strong>Example implementation:</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> my_awaitable</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> await_ready<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This signature satisfies IoAwaitable</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    coro await_suspend<span class="op">(</span> coro cont<span class="op">,</span> executor_ref ex<span class="op">,</span> <span class="bu">std::</span>stop_token token <span class="op">)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Store context for the operation</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">cont_</span> <span class="op">=</span> cont<span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">ex_</span> <span class="op">=</span> ex<span class="op">;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">token_</span> <span class="op">=</span> token<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        start_async_operation<span class="op">();</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>noop_coroutine<span class="op">();</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    T await_resume<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">result_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<blockquote>
<p><strong>Non-normative note.</strong> Implementors may wish to enforce
protocol compliance at API boundaries. When a compliant coroutine’s
<code>await_transform</code> calls the three-argument
<code>await_suspend</code>, a non-compliant awaitable (lacking this
signature) will produce a compile error. Similarly, a compliant
awaitable awaited from a non-compliant coroutine will fail to compile.
This provides static checking that both sides of each suspension point
participate in the protocol:</p>
</blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> await_transform<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IoAwaitable<span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Awaitable does not satisfy IoAwaitable; &quot;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;await_suspend(coro, executor_ref, stop_token) is required&quot;</span><span class="op">);</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return wrapper that forwards to: a.await_suspend(h, executor_, stop_token_)</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="ioawaitabletask">4.2 IoAwaitableTask</h3>
<p>Whereas <em>IoAwaitable</em> allows <em>receiving</em> propagated
context, the <em>IoAwaitableTask</em> refinement adds the promise
interface needed to <strong>store</strong> received context and
<strong>propagate</strong> it to child coroutines. This bidirectional
capability is what distinguishes a task from a simple awaitable—the task
participates fully in the context propagation chain.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> IoAwaitableTask <span class="op">=</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    IoAwaitable<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="op">{</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">;</span> <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span><span class="op">(</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">&amp;</span> p<span class="op">,</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span> <span class="at">const</span><span class="op">&amp;</span> cp<span class="op">,</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        executor_ref ex<span class="op">,</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>stop_token st<span class="op">,</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        coro cont <span class="op">)</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> p<span class="op">.</span>set_executor<span class="op">(</span>ex<span class="op">)</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> p<span class="op">.</span>set_stop_token<span class="op">(</span>st<span class="op">)</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> p<span class="op">.</span>set_continuation<span class="op">(</span>cont<span class="op">,</span> ex<span class="op">)</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> cp<span class="op">.</span>executor<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span> executor_ref <span class="op">&gt;;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> cp<span class="op">.</span>stop_token<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span> <span class="bu">std::</span>stop_token <span class="at">const</span><span class="op">&amp;</span> <span class="op">&gt;;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> cp<span class="op">.</span>complete<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span> coro <span class="op">&gt;;</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>The concept ensures the promise provides the injection interface
(<code>set_executor</code>, <code>set_stop_token</code>) for receiving
context when awaited, and the retrieval interface
(<code>executor</code>, <code>stop_token</code>) for propagating context
to children via <code>await_transform</code>. The
<code>set_continuation</code> and <code>complete</code> functions work
together to implement the <strong>same-executor
optimization</strong>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>coro <span class="dt">promise_type</span><span class="op">::</span>complete<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span> <span class="op">!</span> <span class="va">cont_</span> <span class="op">)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>noop_coroutine<span class="op">();</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span> <span class="va">executor_</span> <span class="op">==</span> <span class="va">caller_ex_</span> <span class="op">)</span> <span class="co">// a single pointer comparison internally</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">cont_</span><span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">caller_ex_</span><span class="op">.</span>dispatch<span class="op">(</span> <span class="va">cont_</span> <span class="op">);</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When a parent <code>co_await</code>s a child task, it calls
<code>set_continuation( cont, caller_ex )</code>, storing both its
coroutine handle and its executor. At completion,
<code>complete()</code> compares the child’s executor against the stored
caller executor: if they match, it returns the continuation directly for
zero-overhead symmetric transfer; if they differ (as with
<code>run_on</code>), it dispatches through the caller’s executor to
ensure the parent resumes in its expected execution context.</p>
<h4 id="satisfying-ioawaitabletask">Satisfying IoAwaitableTask</h4>
<p><strong>Additional requirements (beyond
<em>IoAwaitable</em>):</strong></p>
<ol type="1">
<li>Define a nested <code>promise_type</code></li>
<li>The promise must provide injection methods:
<ul>
<li><code>set_executor(executor_ref)</code> — stores the executor (must
be <code>noexcept</code>)</li>
<li><code>set_stop_token(std::stop_token)</code> — stores the stop token
(must be <code>noexcept</code>)</li>
<li><code>set_continuation(coro, executor_ref)</code> — stores the
continuation handle and caller’s executor (must be
<code>noexcept</code>)</li>
</ul></li>
<li>The promise must provide retrieval methods:
<ul>
<li><code>executor()</code> — returns <code>executor_ref</code> (must be
<code>noexcept</code>)</li>
<li><code>stop_token()</code> — returns
<code>std::stop_token const&amp;</code> (must be
<code>noexcept</code>)</li>
<li><code>complete()</code> — returns a <code>coro</code> for
<code>final_suspend</code> to use for symmetric transfer (must be
<code>noexcept</code>)</li>
</ul></li>
<li>The promise’s <code>await_transform</code> must intercept child
awaitables and inject context</li>
<li>Support <code>operator new</code> overloads for allocator
propagation (read TLS)</li>
</ol>
<p><strong>Example implementation:</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        executor_ref <span class="va">executor_</span><span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        executor_ref <span class="va">caller_ex_</span><span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>stop_token <span class="va">stop_token_</span><span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        coro <span class="va">cont_</span><span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_executor<span class="op">(</span> executor_ref ex <span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="va">executor_</span> <span class="op">=</span> ex<span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_stop_token<span class="op">(</span> <span class="bu">std::</span>stop_token st <span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="va">stop_token_</span> <span class="op">=</span> st<span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_continuation<span class="op">(</span> coro c<span class="op">,</span> executor_ref ex <span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">cont_</span> <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">caller_ex_</span> <span class="op">=</span> ex<span class="op">;</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        executor_ref executor<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">executor_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>stop_token <span class="at">const</span><span class="op">&amp;</span> stop_token<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">stop_token_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>        coro complete<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> <span class="op">!</span> <span class="va">cont_</span> <span class="op">)</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="bu">std::</span>noop_coroutine<span class="op">();</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> <span class="va">executor_</span> <span class="op">==</span> <span class="va">caller_ex_</span> <span class="op">)</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">cont_</span><span class="op">;</span>  <span class="co">// Same-executor optimization</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">caller_ex_</span><span class="op">.</span>dispatch<span class="op">(</span> <span class="va">cont_</span> <span class="op">);</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span><span class="op">&lt;</span>IoAwaitable A<span class="op">&gt;</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> await_transform<span class="op">(</span> A<span class="op">&amp;&amp;</span> awaitable <span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Return wrapper that forwards to:</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">// awaitable.await_suspend(h, executor(), stop_token())</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">...</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ... result storage, initial/final suspend, etc.</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> <span class="va">h_</span><span class="op">;</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> await_ready<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>    T await_resume<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">h_</span><span class="op">.</span>promise<span class="op">().</span>result<span class="op">();</span> <span class="op">}</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Satisfies IoAwaitable and enables IoAwaitableTask</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>    coro await_suspend<span class="op">(</span> coro cont<span class="op">,</span> executor_ref ex<span class="op">,</span> <span class="bu">std::</span>stop_token token <span class="op">)</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">h_</span><span class="op">.</span>promise<span class="op">().</span>set_executor<span class="op">(</span> ex <span class="op">);</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>        <span class="va">h_</span><span class="op">.</span>promise<span class="op">().</span>set_stop_token<span class="op">(</span> token <span class="op">);</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">h_</span><span class="op">.</span>promise<span class="op">().</span>set_continuation<span class="op">(</span> cont<span class="op">,</span> ex <span class="op">);</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">h_</span><span class="op">;</span>  <span class="co">// Transfer to child coroutine</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<blockquote>
<p><strong>Non-normative note.</strong> The
<code>io_awaitable_support</code> CRTP mixin (§8.1) provides all six
required promise methods and is offered as a convenience. It is not
proposed for standardization—implementors may write the boilerplate
themselves.</p>
</blockquote>
<h3 id="iolaunchabletask">4.3 IoLaunchableTask</h3>
<p>The <em>IoLaunchableTask</em> concept further refines
<em>IoAwaitableTask</em> with the interface needed by launch functions
like <code>run_async</code> and <code>run_on</code>. These functions
bootstrap context directly into a task—they call
<code>set_executor</code> and <code>set_stop_token</code> on the promise
rather than going through the three-argument <code>await_suspend</code>.
The concept adds the requirements these functions need:
<code>handle()</code> and <code>release()</code> for lifetime
management, plus <code>exception()</code> and <code>result()</code> for
completion handling.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> IoLaunchableTask <span class="op">=</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    IoAwaitableTask<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span><span class="op">(</span> T<span class="op">&amp;</span> t<span class="op">,</span> T <span class="at">const</span><span class="op">&amp;</span> ct<span class="op">,</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span> <span class="at">const</span><span class="op">&amp;</span> cp <span class="op">)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> ct<span class="op">.</span>handle<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">&gt;</span> <span class="op">&gt;;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> cp<span class="op">.</span>exception<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span> <span class="bu">std::</span>exception_ptr <span class="op">&gt;;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> t<span class="op">.</span>release<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span> <span class="bu">std::</span>is_void_v<span class="op">&lt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&amp;&gt;().</span>await_resume<span class="op">())</span> <span class="op">&gt;</span> <span class="op">||</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>     <span class="kw">requires</span><span class="op">(</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">&amp;</span> p <span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>         p<span class="op">.</span>result<span class="op">();</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>     <span class="op">});</span></span></code></pre></div>
<p><img role="img" aria-label src="data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0ic2VxdWVuY2UiIHJvbGU9ImdyYXBoaWNzLWRvY3VtZW50IGRvY3VtZW50IiB2aWV3Qm94PSItNTAgLTEwIDEwMDQgMzkxIiBzdHlsZT0ibWF4LXdpZHRoOiAxMDA0cHg7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGlkPSJteS1zdmciPjxnPjxyZWN0IGNsYXNzPSJhY3RvciBhY3Rvci1ib3R0b20iIHJ5PSIzIiByeD0iMyIgbmFtZT0iaW8iIGhlaWdodD0iNjUiIHdpZHRoPSIxNTAiIHN0cm9rZT0iIzY2NiIgZmlsbD0iI2VhZWFlYSIgeT0iMzA1IiB4PSI3NTQiLz48dGV4dCBzdHlsZT0idGV4dC1hbmNob3I6IG1pZGRsZTsgZm9udC1zaXplOiAxNnB4OyBmb250LXdlaWdodDogNDAwOyIgY2xhc3M9ImFjdG9yIiBhbGlnbm1lbnQtYmFzZWxpbmU9ImNlbnRyYWwiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIiB5PSIzMzcuNSIgeD0iODI5Ij48dHNwYW4gZHk9IjAiIHg9IjgyOSI+SS9PIG9wZXJhdGlvbjwvdHNwYW4+PC90ZXh0PjwvZz48Zz48cmVjdCBjbGFzcz0iYWN0b3IgYWN0b3ItYm90dG9tIiByeT0iMyIgcng9IjMiIG5hbWU9ImNoaWxkIiBoZWlnaHQ9IjY1IiB3aWR0aD0iMTUwIiBzdHJva2U9IiM2NjYiIGZpbGw9IiNlYWVhZWEiIHk9IjMwNSIgeD0iNTA0Ii8+PHRleHQgc3R5bGU9InRleHQtYW5jaG9yOiBtaWRkbGU7IGZvbnQtc2l6ZTogMTZweDsgZm9udC13ZWlnaHQ6IDQwMDsiIGNsYXNzPSJhY3RvciIgYWxpZ25tZW50LWJhc2VsaW5lPSJjZW50cmFsIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCIgeT0iMzM3LjUiIHg9IjU3OSI+PHRzcGFuIGR5PSIwIiB4PSI1NzkiPmNoaWxkIHRhc2s8L3RzcGFuPjwvdGV4dD48L2c+PGc+PHJlY3QgY2xhc3M9ImFjdG9yIGFjdG9yLWJvdHRvbSIgcnk9IjMiIHJ4PSIzIiBuYW1lPSJwYXJlbnQiIGhlaWdodD0iNjUiIHdpZHRoPSIxNTAiIHN0cm9rZT0iIzY2NiIgZmlsbD0iI2VhZWFlYSIgeT0iMzA1IiB4PSIyNTQiLz48dGV4dCBzdHlsZT0idGV4dC1hbmNob3I6IG1pZGRsZTsgZm9udC1zaXplOiAxNnB4OyBmb250LXdlaWdodDogNDAwOyIgY2xhc3M9ImFjdG9yIiBhbGlnbm1lbnQtYmFzZWxpbmU9ImNlbnRyYWwiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIiB5PSIzMzcuNSIgeD0iMzI5Ij48dHNwYW4gZHk9IjAiIHg9IjMyOSI+cGFyZW50IHRhc2s8L3RzcGFuPjwvdGV4dD48L2c+PGc+PHJlY3QgY2xhc3M9ImFjdG9yIGFjdG9yLWJvdHRvbSIgcnk9IjMiIHJ4PSIzIiBuYW1lPSJydW5fYXN5bmMiIGhlaWdodD0iNjUiIHdpZHRoPSIxNTAiIHN0cm9rZT0iIzY2NiIgZmlsbD0iI2VhZWFlYSIgeT0iMzA1IiB4PSIwIi8+PHRleHQgc3R5bGU9InRleHQtYW5jaG9yOiBtaWRkbGU7IGZvbnQtc2l6ZTogMTZweDsgZm9udC13ZWlnaHQ6IDQwMDsiIGNsYXNzPSJhY3RvciIgYWxpZ25tZW50LWJhc2VsaW5lPSJjZW50cmFsIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCIgeT0iMzM3LjUiIHg9Ijc1Ij48dHNwYW4gZHk9IjAiIHg9Ijc1Ij5ydW5fYXN5bmM8L3RzcGFuPjwvdGV4dD48L2c+PGc+PGxpbmUgc3Ryb2tlPSIjOTk5IiBzdHJva2Utd2lkdGg9IjAuNXB4IiBjbGFzcz0iMjAwIiB5Mj0iMzA1IiB4Mj0iODI5IiB5MT0iNSIgeDE9IjgyOSIgaWQ9ImFjdG9yMyIvPjxnIGlkPSJyb290LTMiPjxyZWN0IGNsYXNzPSJhY3RvciBhY3Rvci10b3AiIHJ5PSIzIiByeD0iMyIgbmFtZT0iaW8iIGhlaWdodD0iNjUiIHdpZHRoPSIxNTAiIHN0cm9rZT0iIzY2NiIgZmlsbD0iI2VhZWFlYSIgeT0iMCIgeD0iNzU0Ii8+PHRleHQgc3R5bGU9InRleHQtYW5jaG9yOiBtaWRkbGU7IGZvbnQtc2l6ZTogMTZweDsgZm9udC13ZWlnaHQ6IDQwMDsiIGNsYXNzPSJhY3RvciIgYWxpZ25tZW50LWJhc2VsaW5lPSJjZW50cmFsIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCIgeT0iMzIuNSIgeD0iODI5Ij48dHNwYW4gZHk9IjAiIHg9IjgyOSI+SS9PIG9wZXJhdGlvbjwvdHNwYW4+PC90ZXh0PjwvZz48L2c+PGc+PGxpbmUgc3Ryb2tlPSIjOTk5IiBzdHJva2Utd2lkdGg9IjAuNXB4IiBjbGFzcz0iMjAwIiB5Mj0iMzA1IiB4Mj0iNTc5IiB5MT0iNSIgeDE9IjU3OSIgaWQ9ImFjdG9yMiIvPjxnIGlkPSJyb290LTIiPjxyZWN0IGNsYXNzPSJhY3RvciBhY3Rvci10b3AiIHJ5PSIzIiByeD0iMyIgbmFtZT0iY2hpbGQiIGhlaWdodD0iNjUiIHdpZHRoPSIxNTAiIHN0cm9rZT0iIzY2NiIgZmlsbD0iI2VhZWFlYSIgeT0iMCIgeD0iNTA0Ii8+PHRleHQgc3R5bGU9InRleHQtYW5jaG9yOiBtaWRkbGU7IGZvbnQtc2l6ZTogMTZweDsgZm9udC13ZWlnaHQ6IDQwMDsiIGNsYXNzPSJhY3RvciIgYWxpZ25tZW50LWJhc2VsaW5lPSJjZW50cmFsIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCIgeT0iMzIuNSIgeD0iNTc5Ij48dHNwYW4gZHk9IjAiIHg9IjU3OSI+Y2hpbGQgdGFzazwvdHNwYW4+PC90ZXh0PjwvZz48L2c+PGc+PGxpbmUgc3Ryb2tlPSIjOTk5IiBzdHJva2Utd2lkdGg9IjAuNXB4IiBjbGFzcz0iMjAwIiB5Mj0iMzA1IiB4Mj0iMzI5IiB5MT0iNSIgeDE9IjMyOSIgaWQ9ImFjdG9yMSIvPjxnIGlkPSJyb290LTEiPjxyZWN0IGNsYXNzPSJhY3RvciBhY3Rvci10b3AiIHJ5PSIzIiByeD0iMyIgbmFtZT0icGFyZW50IiBoZWlnaHQ9IjY1IiB3aWR0aD0iMTUwIiBzdHJva2U9IiM2NjYiIGZpbGw9IiNlYWVhZWEiIHk9IjAiIHg9IjI1NCIvPjx0ZXh0IHN0eWxlPSJ0ZXh0LWFuY2hvcjogbWlkZGxlOyBmb250LXNpemU6IDE2cHg7IGZvbnQtd2VpZ2h0OiA0MDA7IiBjbGFzcz0iYWN0b3IiIGFsaWdubWVudC1iYXNlbGluZT0iY2VudHJhbCIgZG9taW5hbnQtYmFzZWxpbmU9ImNlbnRyYWwiIHk9IjMyLjUiIHg9IjMyOSI+PHRzcGFuIGR5PSIwIiB4PSIzMjkiPnBhcmVudCB0YXNrPC90c3Bhbj48L3RleHQ+PC9nPjwvZz48Zz48bGluZSBzdHJva2U9IiM5OTkiIHN0cm9rZS13aWR0aD0iMC41cHgiIGNsYXNzPSIyMDAiIHkyPSIzMDUiIHgyPSI3NSIgeTE9IjUiIHgxPSI3NSIgaWQ9ImFjdG9yMCIvPjxnIGlkPSJyb290LTAiPjxyZWN0IGNsYXNzPSJhY3RvciBhY3Rvci10b3AiIHJ5PSIzIiByeD0iMyIgbmFtZT0icnVuX2FzeW5jIiBoZWlnaHQ9IjY1IiB3aWR0aD0iMTUwIiBzdHJva2U9IiM2NjYiIGZpbGw9IiNlYWVhZWEiIHk9IjAiIHg9IjAiLz48dGV4dCBzdHlsZT0idGV4dC1hbmNob3I6IG1pZGRsZTsgZm9udC1zaXplOiAxNnB4OyBmb250LXdlaWdodDogNDAwOyIgY2xhc3M9ImFjdG9yIiBhbGlnbm1lbnQtYmFzZWxpbmU9ImNlbnRyYWwiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIiB5PSIzMi41IiB4PSI3NSI+PHRzcGFuIGR5PSIwIiB4PSI3NSI+cnVuX2FzeW5jPC90c3Bhbj48L3RleHQ+PC9nPjwvZz48c3R5bGU+I215LXN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7ZmlsbDojMzMzO30jbXktc3ZnIC5lcnJvci1pY29ue2ZpbGw6IzU1MjIyMjt9I215LXN2ZyAuZXJyb3ItdGV4dHtmaWxsOiM1NTIyMjI7c3Ryb2tlOiM1NTIyMjI7fSNteS1zdmcgLmVkZ2UtdGhpY2tuZXNzLW5vcm1hbHtzdHJva2Utd2lkdGg6MnB4O30jbXktc3ZnIC5lZGdlLXRoaWNrbmVzcy10aGlja3tzdHJva2Utd2lkdGg6My41cHg7fSNteS1zdmcgLmVkZ2UtcGF0dGVybi1zb2xpZHtzdHJva2UtZGFzaGFycmF5OjA7fSNteS1zdmcgLmVkZ2UtcGF0dGVybi1kYXNoZWR7c3Ryb2tlLWRhc2hhcnJheTozO30jbXktc3ZnIC5lZGdlLXBhdHRlcm4tZG90dGVke3N0cm9rZS1kYXNoYXJyYXk6Mjt9I215LXN2ZyAubWFya2Vye2ZpbGw6IzMzMzMzMztzdHJva2U6IzMzMzMzMzt9I215LXN2ZyAubWFya2VyLmNyb3Nze3N0cm9rZTojMzMzMzMzO30jbXktc3ZnIHN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7fSNteS1zdmcgLmFjdG9ye3N0cm9rZTpoc2woMjU5LjYyNjE2ODIyNDMsIDU5Ljc3NjUzNjMxMjglLCA4Ny45MDE5NjA3ODQzJSk7ZmlsbDojRUNFQ0ZGO30jbXktc3ZnIHRleHQuYWN0b3ImZ3Q7dHNwYW57ZmlsbDpibGFjaztzdHJva2U6bm9uZTt9I215LXN2ZyAuYWN0b3ItbGluZXtzdHJva2U6Z3JleTt9I215LXN2ZyAubWVzc2FnZUxpbmUwe3N0cm9rZS13aWR0aDoxLjU7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZTojMzMzO30jbXktc3ZnIC5tZXNzYWdlTGluZTF7c3Ryb2tlLXdpZHRoOjEuNTtzdHJva2UtZGFzaGFycmF5OjIsMjtzdHJva2U6IzMzMzt9I215LXN2ZyAjYXJyb3doZWFkIHBhdGh7ZmlsbDojMzMzO3N0cm9rZTojMzMzO30jbXktc3ZnIC5zZXF1ZW5jZU51bWJlcntmaWxsOndoaXRlO30jbXktc3ZnICNzZXF1ZW5jZW51bWJlcntmaWxsOiMzMzM7fSNteS1zdmcgI2Nyb3NzaGVhZCBwYXRoe2ZpbGw6IzMzMztzdHJva2U6IzMzMzt9I215LXN2ZyAubWVzc2FnZVRleHR7ZmlsbDojMzMzO3N0cm9rZTpub25lO30jbXktc3ZnIC5sYWJlbEJveHtzdHJva2U6aHNsKDI1OS42MjYxNjgyMjQzLCA1OS43NzY1MzYzMTI4JSwgODcuOTAxOTYwNzg0MyUpO2ZpbGw6I0VDRUNGRjt9I215LXN2ZyAubGFiZWxUZXh0LCNteS1zdmcgLmxhYmVsVGV4dCZndDt0c3BhbntmaWxsOmJsYWNrO3N0cm9rZTpub25lO30jbXktc3ZnIC5sb29wVGV4dCwjbXktc3ZnIC5sb29wVGV4dCZndDt0c3BhbntmaWxsOmJsYWNrO3N0cm9rZTpub25lO30jbXktc3ZnIC5sb29wTGluZXtzdHJva2Utd2lkdGg6MnB4O3N0cm9rZS1kYXNoYXJyYXk6MiwyO3N0cm9rZTpoc2woMjU5LjYyNjE2ODIyNDMsIDU5Ljc3NjUzNjMxMjglLCA4Ny45MDE5NjA3ODQzJSk7ZmlsbDpoc2woMjU5LjYyNjE2ODIyNDMsIDU5Ljc3NjUzNjMxMjglLCA4Ny45MDE5NjA3ODQzJSk7fSNteS1zdmcgLm5vdGV7c3Ryb2tlOiNhYWFhMzM7ZmlsbDojZmZmNWFkO30jbXktc3ZnIC5ub3RlVGV4dCwjbXktc3ZnIC5ub3RlVGV4dCZndDt0c3BhbntmaWxsOmJsYWNrO3N0cm9rZTpub25lO30jbXktc3ZnIC5hY3RpdmF0aW9uMHtmaWxsOiNmNGY0ZjQ7c3Ryb2tlOiM2NjY7fSNteS1zdmcgLmFjdGl2YXRpb24xe2ZpbGw6I2Y0ZjRmNDtzdHJva2U6IzY2Njt9I215LXN2ZyAuYWN0aXZhdGlvbjJ7ZmlsbDojZjRmNGY0O3N0cm9rZTojNjY2O30jbXktc3ZnIC5hY3RvclBvcHVwTWVudXtwb3NpdGlvbjphYnNvbHV0ZTt9I215LXN2ZyAuYWN0b3JQb3B1cE1lbnVQYW5lbHtwb3NpdGlvbjphYnNvbHV0ZTtmaWxsOiNFQ0VDRkY7Ym94LXNoYWRvdzowcHggOHB4IDE2cHggMHB4IHJnYmEoMCwwLDAsMC4yKTtmaWx0ZXI6ZHJvcC1zaGFkb3coM3B4IDVweCAycHggcmdiKDAgMCAwIC8gMC40KSk7fSNteS1zdmcgLmFjdG9yLW1hbiBsaW5le3N0cm9rZTpoc2woMjU5LjYyNjE2ODIyNDMsIDU5Ljc3NjUzNjMxMjglLCA4Ny45MDE5NjA3ODQzJSk7ZmlsbDojRUNFQ0ZGO30jbXktc3ZnIC5hY3Rvci1tYW4gY2lyY2xlLCNteS1zdmcgbGluZXtzdHJva2U6aHNsKDI1OS42MjYxNjgyMjQzLCA1OS43NzY1MzYzMTI4JSwgODcuOTAxOTYwNzg0MyUpO2ZpbGw6I0VDRUNGRjtzdHJva2Utd2lkdGg6MnB4O30jbXktc3ZnIDpyb290ey0tbWVybWFpZC1mb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7fTwvc3R5bGU+PGcvPjxkZWZzPjxzeW1ib2wgaGVpZ2h0PSIyNCIgd2lkdGg9IjI0IiBpZD0iY29tcHV0ZXIiPjxwYXRoIGQ9Ik0yIDJ2MTNoMjB2LTEzaC0yMHptMTggMTFoLTE2di05aDE2djl6bS0xMC4yMjggNmwuNDY2LTFoMy41MjRsLjQ2NyAxaC00LjQ1N3ptMTQuMjI4IDNoLTI0bDItNmgyLjEwNGwtMS4zMyA0aDE4LjQ1bC0xLjI5Ny00aDIuMDczbDIgNnptLTUtMTBoLTE0di03aDE0djd6IiB0cmFuc2Zvcm09InNjYWxlKC41KSIvPjwvc3ltYm9sPjwvZGVmcz48ZGVmcz48c3ltYm9sIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iZGF0YWJhc2UiPjxwYXRoIGQ9Ik0xMi4yNTguMDAxbC4yNTYuMDA0LjI1NS4wMDUuMjUzLjAwOC4yNTEuMDEuMjQ5LjAxMi4yNDcuMDE1LjI0Ni4wMTYuMjQyLjAxOS4yNDEuMDIuMjM5LjAyMy4yMzYuMDI0LjIzMy4wMjcuMjMxLjAyOC4yMjkuMDMxLjIyNS4wMzIuMjIzLjAzNC4yMi4wMzYuMjE3LjAzOC4yMTQuMDQuMjExLjA0MS4yMDguMDQzLjIwNS4wNDUuMjAxLjA0Ni4xOTguMDQ4LjE5NC4wNS4xOTEuMDUxLjE4Ny4wNTMuMTgzLjA1NC4xOC4wNTYuMTc1LjA1Ny4xNzIuMDU5LjE2OC4wNi4xNjMuMDYxLjE2LjA2My4xNTUuMDY0LjE1LjA2Ni4wNzQuMDMzLjA3My4wMzMuMDcxLjAzNC4wNy4wMzQuMDY5LjAzNS4wNjguMDM1LjA2Ny4wMzUuMDY2LjAzNS4wNjQuMDM2LjA2NC4wMzYuMDYyLjAzNi4wNi4wMzYuMDYuMDM3LjA1OC4wMzcuMDU4LjAzNy4wNTUuMDM4LjA1NS4wMzguMDUzLjAzOC4wNTIuMDM4LjA1MS4wMzkuMDUuMDM5LjA0OC4wMzkuMDQ3LjAzOS4wNDUuMDQuMDQ0LjA0LjA0My4wNC4wNDEuMDQuMDQuMDQxLjAzOS4wNDEuMDM3LjA0MS4wMzYuMDQxLjAzNC4wNDEuMDMzLjA0Mi4wMzIuMDQyLjAzLjA0Mi4wMjkuMDQyLjAyNy4wNDIuMDI2LjA0My4wMjQuMDQzLjAyMy4wNDMuMDIxLjA0My4wMi4wNDMuMDE4LjA0NC4wMTcuMDQzLjAxNS4wNDQuMDEzLjA0NC4wMTIuMDQ0LjAxMS4wNDUuMDA5LjA0NC4wMDcuMDQ1LjAwNi4wNDUuMDA0LjA0NS4wMDIuMDQ1LjAwMS4wNDV2MTdsLS4wMDEuMDQ1LS4wMDIuMDQ1LS4wMDQuMDQ1LS4wMDYuMDQ1LS4wMDcuMDQ1LS4wMDkuMDQ0LS4wMTEuMDQ1LS4wMTIuMDQ0LS4wMTMuMDQ0LS4wMTUuMDQ0LS4wMTcuMDQzLS4wMTguMDQ0LS4wMi4wNDMtLjAyMS4wNDMtLjAyMy4wNDMtLjAyNC4wNDMtLjAyNi4wNDMtLjAyNy4wNDItLjAyOS4wNDItLjAzLjA0Mi0uMDMyLjA0Mi0uMDMzLjA0Mi0uMDM0LjA0MS0uMDM2LjA0MS0uMDM3LjA0MS0uMDM5LjA0MS0uMDQuMDQxLS4wNDEuMDQtLjA0My4wNC0uMDQ0LjA0LS4wNDUuMDQtLjA0Ny4wMzktLjA0OC4wMzktLjA1LjAzOS0uMDUxLjAzOS0uMDUyLjAzOC0uMDUzLjAzOC0uMDU1LjAzOC0uMDU1LjAzOC0uMDU4LjAzNy0uMDU4LjAzNy0uMDYuMDM3LS4wNi4wMzYtLjA2Mi4wMzYtLjA2NC4wMzYtLjA2NC4wMzYtLjA2Ni4wMzUtLjA2Ny4wMzUtLjA2OC4wMzUtLjA2OS4wMzUtLjA3LjAzNC0uMDcxLjAzNC0uMDczLjAzMy0uMDc0LjAzMy0uMTUuMDY2LS4xNTUuMDY0LS4xNi4wNjMtLjE2My4wNjEtLjE2OC4wNi0uMTcyLjA1OS0uMTc1LjA1Ny0uMTguMDU2LS4xODMuMDU0LS4xODcuMDUzLS4xOTEuMDUxLS4xOTQuMDUtLjE5OC4wNDgtLjIwMS4wNDYtLjIwNS4wNDUtLjIwOC4wNDMtLjIxMS4wNDEtLjIxNC4wNC0uMjE3LjAzOC0uMjIuMDM2LS4yMjMuMDM0LS4yMjUuMDMyLS4yMjkuMDMxLS4yMzEuMDI4LS4yMzMuMDI3LS4yMzYuMDI0LS4yMzkuMDIzLS4yNDEuMDItLjI0Mi4wMTktLjI0Ni4wMTYtLjI0Ny4wMTUtLjI0OS4wMTItLjI1MS4wMS0uMjUzLjAwOC0uMjU1LjAwNS0uMjU2LjAwNC0uMjU4LjAwMS0uMjU4LS4wMDEtLjI1Ni0uMDA0LS4yNTUtLjAwNS0uMjUzLS4wMDgtLjI1MS0uMDEtLjI0OS0uMDEyLS4yNDctLjAxNS0uMjQ1LS4wMTYtLjI0My0uMDE5LS4yNDEtLjAyLS4yMzgtLjAyMy0uMjM2LS4wMjQtLjIzNC0uMDI3LS4yMzEtLjAyOC0uMjI4LS4wMzEtLjIyNi0uMDMyLS4yMjMtLjAzNC0uMjItLjAzNi0uMjE3LS4wMzgtLjIxNC0uMDQtLjIxMS0uMDQxLS4yMDgtLjA0My0uMjA0LS4wNDUtLjIwMS0uMDQ2LS4xOTgtLjA0OC0uMTk1LS4wNS0uMTktLjA1MS0uMTg3LS4wNTMtLjE4NC0uMDU0LS4xNzktLjA1Ni0uMTc2LS4wNTctLjE3Mi0uMDU5LS4xNjctLjA2LS4xNjQtLjA2MS0uMTU5LS4wNjMtLjE1NS0uMDY0LS4xNTEtLjA2Ni0uMDc0LS4wMzMtLjA3Mi0uMDMzLS4wNzItLjAzNC0uMDctLjAzNC0uMDY5LS4wMzUtLjA2OC0uMDM1LS4wNjctLjAzNS0uMDY2LS4wMzUtLjA2NC0uMDM2LS4wNjMtLjAzNi0uMDYyLS4wMzYtLjA2MS0uMDM2LS4wNi0uMDM3LS4wNTgtLjAzNy0uMDU3LS4wMzctLjA1Ni0uMDM4LS4wNTUtLjAzOC0uMDUzLS4wMzgtLjA1Mi0uMDM4LS4wNTEtLjAzOS0uMDQ5LS4wMzktLjA0OS0uMDM5LS4wNDYtLjAzOS0uMDQ2LS4wNC0uMDQ0LS4wNC0uMDQzLS4wNC0uMDQxLS4wNC0uMDQtLjA0MS0uMDM5LS4wNDEtLjAzNy0uMDQxLS4wMzYtLjA0MS0uMDM0LS4wNDEtLjAzMy0uMDQyLS4wMzItLjA0Mi0uMDMtLjA0Mi0uMDI5LS4wNDItLjAyNy0uMDQyLS4wMjYtLjA0My0uMDI0LS4wNDMtLjAyMy0uMDQzLS4wMjEtLjA0My0uMDItLjA0My0uMDE4LS4wNDQtLjAxNy0uMDQzLS4wMTUtLjA0NC0uMDEzLS4wNDQtLjAxMi0uMDQ0LS4wMTEtLjA0NS0uMDA5LS4wNDQtLjAwNy0uMDQ1LS4wMDYtLjA0NS0uMDA0LS4wNDUtLjAwMi0uMDQ1LS4wMDEtLjA0NXYtMTdsLjAwMS0uMDQ1LjAwMi0uMDQ1LjAwNC0uMDQ1LjAwNi0uMDQ1LjAwNy0uMDQ1LjAwOS0uMDQ0LjAxMS0uMDQ1LjAxMi0uMDQ0LjAxMy0uMDQ0LjAxNS0uMDQ0LjAxNy0uMDQzLjAxOC0uMDQ0LjAyLS4wNDMuMDIxLS4wNDMuMDIzLS4wNDMuMDI0LS4wNDMuMDI2LS4wNDMuMDI3LS4wNDIuMDI5LS4wNDIuMDMtLjA0Mi4wMzItLjA0Mi4wMzMtLjA0Mi4wMzQtLjA0MS4wMzYtLjA0MS4wMzctLjA0MS4wMzktLjA0MS4wNC0uMDQxLjA0MS0uMDQuMDQzLS4wNC4wNDQtLjA0LjA0Ni0uMDQuMDQ2LS4wMzkuMDQ5LS4wMzkuMDQ5LS4wMzkuMDUxLS4wMzkuMDUyLS4wMzguMDUzLS4wMzguMDU1LS4wMzguMDU2LS4wMzguMDU3LS4wMzcuMDU4LS4wMzcuMDYtLjAzNy4wNjEtLjAzNi4wNjItLjAzNi4wNjMtLjAzNi4wNjQtLjAzNi4wNjYtLjAzNS4wNjctLjAzNS4wNjgtLjAzNS4wNjktLjAzNS4wNy0uMDM0LjA3Mi0uMDM0LjA3Mi0uMDMzLjA3NC0uMDMzLjE1MS0uMDY2LjE1NS0uMDY0LjE1OS0uMDYzLjE2NC0uMDYxLjE2Ny0uMDYuMTcyLS4wNTkuMTc2LS4wNTcuMTc5LS4wNTYuMTg0LS4wNTQuMTg3LS4wNTMuMTktLjA1MS4xOTUtLjA1LjE5OC0uMDQ4LjIwMS0uMDQ2LjIwNC0uMDQ1LjIwOC0uMDQzLjIxMS0uMDQxLjIxNC0uMDQuMjE3LS4wMzguMjItLjAzNi4yMjMtLjAzNC4yMjYtLjAzMi4yMjgtLjAzMS4yMzEtLjAyOC4yMzQtLjAyNy4yMzYtLjAyNC4yMzgtLjAyMy4yNDEtLjAyLjI0My0uMDE5LjI0NS0uMDE2LjI0Ny0uMDE1LjI0OS0uMDEyLjI1MS0uMDEuMjUzLS4wMDguMjU1LS4wMDUuMjU2LS4wMDQuMjU4LS4wMDEuMjU4LjAwMXptLTkuMjU4IDIwLjQ5OXYuMDFsLjAwMS4wMjEuMDAzLjAyMS4wMDQuMDIyLjAwNS4wMjEuMDA2LjAyMi4wMDcuMDIyLjAwOS4wMjMuMDEuMDIyLjAxMS4wMjMuMDEyLjAyMy4wMTMuMDIzLjAxNS4wMjMuMDE2LjAyNC4wMTcuMDIzLjAxOC4wMjQuMDE5LjAyNC4wMjEuMDI0LjAyMi4wMjUuMDIzLjAyNC4wMjQuMDI1LjA1Mi4wNDkuMDU2LjA1LjA2MS4wNTEuMDY2LjA1MS4wNy4wNTEuMDc1LjA1MS4wNzkuMDUyLjA4NC4wNTIuMDg4LjA1Mi4wOTIuMDUyLjA5Ny4wNTIuMTAyLjA1MS4xMDUuMDUyLjExLjA1Mi4xMTQuMDUxLjExOS4wNTEuMTIzLjA1MS4xMjcuMDUuMTMxLjA1LjEzNS4wNS4xMzkuMDQ4LjE0NC4wNDkuMTQ3LjA0Ny4xNTIuMDQ3LjE1NS4wNDcuMTYuMDQ1LjE2My4wNDUuMTY3LjA0My4xNzEuMDQzLjE3Ni4wNDEuMTc4LjA0MS4xODMuMDM5LjE4Ny4wMzkuMTkuMDM3LjE5NC4wMzUuMTk3LjAzNS4yMDIuMDMzLjIwNC4wMzEuMjA5LjAzLjIxMi4wMjkuMjE2LjAyNy4yMTkuMDI1LjIyMi4wMjQuMjI2LjAyMS4yMy4wMi4yMzMuMDE4LjIzNi4wMTYuMjQuMDE1LjI0My4wMTIuMjQ2LjAxLjI0OS4wMDguMjUzLjAwNS4yNTYuMDA0LjI1OS4wMDEuMjYtLjAwMS4yNTctLjAwNC4yNTQtLjAwNS4yNS0uMDA4LjI0Ny0uMDExLjI0NC0uMDEyLjI0MS0uMDE0LjIzNy0uMDE2LjIzMy0uMDE4LjIzMS0uMDIxLjIyNi0uMDIxLjIyNC0uMDI0LjIyLS4wMjYuMjE2LS4wMjcuMjEyLS4wMjguMjEtLjAzMS4yMDUtLjAzMS4yMDItLjAzNC4xOTgtLjAzNC4xOTQtLjAzNi4xOTEtLjAzNy4xODctLjAzOS4xODMtLjA0LjE3OS0uMDQuMTc1LS4wNDIuMTcyLS4wNDMuMTY4LS4wNDQuMTYzLS4wNDUuMTYtLjA0Ni4xNTUtLjA0Ni4xNTItLjA0Ny4xNDgtLjA0OC4xNDMtLjA0OS4xMzktLjA0OS4xMzYtLjA1LjEzMS0uMDUuMTI2LS4wNS4xMjMtLjA1MS4xMTgtLjA1Mi4xMTQtLjA1MS4xMS0uMDUyLjEwNi0uMDUyLjEwMS0uMDUyLjA5Ni0uMDUyLjA5Mi0uMDUyLjA4OC0uMDUzLjA4My0uMDUxLjA3OS0uMDUyLjA3NC0uMDUyLjA3LS4wNTEuMDY1LS4wNTEuMDYtLjA1MS4wNTYtLjA1LjA1MS0uMDUuMDIzLS4wMjQuMDIzLS4wMjUuMDIxLS4wMjQuMDItLjAyNC4wMTktLjAyNC4wMTgtLjAyNC4wMTctLjAyNC4wMTUtLjAyMy4wMTQtLjAyNC4wMTMtLjAyMy4wMTItLjAyMy4wMS0uMDIzLjAxLS4wMjIuMDA4LS4wMjIuMDA2LS4wMjIuMDA2LS4wMjIuMDA0LS4wMjIuMDA0LS4wMjEuMDAxLS4wMjEuMDAxLS4wMjF2LTQuMTI3bC0uMDc3LjA1NS0uMDguMDUzLS4wODMuMDU0LS4wODUuMDUzLS4wODcuMDUyLS4wOS4wNTItLjA5My4wNTEtLjA5NS4wNS0uMDk3LjA1LS4xLjA0OS0uMTAyLjA0OS0uMTA1LjA0OC0uMTA2LjA0Ny0uMTA5LjA0Ny0uMTExLjA0Ni0uMTE0LjA0NS0uMTE1LjA0NS0uMTE4LjA0NC0uMTIuMDQzLS4xMjIuMDQyLS4xMjQuMDQyLS4xMjYuMDQxLS4xMjguMDQtLjEzLjA0LS4xMzIuMDM4LS4xMzQuMDM4LS4xMzUuMDM3LS4xMzguMDM3LS4xMzkuMDM1LS4xNDIuMDM1LS4xNDMuMDM0LS4xNDQuMDMzLS4xNDcuMDMyLS4xNDguMDMxLS4xNS4wMy0uMTUxLjAzLS4xNTMuMDI5LS4xNTQuMDI3LS4xNTYuMDI3LS4xNTguMDI2LS4xNTkuMDI1LS4xNjEuMDI0LS4xNjIuMDIzLS4xNjMuMDIyLS4xNjUuMDIxLS4xNjYuMDItLjE2Ny4wMTktLjE2OS4wMTgtLjE2OS4wMTctLjE3MS4wMTYtLjE3My4wMTUtLjE3My4wMTQtLjE3NS4wMTMtLjE3NS4wMTItLjE3Ny4wMTEtLjE3OC4wMS0uMTc5LjAwOC0uMTc5LjAwOC0uMTgxLjAwNi0uMTgyLjAwNS0uMTgyLjAwNC0uMTg0LjAwMy0uMTg0LjAwMmgtLjM3bC0uMTg0LS4wMDItLjE4NC0uMDAzLS4xODItLjAwNC0uMTgyLS4wMDUtLjE4MS0uMDA2LS4xNzktLjAwOC0uMTc5LS4wMDgtLjE3OC0uMDEtLjE3Ni0uMDExLS4xNzYtLjAxMi0uMTc1LS4wMTMtLjE3My0uMDE0LS4xNzItLjAxNS0uMTcxLS4wMTYtLjE3LS4wMTctLjE2OS0uMDE4LS4xNjctLjAxOS0uMTY2LS4wMi0uMTY1LS4wMjEtLjE2My0uMDIyLS4xNjItLjAyMy0uMTYxLS4wMjQtLjE1OS0uMDI1LS4xNTctLjAyNi0uMTU2LS4wMjctLjE1NS0uMDI3LS4xNTMtLjAyOS0uMTUxLS4wMy0uMTUtLjAzLS4xNDgtLjAzMS0uMTQ2LS4wMzItLjE0NS0uMDMzLS4xNDMtLjAzNC0uMTQxLS4wMzUtLjE0LS4wMzUtLjEzNy0uMDM3LS4xMzYtLjAzNy0uMTM0LS4wMzgtLjEzMi0uMDM4LS4xMy0uMDQtLjEyOC0uMDQtLjEyNi0uMDQxLS4xMjQtLjA0Mi0uMTIyLS4wNDItLjEyLS4wNDQtLjExNy0uMDQzLS4xMTYtLjA0NS0uMTEzLS4wNDUtLjExMi0uMDQ2LS4xMDktLjA0Ny0uMTA2LS4wNDctLjEwNS0uMDQ4LS4xMDItLjA0OS0uMS0uMDQ5LS4wOTctLjA1LS4wOTUtLjA1LS4wOTMtLjA1Mi0uMDktLjA1MS0uMDg3LS4wNTItLjA4NS0uMDUzLS4wODMtLjA1NC0uMDgtLjA1NC0uMDc3LS4wNTR2NC4xMjd6bTAtNS42NTR2LjAxMWwuMDAxLjAyMS4wMDMuMDIxLjAwNC4wMjEuMDA1LjAyMi4wMDYuMDIyLjAwNy4wMjIuMDA5LjAyMi4wMS4wMjIuMDExLjAyMy4wMTIuMDIzLjAxMy4wMjMuMDE1LjAyNC4wMTYuMDIzLjAxNy4wMjQuMDE4LjAyNC4wMTkuMDI0LjAyMS4wMjQuMDIyLjAyNC4wMjMuMDI1LjAyNC4wMjQuMDUyLjA1LjA1Ni4wNS4wNjEuMDUuMDY2LjA1MS4wNy4wNTEuMDc1LjA1Mi4wNzkuMDUxLjA4NC4wNTIuMDg4LjA1Mi4wOTIuMDUyLjA5Ny4wNTIuMTAyLjA1Mi4xMDUuMDUyLjExLjA1MS4xMTQuMDUxLjExOS4wNTIuMTIzLjA1LjEyNy4wNTEuMTMxLjA1LjEzNS4wNDkuMTM5LjA0OS4xNDQuMDQ4LjE0Ny4wNDguMTUyLjA0Ny4xNTUuMDQ2LjE2LjA0NS4xNjMuMDQ1LjE2Ny4wNDQuMTcxLjA0Mi4xNzYuMDQyLjE3OC4wNC4xODMuMDQuMTg3LjAzOC4xOS4wMzcuMTk0LjAzNi4xOTcuMDM0LjIwMi4wMzMuMjA0LjAzMi4yMDkuMDMuMjEyLjAyOC4yMTYuMDI3LjIxOS4wMjUuMjIyLjAyNC4yMjYuMDIyLjIzLjAyLjIzMy4wMTguMjM2LjAxNi4yNC4wMTQuMjQzLjAxMi4yNDYuMDEuMjQ5LjAwOC4yNTMuMDA2LjI1Ni4wMDMuMjU5LjAwMS4yNi0uMDAxLjI1Ny0uMDAzLjI1NC0uMDA2LjI1LS4wMDguMjQ3LS4wMS4yNDQtLjAxMi4yNDEtLjAxNS4yMzctLjAxNi4yMzMtLjAxOC4yMzEtLjAyLjIyNi0uMDIyLjIyNC0uMDI0LjIyLS4wMjUuMjE2LS4wMjcuMjEyLS4wMjkuMjEtLjAzLjIwNS0uMDMyLjIwMi0uMDMzLjE5OC0uMDM1LjE5NC0uMDM2LjE5MS0uMDM3LjE4Ny0uMDM5LjE4My0uMDM5LjE3OS0uMDQxLjE3NS0uMDQyLjE3Mi0uMDQzLjE2OC0uMDQ0LjE2My0uMDQ1LjE2LS4wNDUuMTU1LS4wNDcuMTUyLS4wNDcuMTQ4LS4wNDguMTQzLS4wNDguMTM5LS4wNS4xMzYtLjA0OS4xMzEtLjA1LjEyNi0uMDUxLjEyMy0uMDUxLjExOC0uMDUxLjExNC0uMDUyLjExLS4wNTIuMTA2LS4wNTIuMTAxLS4wNTIuMDk2LS4wNTIuMDkyLS4wNTIuMDg4LS4wNTIuMDgzLS4wNTIuMDc5LS4wNTIuMDc0LS4wNTEuMDctLjA1Mi4wNjUtLjA1MS4wNi0uMDUuMDU2LS4wNTEuMDUxLS4wNDkuMDIzLS4wMjUuMDIzLS4wMjQuMDIxLS4wMjUuMDItLjAyNC4wMTktLjAyNC4wMTgtLjAyNC4wMTctLjAyNC4wMTUtLjAyMy4wMTQtLjAyMy4wMTMtLjAyNC4wMTItLjAyMi4wMS0uMDIzLjAxLS4wMjMuMDA4LS4wMjIuMDA2LS4wMjIuMDA2LS4wMjIuMDA0LS4wMjEuMDA0LS4wMjIuMDAxLS4wMjEuMDAxLS4wMjF2LTQuMTM5bC0uMDc3LjA1NC0uMDguMDU0LS4wODMuMDU0LS4wODUuMDUyLS4wODcuMDUzLS4wOS4wNTEtLjA5My4wNTEtLjA5NS4wNTEtLjA5Ny4wNS0uMS4wNDktLjEwMi4wNDktLjEwNS4wNDgtLjEwNi4wNDctLjEwOS4wNDctLjExMS4wNDYtLjExNC4wNDUtLjExNS4wNDQtLjExOC4wNDQtLjEyLjA0NC0uMTIyLjA0Mi0uMTI0LjA0Mi0uMTI2LjA0MS0uMTI4LjA0LS4xMy4wMzktLjEzMi4wMzktLjEzNC4wMzgtLjEzNS4wMzctLjEzOC4wMzYtLjEzOS4wMzYtLjE0Mi4wMzUtLjE0My4wMzMtLjE0NC4wMzMtLjE0Ny4wMzMtLjE0OC4wMzEtLjE1LjAzLS4xNTEuMDMtLjE1My4wMjgtLjE1NC4wMjgtLjE1Ni4wMjctLjE1OC4wMjYtLjE1OS4wMjUtLjE2MS4wMjQtLjE2Mi4wMjMtLjE2My4wMjItLjE2NS4wMjEtLjE2Ni4wMi0uMTY3LjAxOS0uMTY5LjAxOC0uMTY5LjAxNy0uMTcxLjAxNi0uMTczLjAxNS0uMTczLjAxNC0uMTc1LjAxMy0uMTc1LjAxMi0uMTc3LjAxMS0uMTc4LjAwOS0uMTc5LjAwOS0uMTc5LjAwNy0uMTgxLjAwNy0uMTgyLjAwNS0uMTgyLjAwNC0uMTg0LjAwMy0uMTg0LjAwMmgtLjM3bC0uMTg0LS4wMDItLjE4NC0uMDAzLS4xODItLjAwNC0uMTgyLS4wMDUtLjE4MS0uMDA3LS4xNzktLjAwNy0uMTc5LS4wMDktLjE3OC0uMDA5LS4xNzYtLjAxMS0uMTc2LS4wMTItLjE3NS0uMDEzLS4xNzMtLjAxNC0uMTcyLS4wMTUtLjE3MS0uMDE2LS4xNy0uMDE3LS4xNjktLjAxOC0uMTY3LS4wMTktLjE2Ni0uMDItLjE2NS0uMDIxLS4xNjMtLjAyMi0uMTYyLS4wMjMtLjE2MS0uMDI0LS4xNTktLjAyNS0uMTU3LS4wMjYtLjE1Ni0uMDI3LS4xNTUtLjAyOC0uMTUzLS4wMjgtLjE1MS0uMDMtLjE1LS4wMy0uMTQ4LS4wMzEtLjE0Ni0uMDMzLS4xNDUtLjAzMy0uMTQzLS4wMzMtLjE0MS0uMDM1LS4xNC0uMDM2LS4xMzctLjAzNi0uMTM2LS4wMzctLjEzNC0uMDM4LS4xMzItLjAzOS0uMTMtLjAzOS0uMTI4LS4wNC0uMTI2LS4wNDEtLjEyNC0uMDQyLS4xMjItLjA0My0uMTItLjA0My0uMTE3LS4wNDQtLjExNi0uMDQ0LS4xMTMtLjA0Ni0uMTEyLS4wNDYtLjEwOS0uMDQ2LS4xMDYtLjA0Ny0uMTA1LS4wNDgtLjEwMi0uMDQ5LS4xLS4wNDktLjA5Ny0uMDUtLjA5NS0uMDUxLS4wOTMtLjA1MS0uMDktLjA1MS0uMDg3LS4wNTMtLjA4NS0uMDUyLS4wODMtLjA1NC0uMDgtLjA1NC0uMDc3LS4wNTR2NC4xMzl6bTAtNS42NjZ2LjAxMWwuMDAxLjAyLjAwMy4wMjIuMDA0LjAyMS4wMDUuMDIyLjAwNi4wMjEuMDA3LjAyMi4wMDkuMDIzLjAxLjAyMi4wMTEuMDIzLjAxMi4wMjMuMDEzLjAyMy4wMTUuMDIzLjAxNi4wMjQuMDE3LjAyNC4wMTguMDIzLjAxOS4wMjQuMDIxLjAyNS4wMjIuMDI0LjAyMy4wMjQuMDI0LjAyNS4wNTIuMDUuMDU2LjA1LjA2MS4wNS4wNjYuMDUxLjA3LjA1MS4wNzUuMDUyLjA3OS4wNTEuMDg0LjA1Mi4wODguMDUyLjA5Mi4wNTIuMDk3LjA1Mi4xMDIuMDUyLjEwNS4wNTEuMTEuMDUyLjExNC4wNTEuMTE5LjA1MS4xMjMuMDUxLjEyNy4wNS4xMzEuMDUuMTM1LjA1LjEzOS4wNDkuMTQ0LjA0OC4xNDcuMDQ4LjE1Mi4wNDcuMTU1LjA0Ni4xNi4wNDUuMTYzLjA0NS4xNjcuMDQzLjE3MS4wNDMuMTc2LjA0Mi4xNzguMDQuMTgzLjA0LjE4Ny4wMzguMTkuMDM3LjE5NC4wMzYuMTk3LjAzNC4yMDIuMDMzLjIwNC4wMzIuMjA5LjAzLjIxMi4wMjguMjE2LjAyNy4yMTkuMDI1LjIyMi4wMjQuMjI2LjAyMS4yMy4wMi4yMzMuMDE4LjIzNi4wMTcuMjQuMDE0LjI0My4wMTIuMjQ2LjAxLjI0OS4wMDguMjUzLjAwNi4yNTYuMDAzLjI1OS4wMDEuMjYtLjAwMS4yNTctLjAwMy4yNTQtLjAwNi4yNS0uMDA4LjI0Ny0uMDEuMjQ0LS4wMTMuMjQxLS4wMTQuMjM3LS4wMTYuMjMzLS4wMTguMjMxLS4wMi4yMjYtLjAyMi4yMjQtLjAyNC4yMi0uMDI1LjIxNi0uMDI3LjIxMi0uMDI5LjIxLS4wMy4yMDUtLjAzMi4yMDItLjAzMy4xOTgtLjAzNS4xOTQtLjAzNi4xOTEtLjAzNy4xODctLjAzOS4xODMtLjAzOS4xNzktLjA0MS4xNzUtLjA0Mi4xNzItLjA0My4xNjgtLjA0NC4xNjMtLjA0NS4xNi0uMDQ1LjE1NS0uMDQ3LjE1Mi0uMDQ3LjE0OC0uMDQ4LjE0My0uMDQ5LjEzOS0uMDQ5LjEzNi0uMDQ5LjEzMS0uMDUxLjEyNi0uMDUuMTIzLS4wNTEuMTE4LS4wNTIuMTE0LS4wNTEuMTEtLjA1Mi4xMDYtLjA1Mi4xMDEtLjA1Mi4wOTYtLjA1Mi4wOTItLjA1Mi4wODgtLjA1Mi4wODMtLjA1Mi4wNzktLjA1Mi4wNzQtLjA1Mi4wNy0uMDUxLjA2NS0uMDUxLjA2LS4wNTEuMDU2LS4wNS4wNTEtLjA0OS4wMjMtLjAyNS4wMjMtLjAyNS4wMjEtLjAyNC4wMi0uMDI0LjAxOS0uMDI0LjAxOC0uMDI0LjAxNy0uMDI0LjAxNS0uMDIzLjAxNC0uMDI0LjAxMy0uMDIzLjAxMi0uMDIzLjAxLS4wMjIuMDEtLjAyMy4wMDgtLjAyMi4wMDYtLjAyMi4wMDYtLjAyMi4wMDQtLjAyMi4wMDQtLjAyMS4wMDEtLjAyMS4wMDEtLjAyMXYtNC4xNTNsLS4wNzcuMDU0LS4wOC4wNTQtLjA4My4wNTMtLjA4NS4wNTMtLjA4Ny4wNTMtLjA5LjA1MS0uMDkzLjA1MS0uMDk1LjA1MS0uMDk3LjA1LS4xLjA0OS0uMTAyLjA0OC0uMTA1LjA0OC0uMTA2LjA0OC0uMTA5LjA0Ni0uMTExLjA0Ni0uMTE0LjA0Ni0uMTE1LjA0NC0uMTE4LjA0NC0uMTIuMDQzLS4xMjIuMDQzLS4xMjQuMDQyLS4xMjYuMDQxLS4xMjguMDQtLjEzLjAzOS0uMTMyLjAzOS0uMTM0LjAzOC0uMTM1LjAzNy0uMTM4LjAzNi0uMTM5LjAzNi0uMTQyLjAzNC0uMTQzLjAzNC0uMTQ0LjAzMy0uMTQ3LjAzMi0uMTQ4LjAzMi0uMTUuMDMtLjE1MS4wMy0uMTUzLjAyOC0uMTU0LjAyOC0uMTU2LjAyNy0uMTU4LjAyNi0uMTU5LjAyNC0uMTYxLjAyNC0uMTYyLjAyMy0uMTYzLjAyMy0uMTY1LjAyMS0uMTY2LjAyLS4xNjcuMDE5LS4xNjkuMDE4LS4xNjkuMDE3LS4xNzEuMDE2LS4xNzMuMDE1LS4xNzMuMDE0LS4xNzUuMDEzLS4xNzUuMDEyLS4xNzcuMDEtLjE3OC4wMS0uMTc5LjAwOS0uMTc5LjAwNy0uMTgxLjAwNi0uMTgyLjAwNi0uMTgyLjAwNC0uMTg0LjAwMy0uMTg0LjAwMS0uMTg1LjAwMS0uMTg1LS4wMDEtLjE4NC0uMDAxLS4xODQtLjAwMy0uMTgyLS4wMDQtLjE4Mi0uMDA2LS4xODEtLjAwNi0uMTc5LS4wMDctLjE3OS0uMDA5LS4xNzgtLjAxLS4xNzYtLjAxLS4xNzYtLjAxMi0uMTc1LS4wMTMtLjE3My0uMDE0LS4xNzItLjAxNS0uMTcxLS4wMTYtLjE3LS4wMTctLjE2OS0uMDE4LS4xNjctLjAxOS0uMTY2LS4wMi0uMTY1LS4wMjEtLjE2My0uMDIzLS4xNjItLjAyMy0uMTYxLS4wMjQtLjE1OS0uMDI0LS4xNTctLjAyNi0uMTU2LS4wMjctLjE1NS0uMDI4LS4xNTMtLjAyOC0uMTUxLS4wMy0uMTUtLjAzLS4xNDgtLjAzMi0uMTQ2LS4wMzItLjE0NS0uMDMzLS4xNDMtLjAzNC0uMTQxLS4wMzQtLjE0LS4wMzYtLjEzNy0uMDM2LS4xMzYtLjAzNy0uMTM0LS4wMzgtLjEzMi0uMDM5LS4xMy0uMDM5LS4xMjgtLjA0MS0uMTI2LS4wNDEtLjEyNC0uMDQxLS4xMjItLjA0My0uMTItLjA0My0uMTE3LS4wNDQtLjExNi0uMDQ0LS4xMTMtLjA0Ni0uMTEyLS4wNDYtLjEwOS0uMDQ2LS4xMDYtLjA0OC0uMTA1LS4wNDgtLjEwMi0uMDQ4LS4xLS4wNS0uMDk3LS4wNDktLjA5NS0uMDUxLS4wOTMtLjA1MS0uMDktLjA1Mi0uMDg3LS4wNTItLjA4NS0uMDUzLS4wODMtLjA1My0uMDgtLjA1NC0uMDc3LS4wNTR2NC4xNTN6bTguNzQtOC4xNzlsLS4yNTcuMDA0LS4yNTQuMDA1LS4yNS4wMDgtLjI0Ny4wMTEtLjI0NC4wMTItLjI0MS4wMTQtLjIzNy4wMTYtLjIzMy4wMTgtLjIzMS4wMjEtLjIyNi4wMjItLjIyNC4wMjMtLjIyLjAyNi0uMjE2LjAyNy0uMjEyLjAyOC0uMjEuMDMxLS4yMDUuMDMyLS4yMDIuMDMzLS4xOTguMDM0LS4xOTQuMDM2LS4xOTEuMDM4LS4xODcuMDM4LS4xODMuMDQtLjE3OS4wNDEtLjE3NS4wNDItLjE3Mi4wNDMtLjE2OC4wNDMtLjE2My4wNDUtLjE2LjA0Ni0uMTU1LjA0Ni0uMTUyLjA0OC0uMTQ4LjA0OC0uMTQzLjA0OC0uMTM5LjA0OS0uMTM2LjA1LS4xMzEuMDUtLjEyNi4wNTEtLjEyMy4wNTEtLjExOC4wNTEtLjExNC4wNTItLjExLjA1Mi0uMTA2LjA1Mi0uMTAxLjA1Mi0uMDk2LjA1Mi0uMDkyLjA1Mi0uMDg4LjA1Mi0uMDgzLjA1Mi0uMDc5LjA1Mi0uMDc0LjA1MS0uMDcuMDUyLS4wNjUuMDUxLS4wNi4wNS0uMDU2LjA1LS4wNTEuMDUtLjAyMy4wMjUtLjAyMy4wMjQtLjAyMS4wMjQtLjAyLjAyNS0uMDE5LjAyNC0uMDE4LjAyNC0uMDE3LjAyMy0uMDE1LjAyNC0uMDE0LjAyMy0uMDEzLjAyMy0uMDEyLjAyMy0uMDEuMDIzLS4wMS4wMjItLjAwOC4wMjItLjAwNi4wMjMtLjAwNi4wMjEtLjAwNC4wMjItLjAwNC4wMjEtLjAwMS4wMjEtLjAwMS4wMjEuMDAxLjAyMS4wMDEuMDIxLjAwNC4wMjEuMDA0LjAyMi4wMDYuMDIxLjAwNi4wMjMuMDA4LjAyMi4wMS4wMjIuMDEuMDIzLjAxMi4wMjMuMDEzLjAyMy4wMTQuMDIzLjAxNS4wMjQuMDE3LjAyMy4wMTguMDI0LjAxOS4wMjQuMDIuMDI1LjAyMS4wMjQuMDIzLjAyNC4wMjMuMDI1LjA1MS4wNS4wNTYuMDUuMDYuMDUuMDY1LjA1MS4wNy4wNTIuMDc0LjA1MS4wNzkuMDUyLjA4My4wNTIuMDg4LjA1Mi4wOTIuMDUyLjA5Ni4wNTIuMTAxLjA1Mi4xMDYuMDUyLjExLjA1Mi4xMTQuMDUyLjExOC4wNTEuMTIzLjA1MS4xMjYuMDUxLjEzMS4wNS4xMzYuMDUuMTM5LjA0OS4xNDMuMDQ4LjE0OC4wNDguMTUyLjA0OC4xNTUuMDQ2LjE2LjA0Ni4xNjMuMDQ1LjE2OC4wNDMuMTcyLjA0My4xNzUuMDQyLjE3OS4wNDEuMTgzLjA0LjE4Ny4wMzguMTkxLjAzOC4xOTQuMDM2LjE5OC4wMzQuMjAyLjAzMy4yMDUuMDMyLjIxLjAzMS4yMTIuMDI4LjIxNi4wMjcuMjIuMDI2LjIyNC4wMjMuMjI2LjAyMi4yMzEuMDIxLjIzMy4wMTguMjM3LjAxNi4yNDEuMDE0LjI0NC4wMTIuMjQ3LjAxMS4yNS4wMDguMjU0LjAwNS4yNTcuMDA0LjI2LjAwMS4yNi0uMDAxLjI1Ny0uMDA0LjI1NC0uMDA1LjI1LS4wMDguMjQ3LS4wMTEuMjQ0LS4wMTIuMjQxLS4wMTQuMjM3LS4wMTYuMjMzLS4wMTguMjMxLS4wMjEuMjI2LS4wMjIuMjI0LS4wMjMuMjItLjAyNi4yMTYtLjAyNy4yMTItLjAyOC4yMS0uMDMxLjIwNS0uMDMyLjIwMi0uMDMzLjE5OC0uMDM0LjE5NC0uMDM2LjE5MS0uMDM4LjE4Ny0uMDM4LjE4My0uMDQuMTc5LS4wNDEuMTc1LS4wNDIuMTcyLS4wNDMuMTY4LS4wNDMuMTYzLS4wNDUuMTYtLjA0Ni4xNTUtLjA0Ni4xNTItLjA0OC4xNDgtLjA0OC4xNDMtLjA0OC4xMzktLjA0OS4xMzYtLjA1LjEzMS0uMDUuMTI2LS4wNTEuMTIzLS4wNTEuMTE4LS4wNTEuMTE0LS4wNTIuMTEtLjA1Mi4xMDYtLjA1Mi4xMDEtLjA1Mi4wOTYtLjA1Mi4wOTItLjA1Mi4wODgtLjA1Mi4wODMtLjA1Mi4wNzktLjA1Mi4wNzQtLjA1MS4wNy0uMDUyLjA2NS0uMDUxLjA2LS4wNS4wNTYtLjA1LjA1MS0uMDUuMDIzLS4wMjUuMDIzLS4wMjQuMDIxLS4wMjQuMDItLjAyNS4wMTktLjAyNC4wMTgtLjAyNC4wMTctLjAyMy4wMTUtLjAyNC4wMTQtLjAyMy4wMTMtLjAyMy4wMTItLjAyMy4wMS0uMDIzLjAxLS4wMjIuMDA4LS4wMjIuMDA2LS4wMjMuMDA2LS4wMjEuMDA0LS4wMjIuMDA0LS4wMjEuMDAxLS4wMjEuMDAxLS4wMjEtLjAwMS0uMDIxLS4wMDEtLjAyMS0uMDA0LS4wMjEtLjAwNC0uMDIyLS4wMDYtLjAyMS0uMDA2LS4wMjMtLjAwOC0uMDIyLS4wMS0uMDIyLS4wMS0uMDIzLS4wMTItLjAyMy0uMDEzLS4wMjMtLjAxNC0uMDIzLS4wMTUtLjAyNC0uMDE3LS4wMjMtLjAxOC0uMDI0LS4wMTktLjAyNC0uMDItLjAyNS0uMDIxLS4wMjQtLjAyMy0uMDI0LS4wMjMtLjAyNS0uMDUxLS4wNS0uMDU2LS4wNS0uMDYtLjA1LS4wNjUtLjA1MS0uMDctLjA1Mi0uMDc0LS4wNTEtLjA3OS0uMDUyLS4wODMtLjA1Mi0uMDg4LS4wNTItLjA5Mi0uMDUyLS4wOTYtLjA1Mi0uMTAxLS4wNTItLjEwNi0uMDUyLS4xMS0uMDUyLS4xMTQtLjA1Mi0uMTE4LS4wNTEtLjEyMy0uMDUxLS4xMjYtLjA1MS0uMTMxLS4wNS0uMTM2LS4wNS0uMTM5LS4wNDktLjE0My0uMDQ4LS4xNDgtLjA0OC0uMTUyLS4wNDgtLjE1NS0uMDQ2LS4xNi0uMDQ2LS4xNjMtLjA0NS0uMTY4LS4wNDMtLjE3Mi0uMDQzLS4xNzUtLjA0Mi0uMTc5LS4wNDEtLjE4My0uMDQtLjE4Ny0uMDM4LS4xOTEtLjAzOC0uMTk0LS4wMzYtLjE5OC0uMDM0LS4yMDItLjAzMy0uMjA1LS4wMzItLjIxLS4wMzEtLjIxMi0uMDI4LS4yMTYtLjAyNy0uMjItLjAyNi0uMjI0LS4wMjMtLjIyNi0uMDIyLS4yMzEtLjAyMS0uMjMzLS4wMTgtLjIzNy0uMDE2LS4yNDEtLjAxNC0uMjQ0LS4wMTItLjI0Ny0uMDExLS4yNS0uMDA4LS4yNTQtLjAwNS0uMjU3LS4wMDQtLjI2LS4wMDEtLjI2LjAwMXoiIHRyYW5zZm9ybT0ic2NhbGUoLjUpIi8+PC9zeW1ib2w+PC9kZWZzPjxkZWZzPjxzeW1ib2wgaGVpZ2h0PSIyNCIgd2lkdGg9IjI0IiBpZD0iY2xvY2siPjxwYXRoIGQ9Ik0xMiAyYzUuNTE0IDAgMTAgNC40ODYgMTAgMTBzLTQuNDg2IDEwLTEwIDEwLTEwLTQuNDg2LTEwLTEwIDQuNDg2LTEwIDEwLTEwem0wLTJjLTYuNjI3IDAtMTIgNS4zNzMtMTIgMTJzNS4zNzMgMTIgMTIgMTIgMTItNS4zNzMgMTItMTItNS4zNzMtMTItMTItMTJ6bTUuODQ4IDEyLjQ1OWMuMjAyLjAzOC4yMDIuMzMzLjAwMS4zNzItMS45MDcuMzYxLTYuMDQ1IDEuMTExLTYuNTQ3IDEuMTExLS43MTkgMC0xLjMwMS0uNTgyLTEuMzAxLTEuMzAxIDAtLjUxMi43Ny01LjQ0NyAxLjEyNS03LjQ0NS4wMzQtLjE5Mi4zMTItLjE4MS4zNDMuMDE0bC45ODUgNi4yMzggNS4zOTQgMS4wMTF6IiB0cmFuc2Zvcm09InNjYWxlKC41KSIvPjwvc3ltYm9sPjwvZGVmcz48ZGVmcz48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMiIgbWFya2VyV2lkdGg9IjEyIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjcuOSIgaWQ9ImFycm93aGVhZCI+PHBhdGggZD0iTSAwIDAgTCAxMCA1IEwgMCAxMCB6Ii8+PC9tYXJrZXI+PC9kZWZzPjxkZWZzPjxtYXJrZXIgcmVmWT0iNC41IiByZWZYPSI0IiBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iOCIgbWFya2VyV2lkdGg9IjE1IiBpZD0iY3Jvc3NoZWFkIj48cGF0aCBzdHlsZT0ic3Ryb2tlLWRhc2hhcnJheTogMCwgMDsiIGQ9Ik0gMSwyIEwgNiw3IE0gNiwyIEwgMSw3IiBzdHJva2Utd2lkdGg9IjFwdCIgc3Ryb2tlPSIjMDAwMDAwIiBmaWxsPSJub25lIi8+PC9tYXJrZXI+PC9kZWZzPjxkZWZzPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjI4IiBtYXJrZXJXaWR0aD0iMjAiIHJlZlk9IjciIHJlZlg9IjE1LjUiIGlkPSJmaWxsZWQtaGVhZCI+PHBhdGggZD0iTSAxOCw3IEw5LDEzIEwxNCw3IEw5LDEgWiIvPjwvbWFya2VyPjwvZGVmcz48ZGVmcz48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSI0MCIgbWFya2VyV2lkdGg9IjYwIiByZWZZPSIxNSIgcmVmWD0iMTUiIGlkPSJzZXF1ZW5jZW51bWJlciI+PGNpcmNsZSByPSI2IiBjeT0iMTUiIGN4PSIxNSIvPjwvbWFya2VyPjwvZGVmcz48dGV4dCBzdHlsZT0iZm9udC1zaXplOiAxNnB4OyBmb250LXdlaWdodDogNDAwOyIgZHk9IjFlbSIgY2xhc3M9Im1lc3NhZ2VUZXh0IiBhbGlnbm1lbnQtYmFzZWxpbmU9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgeT0iODAiIHg9IjIwMSI+c2V0X2V4ZWN1dG9yLCBzZXRfc3RvcF90b2tlbjwvdGV4dD48bGluZSBzdHlsZT0iZmlsbDogbm9uZTsiIG1hcmtlci1lbmQ9InVybCgjYXJyb3doZWFkKSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjIiIGNsYXNzPSJtZXNzYWdlTGluZTAiIHkyPSIxMDkiIHgyPSIzMjUiIHkxPSIxMDkiIHgxPSI3NiIvPjx0ZXh0IHN0eWxlPSJmb250LXNpemU6IDE2cHg7IGZvbnQtd2VpZ2h0OiA0MDA7IiBkeT0iMWVtIiBjbGFzcz0ibWVzc2FnZVRleHQiIGFsaWdubWVudC1iYXNlbGluZT0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB5PSIxMjQiIHg9IjQ1MyI+YXdhaXRfc3VzcGVuZChoLCBleCwgdG9rZW4pPC90ZXh0PjxsaW5lIHN0eWxlPSJmaWxsOiBub25lOyIgbWFya2VyLWVuZD0idXJsKCNhcnJvd2hlYWQpIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMiIgY2xhc3M9Im1lc3NhZ2VMaW5lMCIgeTI9IjE1MyIgeDI9IjU3NSIgeTE9IjE1MyIgeDE9IjMzMCIvPjx0ZXh0IHN0eWxlPSJmb250LXNpemU6IDE2cHg7IGZvbnQtd2VpZ2h0OiA0MDA7IiBkeT0iMWVtIiBjbGFzcz0ibWVzc2FnZVRleHQiIGFsaWdubWVudC1iYXNlbGluZT0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB5PSIxNjgiIHg9IjcwMyI+YXdhaXRfc3VzcGVuZChoLCBleCwgdG9rZW4pPC90ZXh0PjxsaW5lIHN0eWxlPSJmaWxsOiBub25lOyIgbWFya2VyLWVuZD0idXJsKCNhcnJvd2hlYWQpIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMiIgY2xhc3M9Im1lc3NhZ2VMaW5lMCIgeTI9IjE5NyIgeDI9IjgyNSIgeTE9IjE5NyIgeDE9IjU4MCIvPjx0ZXh0IHN0eWxlPSJmb250LXNpemU6IDE2cHg7IGZvbnQtd2VpZ2h0OiA0MDA7IiBkeT0iMWVtIiBjbGFzcz0ibWVzc2FnZVRleHQiIGFsaWdubWVudC1iYXNlbGluZT0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB5PSIyMTIiIHg9IjcwNiI+cmVzdW1lPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2UtZGFzaGFycmF5OiAzLCAzOyBmaWxsOiBub25lOyIgbWFya2VyLWVuZD0idXJsKCNhcnJvd2hlYWQpIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMiIgY2xhc3M9Im1lc3NhZ2VMaW5lMSIgeTI9IjI0MSIgeDI9IjU4MyIgeTE9IjI0MSIgeDE9IjgyOCIvPjx0ZXh0IHN0eWxlPSJmb250LXNpemU6IDE2cHg7IGZvbnQtd2VpZ2h0OiA0MDA7IiBkeT0iMWVtIiBjbGFzcz0ibWVzc2FnZVRleHQiIGFsaWdubWVudC1iYXNlbGluZT0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB5PSIyNTYiIHg9IjQ1NiI+Y29tcGxldGUoKSBjaGVja3MgZXhlY3V0b3I8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZS1kYXNoYXJyYXk6IDMsIDM7IGZpbGw6IG5vbmU7IiBtYXJrZXItZW5kPSJ1cmwoI2Fycm93aGVhZCkiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIyIiBjbGFzcz0ibWVzc2FnZUxpbmUxIiB5Mj0iMjg1IiB4Mj0iMzMzIiB5MT0iMjg1IiB4MT0iNTc4Ii8+PC9zdmc+" alt /></p>
<ul>
<li><strong><code>run_async</code></strong> is the root of a coroutine
chain, launching from non-coroutine code</li>
<li><strong><code>run_on</code></strong> performs executor hopping from
within coroutine code, binding a child task to a different executor</li>
</ul>
<p>Because launch functions are constrained on the concept rather than a
concrete type, they work with any conforming task:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span> IoLaunchableTask Task <span class="op">&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> run_async<span class="op">(</span> executor_ref ex<span class="op">,</span> Task task <span class="op">);</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span> IoLaunchableTask Task <span class="op">&gt;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> run_on<span class="op">(</span> executor_ref ex<span class="op">,</span> Task task <span class="op">);</span></span></code></pre></div>
<p>This decoupling enables library authors to write launch utilities
that work with any conforming task type, and users to define custom task
types that integrate seamlessly with existing launchers.</p>
<h4 id="satisfying-iolaunchabletask">Satisfying IoLaunchableTask</h4>
<p><strong>Additional requirements (beyond
<em>IoAwaitableTask</em>):</strong></p>
<ol type="1">
<li>The task must provide <code>handle()</code> returning
<code>std::coroutine_handle&lt;promise_type&gt;</code> (must be
<code>noexcept</code>)</li>
<li>The task must provide <code>release()</code> to transfer ownership
without destroying the frame (must be <code>noexcept</code>)</li>
<li>The promise must provide <code>exception()</code> returning any
stored <code>std::exception_ptr</code> (must be
<code>noexcept</code>)</li>
<li>For non-void tasks, the promise must provide <code>result()</code>
returning the stored value</li>
</ol>
<p><strong>Example implementation:</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> task</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span> <span class="op">:</span> io_awaitable_support<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>exception_ptr <span class="va">ep_</span><span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>optional<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="va">result_</span><span class="op">;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>exception_ptr exception<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">ep_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        T<span class="op">&amp;&amp;</span> result<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(*</span><span class="va">result_</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ... plus all IoAwaitableTask requirements</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> <span class="va">h_</span><span class="op">;</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> handle<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">h_</span><span class="op">;</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> release<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">h_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... plus all IoAwaitableTask requirements</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The <code>handle()</code> method provides access to the typed
coroutine handle, allowing launch functions to resume the coroutine and
access the promise. The <code>release()</code> method transfers
ownership—after calling it, the task wrapper no longer destroys the
frame, leaving lifetime management to the launch function.</p>
<p>For <code>task&lt;void&gt;</code>, the <code>result()</code> method
is not required since there is no value to retrieve. The concept uses a
disjunction to handle this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span> <span class="bu">std::</span>is_void_v<span class="op">&lt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&amp;&gt;().</span>await_resume<span class="op">())</span> <span class="op">&gt;</span> <span class="op">||</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">&amp;</span> p <span class="op">)</span> <span class="op">{</span> p<span class="op">.</span>result<span class="op">();</span> <span class="op">}</span> <span class="op">);</span></span></code></pre></div>
<blockquote>
<p><strong>Non-normative note.</strong> Unlike the
<code>io_awaitable_support</code> mixin which provides promise methods,
the <code>handle()</code> and <code>release()</code> methods are
task-specific. The exception and result storage shown above is
illustrative—implementations may use different strategies such as
<code>std::variant</code> for result/exception storage.</p>
</blockquote>
<h3 id="executor_ref">4.4 executor_ref</h3>
<p>The type-erasing wrapper <code>executor_ref</code> is a
<strong>concrete type</strong> that appears uniformly in all protocol
signatures—no templates required. The implementation is compact:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> executor_ref</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="at">const</span><span class="op">*</span> <span class="va">ex_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    detail::executor_vtable <span class="at">const</span><span class="op">*</span> <span class="va">vt_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>At just two pointers, <code>executor_ref</code> copies
cheaply—important since executors propagate through every suspension
point in a coroutine chain. Equality comparison reduces to pointer
comparison, enabling the same-executor optimization in
<code>complete()</code>.</p>
<p>The implementation leverages a key property of coroutines: parameter
lifetimes in calling coroutines extend until the callee’s final
suspension. Launch functions preserve a copy of the user’s typed
<em>Executor</em>. The <code>executor_ref</code> holds a pointer to the
stored value. As the wrapper propagates through the call chain, the
original executor remains valid—it cannot go out of scope until all
coroutines in the chain are destroyed.</p>
<p>Coroutines can access their context directly using
<code>this_coro::executor</code> and <code>this_coro::stop_token</code>.
These never suspend—they return immediately with the stored values:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> cancellable_work<span class="op">()</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    executor_ref ex <span class="op">=</span> <span class="cf">co_await</span> this_coro<span class="op">::</span>executor<span class="op">;</span>         <span class="co">// never suspends</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stop_token token <span class="op">=</span> <span class="cf">co_await</span> this_coro<span class="op">::</span>stop_token<span class="op">;</span> <span class="co">// never suspends</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">1000</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>stop_requested<span class="op">())</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">co_return</span><span class="op">;</span>  <span class="co">// Exit gracefully on cancellation</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">co_await</span> process_chunk<span class="op">(</span>ex<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="how-does-a-coroutine-start">4.5 How Does a Coroutine Start?</h3>
<p>Two basic functions are needed to launch coroutine chains, and
authors can define their own custom launch functions to suit their
needs.</p>
<p><strong><code>run_async</code></strong> — launch from callbacks,
main(), event handlers, top level of a coroutine chain.</p>
<p>This uses a two-call syntax where the first call captures context and
returns a wrapper. The executor parameter is required. The remaining
parameters are optional:</p>
<ul>
<li><code>std::stop_token</code> to propagate cancelation signals</li>
<li><code>alloc</code> used to allocate <strong>all</strong> frames in
the coroutine chain</li>
<li><code>h1</code>, invoked with the task’s value at final suspend</li>
<li><code>h2</code>, invoked with <code>std::exception_ptr</code> on
exception</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Basic: executor only</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span> ex <span class="op">)(</span> my_task<span class="op">()</span> <span class="op">);</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Full: executor, stop_token, allocator, success handler, error handler</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span> ex<span class="op">,</span> st<span class="op">,</span> alloc<span class="op">,</span> h1<span class="op">,</span> h2 <span class="op">)(</span> my_task<span class="op">()</span> <span class="op">);</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Example with handlers</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span> ioc<span class="op">.</span>get_executor<span class="op">(),</span> source<span class="op">.</span>get_token<span class="op">(),</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">[](</span><span class="dt">int</span> result<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Got: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="op">},</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">[](</span><span class="bu">std::</span>exception_ptr ep<span class="op">)</span> <span class="op">{</span> <span class="co">/* handle error */</span> <span class="op">}</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="op">)(</span> compute_value<span class="op">()</span> <span class="op">);</span></span></code></pre></div>
<p>While the syntax is unfortunate, it is <em>the only way</em> given
the timing constraints of frame allocation. And hey, its better than
callback hell. What makes this possible is a small but consequential
change in C++17: guaranteed evaluation order for postfix expressions.
The standard now specifies:</p>
<blockquote>
<p>“The postfix-expression is sequenced before each expression in the
expression-list and any default argument.” — [expr.call]</p>
</blockquote>
<p>In <code>run_async(ex)(my_task())</code>, the outer
postfix-expression <code>run_async(ex)</code> is fully
evaluated—returning a wrapper that allocates the trampoline
coroutine—before <code>my_task()</code> is invoked. This guarantees LIFO
destruction order: the trampoline is allocated BEFORE the task and
serves as the task’s continuation.</p>
<p><strong><code>run_on</code></strong> — switching executors within
coroutines.</p>
<p>This binds a child task to a different executor while returning to
the caller’s executor on completion:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> parent<span class="op">()</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Child runs on worker_ex, but completion returns here</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="cf">co_await</span> run_on<span class="op">(</span> worker_ex<span class="op">,</span> compute_on_worker<span class="op">()</span> <span class="op">);</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The executor is stored by value in the calling awaitable’s frame,
keeping it alive for the operation’s duration.</p>
<h3 id="implementing-a-launcher">4.6 Implementing a Launcher</h3>
<p>A launch function (e.g., <code>run_async</code>, <code>run_on</code>)
bridges non-coroutine code into the coroutine world or performs executor
hopping within a coroutine chain. Launch functions are constrained on
<em>IoLaunchableTask</em> to work with any conforming task type:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>Executor Ex<span class="op">,</span> IoLaunchableTask Task<span class="op">&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> run_async<span class="op">(</span> Ex ex<span class="op">,</span> Task task <span class="op">);</span>  <span class="co">// caller responsible for extending lifetime</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>Executor Ex<span class="op">,</span> IoLaunchableTask Task<span class="op">&gt;</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> run_on<span class="op">(</span> Ex ex<span class="op">,</span> Task task <span class="op">);</span>     <span class="co">// caller responsible for extending lifetime</span></span></code></pre></div>
<p><strong>Requirements:</strong></p>
<ol type="1">
<li>Accept or provide an executor</li>
<li>Accept or default a stop token</li>
<li>Set thread-local allocator before invoking the child coroutine</li>
<li>Bootstrap context via <code>set_executor</code> and
<code>set_stop_token</code> on the promise</li>
<li>Manage the task lifetime via <code>handle()</code> and
<code>release()</code></li>
<li>Handle completion via <code>exception()</code> and
<code>result()</code> on the promise</li>
</ol>
<p><strong>Example implementation sketch:</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>Executor Ex<span class="op">,</span> IoLaunchableTask Task<span class="op">&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> run_async<span class="op">(</span> Ex ex<span class="op">,</span> <span class="bu">std::</span>stop_token token<span class="op">,</span> Task task <span class="op">)</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>   <span class="co">// caller responsible for extending lifetime</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> promise <span class="op">=</span> task<span class="op">.</span>handle<span class="op">().</span>promise<span class="op">();</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Bootstrap context directly into the promise</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    promise<span class="op">.</span>set_executor<span class="op">(</span> ex <span class="op">);</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    promise<span class="op">.</span>set_stop_token<span class="op">(</span> token <span class="op">);</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    promise<span class="op">.</span>set_continuation<span class="op">(</span> <span class="co">/* completion handler */</span><span class="op">,</span> ex <span class="op">);</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Transfer ownership and start execution</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    task<span class="op">.</span>release<span class="op">();</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    ex<span class="op">.</span>post<span class="op">(</span> task<span class="op">.</span>handle<span class="op">()</span> <span class="op">);</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p><strong>Non-normative note.</strong> This simplified example has the
allocator ordering problem described in §6.1: the task’s frame is
allocated before <code>run_async</code> is called, so any thread-local
allocator setup would arrive too late. A correct implementation uses the
two-call syntax shown in
§4.5—<code>run_async(ex)(my_task())</code>—where the first call returns
a wrapper that sets up the allocator before the task expression is
evaluated. A complete implementation is beyond the scope of this
example.</p>
</blockquote>
<p>Because launch functions are constrained on the concept rather than a
concrete type, they work with any conforming task implementation. This
decoupling enables library authors to write launch utilities that
interoperate with user-defined task types.</p>
<h3 id="different-design-tradeoffs">4.7 Different Design Tradeoffs</h3>
<p><code>std::execution</code> positions itself as a universal
abstraction for asynchronous work, yet its backward query model reflects
different priorities than networking’s requirements. Coroutine frame
allocation happens <em>before</em> the coroutine body executes—the
allocator must be known at invocation, not discovered later through
receiver queries. The backward flow that works for GPU dispatch (where
the work graph is built first, then executed) optimizes for different
patterns than I/O, where context must be present at the moment of
creation. This represents different design assumptions rather than a
flaw—<code>std::execution</code> optimizes for GPU/parallel workloads
where these tradeoffs make sense. Forward propagation—context flowing
from caller to callee at each suspension point—is the design that
respects coroutine allocation semantics.</p>
<p><a href="https://wg21.link/p2300">P2300</a> itself acknowledges this
timing in its “Dependently-typed senders” section:</p>
<blockquote>
<p>“In the sender/receiver model, as with coroutines, contextual
information about the current execution is most naturally propagated
from the consumer to the producer. In coroutines, that means information
like stop tokens, allocators and schedulers are propagated from the
calling coroutine to the callee. In sender/receiver, that means that
that contextual information is associated with the receiver and is
queried by the sender and/or operation state <strong>after</strong> the
sender and the receiver are <code>connect</code>-ed.”</p>
</blockquote>
<p>The consequence is stated plainly:</p>
<blockquote>
<p>“The implication of the above is that the sender alone does not have
all the information about the async computation it will ultimately
initiate; some of that information is provided late via the
receiver.”</p>
</blockquote>
<p>This “late” information includes the allocator. Consider what happens
with a coroutine-based sender:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">// P2300 query model: allocator discovered AFTER connect</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>receiver Rcvr<span class="op">&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> my_operation_state <span class="op">{</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    Rcvr <span class="va">rcvr_</span><span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> start<span class="op">()</span> <span class="op">&amp;</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Allocator available HERE, via receiver query...</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> alloc <span class="op">=</span> get_allocator<span class="op">(</span>get_env<span class="op">(</span><span class="va">rcvr_</span><span class="op">));</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...but coroutine frame was allocated BEFORE connect() returned</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="co">// The sender is created first, THEN connected:</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> async_work<span class="op">();</span>              <span class="co">// Frame allocated NOW</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sndr <span class="op">=</span> async_work<span class="op">();</span>            </span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> op <span class="op">=</span> <span class="fu">connect</span><span class="op">(</span>sndr<span class="op">,</span> receiver<span class="op">);</span>   <span class="co">// Allocator available NOW—too late</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>start<span class="op">(</span>op<span class="op">);</span></span></code></pre></div>
<p>The timing mismatch is fundamental:</p>
<p><img role="img" aria-label src="data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iLTggLTggMTUxMC45MjE4NzUgMTQzIiBzdHlsZT0ibWF4LXdpZHRoOiAxNTEwLjkycHg7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGlkPSJteS1zdmciPjxzdHlsZT4jbXktc3Zne2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTZweDtmaWxsOiMzMzM7fSNteS1zdmcgLmVycm9yLWljb257ZmlsbDojNTUyMjIyO30jbXktc3ZnIC5lcnJvci10ZXh0e2ZpbGw6IzU1MjIyMjtzdHJva2U6IzU1MjIyMjt9I215LXN2ZyAuZWRnZS10aGlja25lc3Mtbm9ybWFse3N0cm9rZS13aWR0aDoycHg7fSNteS1zdmcgLmVkZ2UtdGhpY2tuZXNzLXRoaWNre3N0cm9rZS13aWR0aDozLjVweDt9I215LXN2ZyAuZWRnZS1wYXR0ZXJuLXNvbGlke3N0cm9rZS1kYXNoYXJyYXk6MDt9I215LXN2ZyAuZWRnZS1wYXR0ZXJuLWRhc2hlZHtzdHJva2UtZGFzaGFycmF5OjM7fSNteS1zdmcgLmVkZ2UtcGF0dGVybi1kb3R0ZWR7c3Ryb2tlLWRhc2hhcnJheToyO30jbXktc3ZnIC5tYXJrZXJ7ZmlsbDojMzMzMzMzO3N0cm9rZTojMzMzMzMzO30jbXktc3ZnIC5tYXJrZXIuY3Jvc3N7c3Ryb2tlOiMzMzMzMzM7fSNteS1zdmcgc3Zne2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTZweDt9I215LXN2ZyAubGFiZWx7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2NvbG9yOiMzMzM7fSNteS1zdmcgLmNsdXN0ZXItbGFiZWwgdGV4dHtmaWxsOiMzMzM7fSNteS1zdmcgLmNsdXN0ZXItbGFiZWwgc3BhbiwjbXktc3ZnIHB7Y29sb3I6IzMzMzt9I215LXN2ZyAubGFiZWwgdGV4dCwjbXktc3ZnIHNwYW4sI215LXN2ZyBwe2ZpbGw6IzMzMztjb2xvcjojMzMzO30jbXktc3ZnIC5ub2RlIHJlY3QsI215LXN2ZyAubm9kZSBjaXJjbGUsI215LXN2ZyAubm9kZSBlbGxpcHNlLCNteS1zdmcgLm5vZGUgcG9seWdvbiwjbXktc3ZnIC5ub2RlIHBhdGh7ZmlsbDojRUNFQ0ZGO3N0cm9rZTojOTM3MERCO3N0cm9rZS13aWR0aDoxcHg7fSNteS1zdmcgLmZsb3djaGFydC1sYWJlbCB0ZXh0e3RleHQtYW5jaG9yOm1pZGRsZTt9I215LXN2ZyAubm9kZSAua2F0ZXggcGF0aHtmaWxsOiMwMDA7c3Ryb2tlOiMwMDA7c3Ryb2tlLXdpZHRoOjFweDt9I215LXN2ZyAubm9kZSAubGFiZWx7dGV4dC1hbGlnbjpjZW50ZXI7fSNteS1zdmcgLm5vZGUuY2xpY2thYmxle2N1cnNvcjpwb2ludGVyO30jbXktc3ZnIC5hcnJvd2hlYWRQYXRoe2ZpbGw6IzMzMzMzMzt9I215LXN2ZyAuZWRnZVBhdGggLnBhdGh7c3Ryb2tlOiMzMzMzMzM7c3Ryb2tlLXdpZHRoOjIuMHB4O30jbXktc3ZnIC5mbG93Y2hhcnQtbGlua3tzdHJva2U6IzMzMzMzMztmaWxsOm5vbmU7fSNteS1zdmcgLmVkZ2VMYWJlbHtiYWNrZ3JvdW5kLWNvbG9yOiNlOGU4ZTg7dGV4dC1hbGlnbjpjZW50ZXI7fSNteS1zdmcgLmVkZ2VMYWJlbCByZWN0e29wYWNpdHk6MC41O2JhY2tncm91bmQtY29sb3I6I2U4ZThlODtmaWxsOiNlOGU4ZTg7fSNteS1zdmcgLmxhYmVsQmtne2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsIDIzMiwgMjMyLCAwLjUpO30jbXktc3ZnIC5jbHVzdGVyIHJlY3R7ZmlsbDojZmZmZmRlO3N0cm9rZTojYWFhYTMzO3N0cm9rZS13aWR0aDoxcHg7fSNteS1zdmcgLmNsdXN0ZXIgdGV4dHtmaWxsOiMzMzM7fSNteS1zdmcgLmNsdXN0ZXIgc3BhbiwjbXktc3ZnIHB7Y29sb3I6IzMzMzt9I215LXN2ZyBkaXYubWVybWFpZFRvb2x0aXB7cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7bWF4LXdpZHRoOjIwMHB4O3BhZGRpbmc6MnB4O2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTJweDtiYWNrZ3JvdW5kOmhzbCg4MCwgMTAwJSwgOTYuMjc0NTA5ODAzOSUpO2JvcmRlcjoxcHggc29saWQgI2FhYWEzMztib3JkZXItcmFkaXVzOjJweDtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6MTAwO30jbXktc3ZnIC5mbG93Y2hhcnRUaXRsZVRleHR7dGV4dC1hbmNob3I6bWlkZGxlO2ZvbnQtc2l6ZToxOHB4O2ZpbGw6IzMzMzt9I215LXN2ZyA6cm9vdHstLW1lcm1haWQtZm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO308L3N0eWxlPjxnPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjEyIiBtYXJrZXJXaWR0aD0iMTIiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iNiIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydCIgaWQ9Im15LXN2Z19mbG93Y2hhcnQtcG9pbnRFbmQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDAgMCBMIDEwIDUgTCAwIDEwIHoiLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMiIgbWFya2VyV2lkdGg9IjEyIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjQuNSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydCIgaWQ9Im15LXN2Z19mbG93Y2hhcnQtcG9pbnRTdGFydCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMCA1IEwgMTAgMTAgTCAxMCAwIHoiLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjExIiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0IiBpZD0ibXktc3ZnX2Zsb3djaGFydC1jaXJjbGVFbmQiPjxjaXJjbGUgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHI9IjUiIGN5PSI1IiBjeD0iNSIvPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iLTEiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LWNpcmNsZVN0YXJ0Ij48Y2lyY2xlIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiByPSI1IiBjeT0iNSIgY3g9IjUiLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUuMiIgcmVmWD0iMTIiIHZpZXdCb3g9IjAgMCAxMSAxMSIgY2xhc3M9Im1hcmtlciBjcm9zcyBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LWNyb3NzRW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAyOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAxLDEgbCA5LDkgTSAxMCwxIGwgLTksOSIvPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNS4yIiByZWZYPSItMSIgdmlld0JveD0iMCAwIDExIDExIiBjbGFzcz0ibWFya2VyIGNyb3NzIGZsb3djaGFydCIgaWQ9Im15LXN2Z19mbG93Y2hhcnQtY3Jvc3NTdGFydCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMjsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiLz48L21hcmtlcj48ZyBjbGFzcz0icm9vdCI+PGcgY2xhc3M9ImNsdXN0ZXJzIi8+PGcgY2xhc3M9ImVkZ2VQYXRocyI+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXBvaW50RW5kKSIgc3R5bGU9ImZpbGw6bm9uZTsiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIExTLVMxIExFLVMyIiBpZD0iTC1TMS1TMi0wIiBkPSJNMjk2LjYyNSw3OC41TDMwMC43OTIsNzguNUMzMDQuOTU4LDc4LjUsMzEzLjI5Miw3OC41LDMyMC43NDIsNzguNUMzMjguMTkyLDc4LjUsMzM0Ljc1OCw3OC41LDMzOC4wNDIsNzguNUwzNDEuMzI1LDc4LjUiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtcG9pbnRFbmQpIiBzdHlsZT0iZmlsbDpub25lOyIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsgTFMtUzIgTEUtUzMiIGlkPSJMLVMyLVMzLTAiIGQ9Ik01NTQuMDg0LDYxLjVMNTc2LjA0Niw1NC4wODNDNTk4LjAwOSw0Ni42NjcsNjQxLjkzNCwzMS44MzMsNjY3LjE4LDI0LjQxN0M2OTIuNDI2LDE3LDY5OC45OTMsMTcsNzAyLjI3NiwxN0w3MDUuNTU5LDE3Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXBvaW50RW5kKSIgc3R5bGU9ImZpbGw6bm9uZTsiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIExTLVMzIExFLVM0IiBpZD0iTC1TMy1TNC0wIiBkPSJNMTExMy4wOTQsMTdMMTExNy4yNiwxN0MxMTIxLjQyNywxNywxMTI5Ljc2LDE3LDExNTYuMTEsMjQuMTQ2QzExODIuNDU5LDMxLjI5MiwxMjI2LjgyNSw0NS41ODMsMTI0OS4wMDcsNTIuNzI5TDEyNzEuMTksNTkuODc1Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXBvaW50RW5kKSIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MnB4O3N0cm9rZS1kYXNoYXJyYXk6MzsiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLWRvdHRlZCBmbG93Y2hhcnQtbGluayBMUy1TMiBMRS1TNCIgaWQ9IkwtUzItUzQtMCIgZD0iTTY2MC44NTksNzguNUw2NjUuMDI2LDc4LjVDNjY5LjE5Myw3OC41LDY3Ny41MjYsNzguNSw3MTkuMzc5LDc4LjVDNzYxLjIzMiw3OC41LDgzNi42MDQsNzguNSw5MTEuOTc3LDc4LjVDOTg3LjM0OSw3OC41LDEwNjIuNzIxLDc4LjUsMTEwMy42OTEsNzguNUMxMTQ0LjY2LDc4LjUsMTE1MS4yMjcsNzguNSwxMTU0LjUxLDc4LjVMMTE1Ny43OTQsNzguNSIvPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjbXktc3ZnX2Zsb3djaGFydC1wb2ludEVuZCkiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjJweDtzdHJva2UtZGFzaGFycmF5OjM7IiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1kb3R0ZWQgZmxvd2NoYXJ0LWxpbmsgTFMtUzQgTEUtUzIiIGlkPSJMLVM0LVMyLTAiIGQ9Ik0xMjQ1Ljc4OSw5NS41TDEyMjcuODQsOTkuMTY3QzEyMDkuODksMTAyLjgzMywxMTczLjk5MiwxMTAuMTY3LDExMTguMzU3LDExMy44MzNDMTA2Mi43MjEsMTE3LjUsOTg3LjM0OSwxMTcuNSw5MTEuOTc3LDExNy41QzgzNi42MDQsMTE3LjUsNzYxLjIzMiwxMTcuNSw3MDcuMjg3LDExNC4wMThDNjUzLjM0MywxMTAuNTM3LDYyMC44MjYsMTAzLjU3Myw2MDQuNTY3LDEwMC4wOTJMNTg4LjMwOSw5Ni42MSIvPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVscyI+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2hpdGUtc3BhY2U6IG5vd3JhcDsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTExLjk3NjU2MjUsIDc4LjUpIiBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTIzLjIxMDkzNzUsIC05LjUpIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMTkiIHdpZHRoPSIyNDYuNDIxODc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+TmVlZCBhbGxvY2F0b3I8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTExLjk3NjU2MjUsIDExNy41KSIgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTc5LjIxMDkzNzUsIC05LjUpIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMTkiIHdpZHRoPSIxNTguNDIxODc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+VG9vIGxhdGUhPC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZXMiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE0OC4zMTI1LCA3OC41KSIgZGF0YS1pZD0iUzEiIGRhdGEtbm9kZT0idHJ1ZSIgaWQ9ImZsb3djaGFydC1TMS0wIiBjbGFzcz0ibm9kZSBkZWZhdWx0IGRlZmF1bHQgZmxvd2NoYXJ0LWxhYmVsIj48cmVjdCBoZWlnaHQ9IjM0IiB3aWR0aD0iMjk2LjYyNSIgeT0iLTE3IiB4PSItMTQ4LjMxMjUiIHJ5PSIwIiByeD0iMCIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNDAuODEyNSwgLTkuNSkiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMTkiIHdpZHRoPSIyODEuNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+MS4gQ3JlYXRlIHNlbmRlcjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MDMuNzQyMTg3NSwgNzguNSkiIGRhdGEtaWQ9IlMyIiBkYXRhLW5vZGU9InRydWUiIGlkPSJmbG93Y2hhcnQtUzItMSIgY2xhc3M9Im5vZGUgZGVmYXVsdCBkZWZhdWx0IGZsb3djaGFydC1sYWJlbCI+PHJlY3QgaGVpZ2h0PSIzNCIgd2lkdGg9IjMxNC4yMzQzNzUiIHk9Ii0xNyIgeD0iLTE1Ny4xMTcxODc1IiByeT0iMCIgcng9IjAiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTQ5LjYxNzE4NzUsIC05LjUpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjE5IiB3aWR0aD0iMjk5LjIzNDM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjIuIEFsbG9jYXRlIGZyYW1lPC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkxMS45NzY1NjI1LCAxNykiIGRhdGEtaWQ9IlMzIiBkYXRhLW5vZGU9InRydWUiIGlkPSJmbG93Y2hhcnQtUzMtMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCBkZWZhdWx0IGZsb3djaGFydC1sYWJlbCI+PHJlY3QgaGVpZ2h0PSIzNCIgd2lkdGg9IjQwMi4yMzQzNzUiIHk9Ii0xNyIgeD0iLTIwMS4xMTcxODc1IiByeT0iMCIgcng9IjAiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTkzLjYxNzE4NzUsIC05LjUpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjE5IiB3aWR0aD0iMzg3LjIzNDM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjMuIGNvbm5lY3Qoc25kciwgcmN2cik8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyOS4wMDc4MTI1LCA3OC41KSIgZGF0YS1pZD0iUzQiIGRhdGEtbm9kZT0idHJ1ZSIgaWQ9ImZsb3djaGFydC1TNC01IiBjbGFzcz0ibm9kZSBkZWZhdWx0IGRlZmF1bHQgZmxvd2NoYXJ0LWxhYmVsIj48cmVjdCBoZWlnaHQ9IjM0IiB3aWR0aD0iMzMxLjgyODEyNSIgeT0iLTE3IiB4PSItMTY1LjkxNDA2MjUiIHJ5PSIwIiByeD0iMCIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTguNDE0MDYyNSwgLTkuNSkiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMTkiIHdpZHRoPSIzMTYuODI4MTI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+NC4gUXVlcnkgYWxsb2NhdG9yPC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48L2c+PC9nPjwvc3ZnPg==" alt /></p>
<p>The coroutine frame is allocated at invocation, but the allocator
isn’t queryable until <code>connect</code>—after the allocation has
already happened. No amount of query machinery can retroactively inject
an allocator into an allocation that has already occurred. This isn’t a
missing feature; it’s a fundamental ordering constraint that the
backward query model cannot satisfy.</p>
<p>Our forward flow model solves this:</p>
<p><img role="img" aria-label src="data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iLTggLTggMTMwMi4zMTI1IDEwNCIgc3R5bGU9Im1heC13aWR0aDogMTMwMi4zMXB4OyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBpZD0ibXktc3ZnIj48c3R5bGU+I215LXN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7ZmlsbDojMzMzO30jbXktc3ZnIC5lcnJvci1pY29ue2ZpbGw6IzU1MjIyMjt9I215LXN2ZyAuZXJyb3ItdGV4dHtmaWxsOiM1NTIyMjI7c3Ryb2tlOiM1NTIyMjI7fSNteS1zdmcgLmVkZ2UtdGhpY2tuZXNzLW5vcm1hbHtzdHJva2Utd2lkdGg6MnB4O30jbXktc3ZnIC5lZGdlLXRoaWNrbmVzcy10aGlja3tzdHJva2Utd2lkdGg6My41cHg7fSNteS1zdmcgLmVkZ2UtcGF0dGVybi1zb2xpZHtzdHJva2UtZGFzaGFycmF5OjA7fSNteS1zdmcgLmVkZ2UtcGF0dGVybi1kYXNoZWR7c3Ryb2tlLWRhc2hhcnJheTozO30jbXktc3ZnIC5lZGdlLXBhdHRlcm4tZG90dGVke3N0cm9rZS1kYXNoYXJyYXk6Mjt9I215LXN2ZyAubWFya2Vye2ZpbGw6IzMzMzMzMztzdHJva2U6IzMzMzMzMzt9I215LXN2ZyAubWFya2VyLmNyb3Nze3N0cm9rZTojMzMzMzMzO30jbXktc3ZnIHN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7fSNteS1zdmcgLmxhYmVse2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtjb2xvcjojMzMzO30jbXktc3ZnIC5jbHVzdGVyLWxhYmVsIHRleHR7ZmlsbDojMzMzO30jbXktc3ZnIC5jbHVzdGVyLWxhYmVsIHNwYW4sI215LXN2ZyBwe2NvbG9yOiMzMzM7fSNteS1zdmcgLmxhYmVsIHRleHQsI215LXN2ZyBzcGFuLCNteS1zdmcgcHtmaWxsOiMzMzM7Y29sb3I6IzMzMzt9I215LXN2ZyAubm9kZSByZWN0LCNteS1zdmcgLm5vZGUgY2lyY2xlLCNteS1zdmcgLm5vZGUgZWxsaXBzZSwjbXktc3ZnIC5ub2RlIHBvbHlnb24sI215LXN2ZyAubm9kZSBwYXRoe2ZpbGw6I0VDRUNGRjtzdHJva2U6IzkzNzBEQjtzdHJva2Utd2lkdGg6MXB4O30jbXktc3ZnIC5mbG93Y2hhcnQtbGFiZWwgdGV4dHt0ZXh0LWFuY2hvcjptaWRkbGU7fSNteS1zdmcgLm5vZGUgLmthdGV4IHBhdGh7ZmlsbDojMDAwO3N0cm9rZTojMDAwO3N0cm9rZS13aWR0aDoxcHg7fSNteS1zdmcgLm5vZGUgLmxhYmVse3RleHQtYWxpZ246Y2VudGVyO30jbXktc3ZnIC5ub2RlLmNsaWNrYWJsZXtjdXJzb3I6cG9pbnRlcjt9I215LXN2ZyAuYXJyb3doZWFkUGF0aHtmaWxsOiMzMzMzMzM7fSNteS1zdmcgLmVkZ2VQYXRoIC5wYXRoe3N0cm9rZTojMzMzMzMzO3N0cm9rZS13aWR0aDoyLjBweDt9I215LXN2ZyAuZmxvd2NoYXJ0LWxpbmt7c3Ryb2tlOiMzMzMzMzM7ZmlsbDpub25lO30jbXktc3ZnIC5lZGdlTGFiZWx7YmFja2dyb3VuZC1jb2xvcjojZThlOGU4O3RleHQtYWxpZ246Y2VudGVyO30jbXktc3ZnIC5lZGdlTGFiZWwgcmVjdHtvcGFjaXR5OjAuNTtiYWNrZ3JvdW5kLWNvbG9yOiNlOGU4ZTg7ZmlsbDojZThlOGU4O30jbXktc3ZnIC5sYWJlbEJrZ3tiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLCAyMzIsIDIzMiwgMC41KTt9I215LXN2ZyAuY2x1c3RlciByZWN0e2ZpbGw6I2ZmZmZkZTtzdHJva2U6I2FhYWEzMztzdHJva2Utd2lkdGg6MXB4O30jbXktc3ZnIC5jbHVzdGVyIHRleHR7ZmlsbDojMzMzO30jbXktc3ZnIC5jbHVzdGVyIHNwYW4sI215LXN2ZyBwe2NvbG9yOiMzMzM7fSNteS1zdmcgZGl2Lm1lcm1haWRUb29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO21heC13aWR0aDoyMDBweDtwYWRkaW5nOjJweDtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEycHg7YmFja2dyb3VuZDpoc2woODAsIDEwMCUsIDk2LjI3NDUwOTgwMzklKTtib3JkZXI6MXB4IHNvbGlkICNhYWFhMzM7Ym9yZGVyLXJhZGl1czoycHg7cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4OjEwMDt9I215LXN2ZyAuZmxvd2NoYXJ0VGl0bGVUZXh0e3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6MThweDtmaWxsOiMzMzM7fSNteS1zdmcgOnJvb3R7LS1tZXJtYWlkLWZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjt9PC9zdHlsZT48Zz48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMiIgbWFya2VyV2lkdGg9IjEyIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjYiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LXBvaW50RW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDAgTCAxMCA1IEwgMCAxMCB6Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTIiIG1hcmtlcldpZHRoPSIxMiIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSI0LjUiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LXBvaW50U3RhcnQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDAgNSBMIDEwIDEwIEwgMTAgMCB6Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSIxMSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydCIgaWQ9Im15LXN2Z19mbG93Y2hhcnQtY2lyY2xlRW5kIj48Y2lyY2xlIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiByPSI1IiBjeT0iNSIgY3g9IjUiLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9Ii0xIiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0IiBpZD0ibXktc3ZnX2Zsb3djaGFydC1jaXJjbGVTdGFydCI+PGNpcmNsZSBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgcj0iNSIgY3k9IjUiIGN4PSI1Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1LjIiIHJlZlg9IjEyIiB2aWV3Qm94PSIwIDAgMTEgMTEiIGNsYXNzPSJtYXJrZXIgY3Jvc3MgZmxvd2NoYXJ0IiBpZD0ibXktc3ZnX2Zsb3djaGFydC1jcm9zc0VuZCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMjsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiLz48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUuMiIgcmVmWD0iLTEiIHZpZXdCb3g9IjAgMCAxMSAxMSIgY2xhc3M9Im1hcmtlciBjcm9zcyBmbG93Y2hhcnQiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LWNyb3NzU3RhcnQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDI7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5Ii8+PC9tYXJrZXI+PGcgY2xhc3M9InJvb3QiPjxnIGNsYXNzPSJjbHVzdGVycyIvPjxnIGNsYXNzPSJlZGdlUGF0aHMiPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjbXktc3ZnX2Zsb3djaGFydC1wb2ludEVuZCkiIHN0eWxlPSJmaWxsOm5vbmU7IiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayBMUy1JMSBMRS1JMiIgaWQ9IkwtSTEtSTItMCIgZD0iTTI0NC4xMjgsMzAuNzVMMjU3LjA0NCwyOC40NThDMjY5Ljk2LDI2LjE2NywyOTUuNzkzLDIxLjU4MywzMTIuMjEsMTkuMjkyQzMyOC42MjcsMTcsMzM1LjYyOCwxNywzMzkuMTI5LDE3TDM0Mi42MywxNyIvPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjbXktc3ZnX2Zsb3djaGFydC1wb2ludEVuZCkiIHN0eWxlPSJmaWxsOm5vbmU7IiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayBMUy1JMiBMRS1JMyIgaWQ9IkwtSTItSTMtMCIgZD0iTTYwOS4zNTIsMTdMNjEzLjczNiwxN0M2MTguMTIsMTcsNjI2Ljg4OCwxNyw2NDIuNjY0LDE5LjEyOUM2NTguNDQxLDIxLjI1OSw2ODEuMjI2LDI1LjUxNyw2OTIuNjE4LDI3LjY0N0w3MDQuMDEsMjkuNzc2Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXBvaW50RW5kKSIgc3R5bGU9ImZpbGw6bm9uZTsiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIExTLUkzIExFLUk0IiBpZD0iTC1JMy1JNC0wIiBkPSJNOTM5LjY4OCw0Ny43NUw5NDMuODU0LDQ3Ljc1Qzk0OC4wMjEsNDcuNzUsOTU2LjM1NCw0Ny43NSw5NjMuODA0LDQ3Ljc1Qzk3MS4yNTQsNDcuNzUsOTc3LjgyMSw0Ny43NSw5ODEuMTA0LDQ3Ljc1TDk4NC4zODgsNDcuNzUiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtcG9pbnRFbmQpIiBzdHlsZT0iZmlsbDpub25lO3N0cm9rZS13aWR0aDoycHg7c3Ryb2tlLWRhc2hhcnJheTozOyIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tZG90dGVkIGZsb3djaGFydC1saW5rIExTLUkxIExFLUkzIiBpZD0iTC1JMS1JMy0wIiBkPSJNMjQ0LjEyOCw2NC43NUwyNTcuMDQ0LDY3LjA0MkMyNjkuOTYsNjkuMzMzLDI5NS43OTMsNzMuOTE3LDMzNC44NzgsNzYuMjA4QzM3My45NjQsNzguNSw0MjYuMzAyLDc4LjUsNDc4LjY0MSw3OC41QzUzMC45NzksNzguNSw1ODMuMzE4LDc4LjUsNjIwLjg3OSw3Ni4zNzFDNjU4LjQ0MSw3NC4yNDEsNjgxLjIyNiw2OS45ODMsNjkyLjYxOCw2Ny44NTNMNzA0LjAxLDY1LjcyNCIvPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVscyI+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2hpdGUtc3BhY2U6IG5vd3JhcDsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDc4LjY0MDYyNSwgNzguNSkiIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMzIuMDE1NjI1LCAtOS41KSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjE5IiB3aWR0aD0iMjY0LjAzMTI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+QWxsb2NhdG9yIHJlYWR5PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZXMiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE0OC4zMTI1LCA0Ny43NSkiIGRhdGEtaWQ9IkkxIiBkYXRhLW5vZGU9InRydWUiIGlkPSJmbG93Y2hhcnQtSTEtMCIgY2xhc3M9Im5vZGUgZGVmYXVsdCBkZWZhdWx0IGZsb3djaGFydC1sYWJlbCI+PHJlY3QgaGVpZ2h0PSIzNCIgd2lkdGg9IjI5Ni42MjUiIHk9Ii0xNyIgeD0iLTE0OC4zMTI1IiByeT0iMCIgcng9IjAiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTQwLjgxMjUsIC05LjUpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjE5IiB3aWR0aD0iMjgxLjYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjEuIFNldCBUTFMgYWxsb2M8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDc4LjY0MDYyNSwgMTcpIiBkYXRhLWlkPSJJMiIgZGF0YS1ub2RlPSJ0cnVlIiBpZD0iZmxvd2NoYXJ0LUkyLTEiIGNsYXNzPSJub2RlIGRlZmF1bHQgZGVmYXVsdCBmbG93Y2hhcnQtbGFiZWwiPjxyZWN0IGhlaWdodD0iMzQiIHdpZHRoPSIyNjEuNDIxODc1IiB5PSItMTciIHg9Ii0xMzAuNzEwOTM3NSIgcnk9IjAiIHJ4PSIwIiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEyMy4yMTA5Mzc1LCAtOS41KSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIxOSIgd2lkdGg9IjI0Ni40MjE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2hpdGUtc3BhY2U6IG5vd3JhcDsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj4yLiBDYWxsIHRhc2soKTwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MDAuMTcxODc1LCA0Ny43NSkiIGRhdGEtaWQ9IkkzIiBkYXRhLW5vZGU9InRydWUiIGlkPSJmbG93Y2hhcnQtSTMtMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCBkZWZhdWx0IGZsb3djaGFydC1sYWJlbCI+PHJlY3QgaGVpZ2h0PSIzNCIgd2lkdGg9IjI3OS4wMzEyNSIgeT0iLTE3IiB4PSItMTM5LjUxNTYyNSIgcnk9IjAiIHJ4PSIwIiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzMi4wMTU2MjUsIC05LjUpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjE5IiB3aWR0aD0iMjY0LjAzMTI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+My4gb3BlcmF0b3IgbmV3PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDExMzgsIDQ3Ljc1KSIgZGF0YS1pZD0iSTQiIGRhdGEtbm9kZT0idHJ1ZSIgaWQ9ImZsb3djaGFydC1JNC01IiBjbGFzcz0ibm9kZSBkZWZhdWx0IGRlZmF1bHQgZmxvd2NoYXJ0LWxhYmVsIj48cmVjdCBoZWlnaHQ9IjM0IiB3aWR0aD0iMjk2LjYyNSIgeT0iLTE3IiB4PSItMTQ4LjMxMjUiIHJ5PSIwIiByeD0iMCIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNDAuODEyNSwgLTkuNSkiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMTkiIHdpZHRoPSIyODEuNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+NC4gYXdhaXRfc3VzcGVuZDwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=" alt /></p>
<p>The same timing constraint applies to stop tokens. In
<code>std::execution</code>, the token is discovered via
<code>get_stop_token(get_env(receiver))</code>—available only after
<code>connect()</code>. In our model, the token propagates forward
alongside the executor via the same <code>await_suspend</code>
signature, available from the moment the coroutine begins.</p>
<h3 id="type-erasure">4.8 Type Erasure</h3>
<p>In <code>std::execution</code>, sender types encode the entire
operation chain:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sndr <span class="op">=</span> schedule<span class="op">(</span>sched<span class="op">)</span> <span class="op">|</span> then<span class="op">(</span>f<span class="op">)</span> <span class="op">|</span> then<span class="op">(</span>g<span class="op">);</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Type: then_sender&lt;then_sender&lt;schedule_sender&lt;Sched&gt;, F&gt;, G&gt;</span></span></code></pre></div>
<p>This “sender type explosion” makes storing senders in data structures
or passing them through non-templated interfaces difficult. Users need
type erasure—but C++26 <code>std::execution</code> provides none. The <a href="https://en.cppreference.com/w/cpp/execution">standard library</a>
includes sender concepts, factories, adaptors, and consumers, but
<strong>no type-erasing wrapper</strong>.</p>
<p>Facebook’s libunifex provides <code>any_sender_of</code> as a
workaround, but it has significant limitations:</p>
<ul>
<li>Heap allocation for every type-erased sender</li>
<li>Coroutine-based senders pay twice: frame allocation + erasure
wrapper</li>
<li>Hard-coded to <code>std::exception_ptr</code>—cannot handle
<code>std::error_code</code> without conversion</li>
<li>Essentially abandoned: the <a href="https://github.com/facebookexperimental/libunifex/commit/c93740d3c0ee74311c442f55295cd0b9c8bd63cd">last
commit</a> was over two years ago, addressing MSVC compatibility rather
than the fundamental error type limitations</li>
</ul>
<p>The P2300 architects themselves acknowledged these problems. <a href="https://github.com/facebookexperimental/libunifex/issues/244#issuecomment-810686094">Eric
Niebler noted</a>:</p>
<blockquote>
<p>“any_sender_of&lt;&gt; is only able to handle std::exception_ptr.
There currently isn’t a generalization of any_sender_of&lt;&gt; that can
handle more than std::exception_ptr… A stop-gap would be to change
any_sender_of to handle error types other than std::exception_ptr by
passing them to std::make_exception_ptr. That’s not a super-awesome
solution, though.”</p>
</blockquote>
<p><a href="https://github.com/facebookexperimental/libunifex/issues/244#issuecomment-812755302">Lewis
Baker added</a>:</p>
<blockquote>
<p>“Longer term, it probably makes sense to allow the any_sender_of type
to be parameterisable with both a list of set_value overloads and a list
of set_error overloads that it expects/supports.”</p>
</blockquote>
<p>These “longer term” fixes were proposed in 2021. They remain
unimplemented.</p>
<p>Coroutines provide structural type erasure at no additional cost:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> h<span class="op">;</span>  <span class="co">// Type-erased by design—just a pointer</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>executor_ref ex<span class="op">;</span>                 <span class="co">// Two pointers</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> t<span class="op">;</span>                     <span class="co">// Simple type, not task&lt;int, Ex, Alloc, Token&gt;</span></span></code></pre></div>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 36%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th>Aspect</th>
<th>IoAwaitable</th>
<th><code>std::execution</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Task types</td>
<td>Simple <code>task&lt;T&gt;</code></td>
<td>Encode operation chain</td>
</tr>
<tr>
<td>Standard solution</td>
<td>Native <code>coroutine_handle&lt;&gt;</code></td>
<td>None in C++26</td>
</tr>
<tr>
<td>Coroutine cost</td>
<td>Frame only</td>
<td>Frame + erasure wrapper</td>
</tr>
<tr>
<td>Error types</td>
<td>Any (<code>error_code</code>, etc.)</td>
<td>Only <code>exception_ptr</code></td>
</tr>
<tr>
<td>Conversion overhead</td>
<td>None</td>
<td>Required</td>
</tr>
</tbody>
</table>
<p>The difference is architectural. <code>std::execution</code> builds
typed operation graphs that must be explicitly erased after
construction—and the only available eraser is incomplete, non-standard,
and unmaintained. Coroutines erase at the handle boundary naturally:
<code>task&lt;T&gt;</code> remains <code>task&lt;T&gt;</code> regardless
of which executor, allocator, or stop token it uses. Context propagates
through type-erased channels, not template parameters.</p>
<hr />
<h2 id="executor-concept">5. Executor concept</h2>
<p><strong>Terminology note.</strong> We use the term <em>Executor</em>
rather than <em>scheduler</em> intentionally. In
<code>std::execution</code>, schedulers are designed for heterogeneous
computing—selecting GPU vs CPU algorithms, managing completion domains,
and dispatching to hardware accelerators. Networking has different
needs: strand serialization, I/O completion contexts, and thread
affinity. By using <em>executor</em>, we signal a distinct concept
tailored to networking’s requirements. This terminology also honors
Christopher Kohlhoff’s executor model in Boost.Asio, which established
the foundation for modern C++ asynchronous I/O.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E<span class="op">&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> Executor <span class="op">=</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>copy_constructible<span class="op">&lt;</span>E<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>equality_comparable<span class="op">&lt;</span>E<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span><span class="op">(</span> E<span class="op">&amp;</span> e<span class="op">,</span> E <span class="at">const</span><span class="op">&amp;</span> ce<span class="op">,</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;&gt;</span> h <span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> ce<span class="op">.</span>context<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">requires</span> <span class="bu">std::</span>is_lvalue_reference_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ce<span class="op">.</span>context<span class="op">())&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>derived_from<span class="op">&lt;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>remove_reference_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ce<span class="op">.</span>context<span class="op">())&gt;,</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>                execution_context<span class="op">&gt;;</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> ce<span class="op">.</span>on_work_started<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> ce<span class="op">.</span>on_work_finished<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Work submission</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> ce<span class="op">.</span>dispatch<span class="op">(</span> h <span class="op">)</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;&gt;</span> <span class="op">&gt;;</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> ce<span class="op">.</span>post<span class="op">(</span>h<span class="op">)</span> <span class="op">};</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>Executors are lightweight, copyable handles to execution contexts.
Users often provide custom executor types tailored to application
needs—priority scheduling, per-connection strand serialization, or
specialized logging and instrumentation. An execution model must respect
these customizations. It must also support executor composition:
wrapping one executor with another. The <code>strand</code> we provide,
for example, wraps an I/O context’s executor to add serialization
guarantees without changing the underlying dispatch mechanism.</p>
<p>C++20 coroutines provide type erasure <em>by construction</em>—but
not through the handle type.
<code>std::coroutine_handle&lt;void&gt;</code> and
<code>std::coroutine_handle&lt;promise_type&gt;</code> are both just
pointers with identical overhead. The erasure that matters is
<em>structural</em>:</p>
<ol type="1">
<li><strong>The frame is opaque</strong>: Callers see only a handle, not
the promise’s layout</li>
<li><strong>The return type is uniform</strong>: All coroutines
returning <code>task</code> have the same type, regardless of body</li>
<li><strong>Suspension points are hidden</strong>: The caller doesn’t
know where the coroutine may suspend</li>
</ol>
<p>This structural erasure is often lamented as overhead, but we
recognize it as opportunity: <em>the allocation we cannot avoid can pay
for the type erasure we need</em>. In our model, executor type-erasure
happens late; only after the API has locked in the executor choice.
Executor types are fully preserved at call sites even though they’re
type-erased internally. This enables zero-overhead composition at the
API boundary while maintaining uniform internal representation.</p>
<h3 id="dispatch-1">5.1 Dispatch</h3>
<p><code>dispatch</code> schedules a coroutine handle for resumption. If
the caller is already in the executor’s context, the implementation may
resume inline; otherwise, the handle is queued.</p>
<p>Unlike general-purpose executors that accept templated callables,
<code>dispatch</code> takes only
<code>std::coroutine_handle&lt;&gt;</code>—this is a coroutine-only
model. A coroutine handle is a simple pointer: no allocation, no type
erasure overhead, no virtual dispatch.</p>
<p>When an I/O context thread dequeues a completion via
<code>epoll_wait</code>, <code>GetQueuedCompletionStatus</code>, or
<code>io_uring_wait_cqe</code>, it calls <code>dispatch</code> to resume
the waiting coroutine. The return value enables symmetric transfer:
rather than recursively calling <code>resume()</code>, the caller
returns the handle to the coroutine machinery for a tail call,
preventing stack overflow.</p>
<p>Some contexts prohibit inline execution. A strand currently executing
work cannot dispatch inline without breaking
serialization—<code>dispatch</code> then behaves like <code>post</code>,
queuing unconditionally.</p>
<h3 id="post-1">5.2 Post</h3>
<p><code>post</code> queues work for later execution. Unlike
<code>dispatch</code>, it never executes inline—the work item is always
enqueued, and <code>post</code> returns immediately.</p>
<p>Use <code>post</code> for: - <strong>New work</strong> that is not a
continuation of the current operation - <strong>Breaking call
chains</strong> to bound stack depth - <strong>Safety under
locks</strong>—posting while holding a mutex avoids deadlock risk from
inline execution</p>
<h3 id="the-execution_context">5.3 The
<code>execution_context</code></h3>
<p>An executor’s <code>context()</code> function returns a reference to
the <code>execution_context</code>, the proposed base class for any
object that runs work (often containing the platform reactor or event
loop). I/O objects coordinate global state here. Implementations install
services—singletons with well-defined shutdown and destruction ordering
for safe resource release. This design borrows heavily from
Boost.Asio.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> execution_context</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> service</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>service<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        service<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">void</span> shutdown<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    execution_context<span class="op">(</span> execution_context <span class="at">const</span><span class="op">&amp;</span> <span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    execution_context<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span> execution_context <span class="at">const</span><span class="op">&amp;</span> <span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>execution_context<span class="op">();</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    execution_context<span class="op">();</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="dt">bool</span> has_service<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> T<span class="op">*</span> find_service<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> T<span class="op">&amp;</span> use_service<span class="op">();</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span> T<span class="op">&amp;</span> make_service<span class="op">(</span> Args<span class="op">&amp;&amp;...</span> args <span class="op">;</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::memory_resource<span class="op">*</span> get_frame_allocator<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_frame_allocator<span class="op">(</span> <span class="bu">std::</span>pmr::memory_resource<span class="op">*</span> mr <span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Allocator<span class="op">&gt;</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">requires</span> <span class="op">(!</span><span class="bu">std::</span>is_pointer_v<span class="op">&lt;</span>Allocator<span class="op">&gt;)</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_frame_allocator<span class="op">(</span> Allocator <span class="at">const</span><span class="op">&amp;</span> a <span class="op">);</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> shutdown<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> destroy<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Derived classes can provide: - <strong>Platform reactor</strong>:
epoll, IOCP, io_uring, or kqueue integration - <strong>Supporting
singletons</strong>: Timer queues, resolver services, signal handlers -
<strong>Orderly shutdown</strong>: <code>stop()</code> and
<code>join()</code> for graceful termination - <strong>Work
tracking</strong>: <code>on_work_started()</code> /
<code>on_work_finished()</code> for run-until-idle semantics -
<strong>Threads</strong>: for example <code>thread_pool</code>.</p>
<p>I/O objects hold a reference to their execution context, and do not
have an associated executor. A socket needs the context to register with
the reactor; the executor alone cannot provide this.</p>
<h4 id="frame-allocator">Frame Allocator</h4>
<p>The <code>execution_context</code> provides
<code>set_frame_allocator</code> and <code>get_frame_allocator</code> as
customization points for launchers when no allocator is specified at the
launch site. Since every launcher requires an <em>Executor</em>, the
execution context naturally coordinates frame allocation policy. The
default allocator can optimize for speed using recycling with
thread-local pools, or for economy on constrained platforms. Using
<code>std::pmr::memory_resource*</code> allows implementations to change
the default without breaking ABI. Applications can set a policy once via
<code>set_frame_allocator</code>, and all coroutines launched with the
default will use it—including those in foreign libraries, without
propagating allocator template parameters or recompiling.</p>
<h3 id="comparison">5.4 Comparison</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 39%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr>
<th>Aspect</th>
<th>Executor</th>
<th>Scheduler (<code>std::execution</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Purpose</td>
<td>I/O completion, serialization</td>
<td>Algorithm dispatch, GPU/CPU</td>
</tr>
<tr>
<td>Context discovery</td>
<td>Forward (at <code>co_await</code>)</td>
<td>Backward (query receiver)</td>
</tr>
<tr>
<td>Allocation</td>
<td>Early (before frame)</td>
<td>Late (at <code>connect()</code>)</td>
</tr>
<tr>
<td>Type erasure</td>
<td>Structural (coroutine handles)</td>
<td>Explicit (<code>any_sender</code>)</td>
</tr>
<tr>
<td>Operations</td>
<td><code>dispatch</code>, <code>post</code></td>
<td><code>schedule</code>, <code>transfer</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="the-allocator-1">6. The Allocator</h2>
<p>Achieving high performance levels with coroutines demands allocator
customization, yet allocator propagation presents a unique challenge.
Unlike executors and stop tokens, which can be injected at suspension
points via <code>await_transform</code>, the allocator must be available
<em>before</em> the coroutine frame exists. This section examines why
standard approaches fail and presents our solution.</p>
<h3 id="the-timing-constraint">6.1 The Timing Constraint</h3>
<p>Coroutine frame allocation has a fundamental timing constraint:
<code>operator new</code> executes before the coroutine body. When a
coroutine is called, the compiler allocates the frame first, then begins
execution. Any mechanism that injects context later—receiver connection,
<code>await_transform</code>, explicit method calls—arrives too
late.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> t <span class="op">=</span> my_coro<span class="op">(</span>sock<span class="op">);</span>  <span class="co">// operator new called HERE</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="cf">co_await</span> t<span class="op">;</span>              <span class="co">// await_transform kicks in HERE (too late)</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>spawn<span class="op">(</span> my_coro<span class="op">(</span>sock<span class="op">)</span> <span class="op">);</span>  <span class="co">// my_coro(sock) evaluated BEFORE calling spawn (too late)</span></span></code></pre></div>
<h3 id="the-awkward-approach">6.2 The Awkward Approach</h3>
<p>C++ provides exactly one hook at the right time:
<strong><code>promise_type::operator new</code></strong>. The compiler
passes coroutine arguments directly to this overload, allowing the
promise to inspect parameters and select an allocator. The standard
pattern uses <code>std::allocator_arg_t</code> as a tag to mark the
allocator parameter:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Free function: allocator intrudes on the parameter list</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> fetch_data<span class="op">(</span> <span class="bu">std::</span>allocator_arg_t<span class="op">,</span> MyAllocator alloc<span class="op">,</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>                      socket<span class="op">&amp;</span> sock<span class="op">,</span> buffer<span class="op">&amp;</span> buf <span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Member function: same intrusion</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> Connection<span class="op">::</span>process<span class="op">(</span> <span class="bu">std::</span>allocator_arg_t<span class="op">,</span> MyAllocator alloc<span class="op">,</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>                                request <span class="at">const</span><span class="op">&amp;</span> req<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>The promise type must provide multiple <code>operator new</code>
overloads to handle both cases:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="dt">promise_type</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For free functions</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span> <span class="kw">typename</span> Alloc<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args <span class="op">&gt;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">void</span><span class="op">*</span> <span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span> <span class="bu">std::</span>size_t sz<span class="op">,</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>allocator_arg_t<span class="op">,</span> Alloc<span class="op">&amp;</span> a<span class="op">,</span> Args<span class="op">&amp;&amp;...)</span> <span class="op">{</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">.</span>allocate<span class="op">(</span>sz<span class="op">);</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For member functions (this is first arg)</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> Alloc<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args <span class="op">&gt;</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">void</span><span class="op">*</span> <span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span> <span class="bu">std::</span>size_t sz<span class="op">,</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>        T<span class="op">&amp;,</span> <span class="bu">std::</span>allocator_arg_t<span class="op">,</span> Alloc<span class="op">&amp;</span> a<span class="op">,</span> Args<span class="op">&amp;&amp;...)</span> <span class="op">{</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">.</span>allocate<span class="op">(</span>sz<span class="op">);</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This approach works, but it violates encapsulation. The coroutine’s
parameter list—which should describe the algorithm’s interface—is
polluted with allocation machinery unrelated to its purpose. A function
that fetches data from a socket shouldn’t need to know or care about
memory policy. Worse, every coroutine in a call chain must thread the
allocator through its signature, even if it never uses it directly. The
allocator becomes viral, infecting interfaces throughout the
codebase.</p>
<h3 id="our-solution-thread-local-propagation">6.3 Our Solution:
Thread-Local Propagation</h3>
<p>Thread-local propagation is the only approach that maintains clean
interfaces while respecting the timing constraint. The premise is
simple: <strong>allocator customization happens at launch
sites</strong>, not within coroutine algorithms. Functions like
<code>run_async</code> and <code>run_on</code> accept allocator
parameters because they represent application policy decisions.
Coroutine algorithms don’t need to “allocator-hop”—they simply inherit
whatever allocator the application has established.</p>
<p>Our approach:</p>
<ol type="1">
<li><p><strong>Receive the allocator at launch time.</strong> The launch
site (<code>run_async</code>, <code>run_on</code>) accepts a fully-typed
<em>Allocator</em> parameter, or a
<code>std::pmr::memory_resource*</code> at the caller’s
discretion.</p></li>
<li><p><strong>Type-erase it.</strong> Typed allocators are stored as
<code>std::pmr::memory_resource*</code>, providing a uniform interface
for all downstream coroutines.</p></li>
<li><p><strong>Maintain lifetime via frame extension.</strong> The
allocator lives in the launch coroutine’s frame. Because coroutine
parameter lifetimes extend until final suspension, the allocator remains
valid for the entire operation chain.</p></li>
<li><p><strong>Propagate through thread-locals.</strong> Before any
child coroutine is invoked, the current allocator is set in TLS. The
child’s <code>promise_type::operator new</code> reads it. This is an
example implementation (non-normative):</p></li>
</ol>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Thread-local accessor (returns reference to enable setting)</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="bu">std::</span>pmr::memory_resource<span class="op">*&amp;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>current_frame_allocator<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="at">thread_local</span> <span class="bu">std::</span>pmr::memory_resource<span class="op">*</span> mr <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mr<span class="op">;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">// In promise_type::operator new</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">void</span><span class="op">*</span> <span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span> <span class="bu">std::</span>size_t size <span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">*</span> mr <span class="op">=</span> current_frame_allocator<span class="op">();</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(!</span>mr<span class="op">)</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>        mr <span class="op">=</span> <span class="bu">std::</span>pmr::get_default_resource<span class="op">();</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Store allocator pointer at end of frame for correct deallocation</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t total <span class="op">=</span> size <span class="op">+</span> <span class="kw">sizeof</span><span class="op">(</span><span class="bu">std::</span>pmr::memory_resource<span class="op">*);</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> raw <span class="op">=</span> mr<span class="op">-&gt;</span>allocate<span class="op">(</span>total<span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="bu">std::</span>max_align_t<span class="op">));</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="bu">std::</span>pmr::memory_resource<span class="op">**&gt;(</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(</span>raw<span class="op">)</span> <span class="op">+</span> size<span class="op">)</span> <span class="op">=</span> mr<span class="op">;</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> raw<span class="op">;</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span> <span class="dt">void</span><span class="op">*</span> ptr<span class="op">,</span> <span class="bu">std::</span>size_t size <span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Read the allocator pointer from the end of the frame</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">*</span> mr <span class="op">=</span> <span class="op">*</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="bu">std::</span>pmr::memory_resource<span class="op">**&gt;(</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(</span>ptr<span class="op">)</span> <span class="op">+</span> size<span class="op">);</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t total <span class="op">=</span> size <span class="op">+</span> <span class="kw">sizeof</span><span class="op">(</span><span class="bu">std::</span>pmr::memory_resource<span class="op">*);</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>    mr<span class="op">-&gt;</span>deallocate<span class="op">(</span>ptr<span class="op">,</span> total<span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span><span class="bu">std::</span>max_align_t<span class="op">));</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This design keeps allocator policy where it belongs—at the
application layer—while coroutine algorithms remain blissfully unaware
of memory strategy. The propagation happens during what we call “the
window”: a narrow interval of execution where the correct state is
guaranteed in thread-locals.</p>
<h3 id="the-window">6.4 The Window</h3>
<p>Thread-local propagation relies on a narrow, deterministic execution
window. Consider:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> parent<span class="op">()</span> <span class="op">{</span>        <span class="co">// parent is RUNNING here</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">co_await</span> child<span class="op">();</span>        <span class="co">// child() called while parent is running</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When <code>child()</code> is called: 1. <code>parent</code> coroutine
is <strong>actively executing</strong> (not suspended) 2.
<code>child()</code>’s <code>operator new</code> is called 3.
<code>child()</code>’s frame is created 4. <code>child()</code> returns
task 5. THEN <code>parent</code> suspends</p>
<p>The window is the period while the parent coroutine body executes. If
<code>parent</code> sets TLS when it resumes and <code>child()</code> is
called during that execution, <code>child</code>’s
<code>operator new</code> sees the correct TLS value.</p>
<p>TLS remains valid between <code>await_suspend</code> and
<code>await_resume</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> initial_suspend<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> awaiter <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">promise_type</span><span class="op">*</span> <span class="va">p_</span><span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> await_ready<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> await_suspend<span class="op">(</span>coro<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Capture TLS allocator while it&#39;s still valid</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">p_</span><span class="op">-&gt;</span>set_frame_allocator<span class="op">(</span> current_frame_allocator<span class="op">()</span> <span class="op">);</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> await_resume<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Restore TLS when body starts executing</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> <span class="va">p_</span><span class="op">-&gt;</span>frame_allocator<span class="op">()</span> <span class="op">)</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>                current_frame_allocator<span class="op">()</span> <span class="op">=</span> <span class="va">p_</span><span class="op">-&gt;</span>frame_allocator<span class="op">();</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> awaiter<span class="op">{</span><span class="kw">this</span><span class="op">};</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Every time the coroutine resumes (after any <code>co_await</code>),
it sets TLS to its allocator. When <code>child()</code> is called, TLS
is already pointing to <code>parent</code>’s allocator. The flow:</p>
<pre><code>parent resumes → TLS = parent.alloc
    ↓
parent calls child()
    ↓
child operator new → reads TLS → uses parent.alloc
    ↓
child created, returns task
    ↓
parent&#39;s await_suspend → parent suspends
    ↓
child resumes → TLS = child.alloc (inherited value)
    ↓
child calls grandchild() → grandchild uses TLS</code></pre>
<p>This is safe because: - TLS is only read in <code>operator new</code>
- TLS is set by the currently-running coroutine - Single-threaded: only
one coroutine runs at a time per thread - No dangling: the coroutine
that set TLS is still on the stack when <code>operator new</code> reads
it</p>
<hr />
<h2 id="comparing-design-approaches">7. Comparing Design Approaches</h2>
<p>If networking is required to integrate with
<code>std::execution</code>, I/O libraries must pay a complexity tax
regardless of whether they benefit from the framework’s
abstractions.</p>
<h3 id="integration-considerations">7.1 Integration Considerations</h3>
<p>To participate in the sender/receiver ecosystem, networking code must
implement:</p>
<ul>
<li><strong>Query protocol compliance</strong>: <code>get_env</code>,
<code>get_domain</code>, <code>get_completion_scheduler</code>—even if
only to return defaults</li>
<li><strong>Concept satisfaction</strong>: Meet sender/receiver
requirements designed for GPU algorithm dispatch</li>
<li><strong>Transform machinery</strong>: Domain transforms execute even
when they select the only available implementation</li>
<li><strong>API surface expansion</strong>: Expose attributes and
queries irrelevant to I/O operations</li>
</ul>
<p>A socket returning <code>default_domain</code> still participates in
the dispatch protocol. The <a href="https://wg21.link/p3826">P3826</a>
machinery runs, finds no customization, and falls through to the
default—overhead without corresponding benefit for I/O workloads.</p>
<h3 id="type-leakage-through-connect_result_t">7.2 Type Leakage Through
connect_result_t</h3>
<p>The sender/receiver model solves a real problem: constructing a
compile-time call graph for heterogeneous computation chains. When all
types are visible at <code>connect()</code> time, the compiler can
optimize across operation boundaries—inlining GPU kernel launches,
eliminating intermediate buffers, and selecting optimal memory transfer
strategies. For workloads where dispatch overhead is measured in
nanoseconds and operations complete in microseconds, this visibility
enables meaningful optimization.</p>
<p>Networking operates in a different regime. I/O latency is measured in
tens of microseconds (NVMe storage) to hundreds of milliseconds (network
round-trips). A 10-nanosecond dispatch optimization is irrelevant when
the operation takes 100,000 nanoseconds. The compile-time call graph
provides no benefit—there is no GPU kernel to inline, no heterogeneous
dispatch to optimize.</p>
<p>Yet the sender/receiver model requires type visibility
regardless:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// std::execution pattern</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>execution<span class="op">::</span>sender <span class="kw">auto</span> snd <span class="op">=</span> socket<span class="op">.</span>async_read<span class="op">(</span>buf<span class="op">);</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>execution<span class="op">::</span>receiver <span class="kw">auto</span> rcv <span class="op">=</span> <span class="co">/* ... */</span><span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> state <span class="op">=</span> execution<span class="op">::</span><span class="fu">connect</span><span class="op">(</span>snd<span class="op">,</span> rcv<span class="op">);</span>  <span class="co">// Type: connect_result_t&lt;Sender, Receiver&gt;</span></span></code></pre></div>
<p>The <code>connect_result_t</code> type encodes the full operation
state. Algorithms that compose senders must propagate these types:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">// From P2300: operation state types leak into composed operations</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S<span class="op">,</span> <span class="kw">class</span> R<span class="op">&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> _retry_op <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> _child_op_t <span class="op">=</span> stdexec<span class="op">::</span><span class="dt">connect_result_t</span><span class="op">&lt;</span>S<span class="op">&amp;,</span> _retry_receiver<span class="op">&lt;</span>S<span class="op">,</span> R<span class="op">&gt;&gt;;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">&lt;</span>_child_op_t<span class="op">&gt;</span> <span class="va">o_</span><span class="op">;</span>  <span class="co">// Nested operation state, fully typed</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>For networking, this creates the template tax we sought to avoid
(§3.1)—N×M instantiations, compile time growth, implementation details
exposed through every API boundary—without the optimization payoff that
justifies it for GPU workloads. Our design achieves zero type leakage;
composed algorithms expose only concrete <em>Task</em> return types.</p>
<h3 id="the-core-question">7.3 The Core Question</h3>
<p>The question is not whether <a href="https://wg21.link/p2300">P2300</a>/<a href="https://wg21.link/p3826">P3826</a> break networking code. They
don’t—defaults work. The question is whether networking should pay for
abstractions it doesn’t use.</p>
<table>
<thead>
<tr>
<th>Abstraction</th>
<th>Networking Need</th>
<th>GPU/Parallel Need</th>
</tr>
</thead>
<tbody>
<tr>
<td>Domain-based dispatch</td>
<td>None</td>
<td>Critical</td>
</tr>
<tr>
<td>Completion scheduler queries</td>
<td>Unused</td>
<td>Required</td>
</tr>
<tr>
<td>Sender transforms</td>
<td>Pass-through only</td>
<td>Algorithm selection</td>
</tr>
<tr>
<td>Typed operation state</td>
<td>ABI liability</td>
<td>Optimization opportunity</td>
</tr>
</tbody>
</table>
<p>Our analysis suggests the cost is not justified when a simpler,
networking-native design achieves the same goals without the tax.</p>
<hr />
<h2 id="miscellaneous">8. Miscellaneous</h2>
<p>This section is non-normative and demonstrates some aspects which may
be required by implementors.</p>
<h3 id="the-io_awaitable_support-mixin">9.1 The
<code>io_awaitable_support</code> Mixin</h3>
<p>This utility simplifies promise type implementation by providing all
machinery required for <em>IoAwaitableTask</em> compliance:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Derived<span class="op">&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> io_awaitable_support</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    executor_ref <span class="va">executor_</span><span class="op">;</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stop_token <span class="va">stop_token_</span><span class="op">;</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::memory_resource<span class="op">*</span> <span class="va">alloc_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    executor_ref <span class="va">caller_ex_</span><span class="op">;</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    coro <span class="va">cont_</span><span class="op">;</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">void</span><span class="op">*</span> <span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span> <span class="bu">std::</span>size_t size <span class="op">);</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span> <span class="dt">void</span><span class="op">*</span> ptr<span class="op">,</span> <span class="bu">std::</span>size_t size <span class="op">);</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_frame_allocator<span class="op">(</span> <span class="bu">std::</span>pmr::memory_resource<span class="op">*</span> alloc <span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::memory_resource<span class="op">*</span> frame_allocator<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_continuation<span class="op">(</span> coro cont<span class="op">,</span> executor_ref caller_ex <span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>    coro complete<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_stop_token<span class="op">(</span> <span class="bu">std::</span>stop_token token <span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stop_token <span class="at">const</span><span class="op">&amp;</span> stop_token<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_executor<span class="op">(</span> executor_ref ex <span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>    executor_ref executor<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">&gt;</span></span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> transform_awaitable<span class="op">(</span> A<span class="op">&amp;&amp;</span> a <span class="op">);</span></span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> await_transform<span class="op">(</span> T<span class="op">&amp;&amp;</span> t <span class="op">);</span></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Promise types inherit from this mixin to gain:</p>
<ul>
<li><strong>Frame allocation</strong>:
<code>operator new</code>/<code>delete</code> using the thread-local
frame allocator, with the allocator pointer stored at the end of each
frame for correct deallocation</li>
<li><strong>Frame allocator storage</strong>:
<code>set_frame_allocator</code>/<code>frame_allocator</code> for
propagation to child tasks</li>
<li><strong>Continuation support</strong>:
<code>set_continuation</code>/<code>complete</code> implementing the
same-executor optimization</li>
<li><strong>Stop token storage</strong>:
<code>set_stop_token</code>/<code>stop_token</code> for cancellation
propagation</li>
<li><strong>Executor storage</strong>:
<code>set_executor</code>/<code>executor</code> for executor
affinity</li>
<li><strong>Awaitable transformation</strong>:
<code>await_transform</code> intercepts <code>get_stop_token_tag</code>
and <code>get_executor_tag</code>, delegating all other awaitables to
<code>transform_awaitable</code></li>
</ul>
<p>The <code>await_transform</code> method uses
<code>if constexpr</code> to dispatch tag types to immediate awaiters
(where <code>await_ready()</code> returns <code>true</code>), enabling
<code>co_await get_executor()</code> and
<code>co_await get_stop_token()</code> without suspension. Other
awaitables pass through to <code>transform_awaitable</code>, which
derived classes can override to add custom transformation logic.</p>
<p>This mixin encapsulates the boilerplate that every
<em>IoLaunchableTask</em>-compatible promise type would otherwise
duplicate.</p>
<hr />
<h2 id="conclusion">9. Conclusion</h2>
<p>We have presented an execution model designed from the ground up for
coroutine-driven asynchronous I/O:</p>
<ol type="1">
<li><p><strong>Minimal executor abstraction</strong>: Two
operations—<code>dispatch</code> and <code>post</code>—suffice for I/O
workloads.</p></li>
<li><p><strong>Clear responsibility model</strong>: The application
decides execution, allocation, and stop policy.</p></li>
<li><p><strong>Complete type hiding</strong>: Executor types do not leak
into public interfaces. Platform I/O types remain hidden in translation
units. Composed algorithms expose only concrete Task return types. This
directly enables ABI stability.</p></li>
<li><p><strong>Forward context propagation</strong>: Execution context
flows with control flow, not against it. No backward queries.
<em>IoAwaitableTask</em> injects context through
<code>await_transform</code>.</p></li>
<li><p><strong>Conscious tradeoff</strong>: One pointer indirection per
I/O operation (~1-2 nanoseconds) buys encapsulation, ABI stability, and
fast compilation. For I/O-bound workloads where operations take 10,000+
nanoseconds, this cost is negligible.</p></li>
<li><p><strong>Borrows from existing practice</strong>: Our design is
heavily inspired by Boost.Asio. It gets most things right.</p></li>
</ol>
<p>The comparison with <code>std::execution</code> (§3.4, §7) is
instructive: that framework’s complexity serves GPU workloads, not
networking. The number of papers in flight for
<code>std::execution</code> reflects the complexity inherent in its
ambitious scope. This complexity introduces risk for networking: as
design attention focuses on GPU and parallel workloads, I/O-specific
requirements may become secondary considerations. <a href="https://wg21.link/p3826">P3826</a> adds machinery that provides
limited benefit for networking: domain-based algorithm dispatch,
completion scheduler queries, sender transforms. Our design sidesteps
these issues entirely.</p>
<p>In October 2021, LEWG polled:</p>
<blockquote>
<p><em>“Networking should be based on the sender/receiver model” — Weak
consensus in favor</em></p>
</blockquote>
<p>This direction was reasonable given the information available at the
time. However, the evidence presented in this paper—the timing
incompatibility with coroutine allocation, the forward-vs-backward
context flow mismatch, the complexity overhead without corresponding
benefit for I/O—suggests the committee may wish to revisit this
guidance. A “weak consensus” is not a mandate; it is an invitation to
reconsider as new information emerges. The future of asynchronous C++
need not be a single universal abstraction—purpose-built frameworks can
excel at their primary use cases while remaining interoperable at the
boundaries.</p>
<hr />
<h2 id="closing-thoughts">10. Closing Thoughts</h2>
<p>A reference implementation of this protocol exists as a complete
library: <a href="https://github.com/cppalliance/capy">Capy</a>. It is
also the foundation for the <a href="https://github.com/cppalliance/corosio">Corosio</a> library which
offers sockets, timers, signals, DNS resolution, and integration on
multiple platforms. These libraries arose from use-case-first driven
development with a simple mandate: produce a networking library built
only for coroutines. Every design decision: forward context propagation,
type-erased executors, the thread-local allocation window, emerged from
solving real problems in production I/O code.</p>
<p>The future of C++ depends less on papers and more on practitioners
who ship working code. Open source library authors are the true
pioneers—they discover what works by building systems that people
actually use. Standards should follow implementations, not the reverse.
The <em>IoAwaitable</em> protocol is offered in that spirit: not as a
theoretical construct, but as a distillation of patterns proven in
practice.</p>
<hr />
<h2 id="wording">11. Wording</h2>
<blockquote>
<p><strong>Non-normative note.</strong> The wording below is not
primarily intended for standardization. Its purpose is to demonstrate
how a networking-focused, use-case-first design produces a dramatically
leaner specification footprint. Compare this compact specification
against the machinery required by P2300/P3826—domains, completion
schedulers, sender transforms, query protocols—and observe how much
simpler an execution model becomes when designed specifically for I/O
workloads.</p>
</blockquote>
<h3 id="header-io_awaitable-synopsis-ioawait.syn">12.1 Header
<code>&lt;io_awaitable&gt;</code> synopsis [ioawait.syn]</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// [ioawait.concepts], concepts</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span> <span class="kw">concept</span> io_awaitable <span class="op">=</span> see<span class="op">-</span>below<span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">concept</span> io_awaitable_task <span class="op">=</span> see<span class="op">-</span>below<span class="op">;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">concept</span> io_launchable_task <span class="op">=</span> see<span class="op">-</span>below<span class="op">;</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E<span class="op">&gt;</span> <span class="kw">concept</span> executor <span class="op">=</span> see<span class="op">-</span>below<span class="op">;</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// [ioawait.execref], class executor_ref</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> executor_ref<span class="op">;</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// [ioawait.execctx], class execution_context</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> execution_context<span class="op">;</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// [ioawait.launch], launch functions</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>executor Ex<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    unspecified run_async<span class="op">(</span>Ex <span class="at">const</span><span class="op">&amp;</span> ex<span class="op">,</span> Args<span class="op">&amp;&amp;...</span> args<span class="op">);</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span>executor Ex<span class="op">,</span> io_launchable_task Task<span class="op">&gt;</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>    unspecified run_on<span class="op">(</span>Ex <span class="at">const</span><span class="op">&amp;</span> ex<span class="op">,</span> Task task<span class="op">);</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// [ioawait.thiscoro], namespace this_coro</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">namespace</span> this_coro <span class="op">{</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> executor_tag <span class="op">{};</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> stop_token_tag <span class="op">{};</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">constexpr</span> executor_tag executor<span class="op">{};</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">constexpr</span> stop_token_tag stop_token<span class="op">{};</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="concepts-ioawait.concepts">12.2 Concepts [ioawait.concepts]</h3>
<h4 id="concept-io_awaitable-ioawait.concepts.awaitable">12.2.1 Concept
<code>io_awaitable</code> [ioawait.concepts.awaitable]</h4>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> io_awaitable <span class="op">=</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span>A a<span class="op">,</span> coroutine_handle<span class="op">&lt;&gt;</span> h<span class="op">,</span> executor_ref ex<span class="op">,</span> stop_token token<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>await_suspend<span class="op">(</span>h<span class="op">,</span> ex<span class="op">,</span> token<span class="op">);</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<p>1 A type <code>A</code> meets the <code>io_awaitable</code>
requirements if it satisfies the syntactic requirements above and the
semantic requirements below.</p>
<p>2 In Table 1, <code>a</code> denotes a value of type <code>A</code>,
<code>h</code> denotes a value of type
<code>coroutine_handle&lt;&gt;</code> representing the calling
coroutine, <code>ex</code> denotes a value of type
<code>executor_ref</code>, and <code>token</code> denotes a value of
type <code>stop_token</code>.</p>
<p><strong>Table 1 — io_awaitable requirements</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 21%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-conditions</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a.await_suspend(h, ex, token)</code></td>
<td><code>void</code>, <code>bool</code>, or
<code>coroutine_handle&lt;&gt;</code></td>
<td><em>Effects:</em> Initiates the asynchronous operation represented
by <code>a</code>. The executor <code>ex</code> and stop token
<code>token</code> are propagated to the operation. If the return type
is <code>coroutine_handle&lt;&gt;</code>, the returned handle is
suitable for symmetric transfer. <em>Preconditions:</em> <code>h</code>
is a suspended coroutine. <code>ex</code> refers to a valid executor.
<em>Synchronization:</em> The call to <code>await_suspend</code>
synchronizes with the resumption of <code>h</code> or any coroutine to
which control is transferred.</td>
</tr>
</tbody>
</table>
<p>3 [ <em>Note:</em> The three-argument <code>await_suspend</code>
signature distinguishes <code>io_awaitable</code> types from standard
awaitables. A compliant coroutine’s <code>await_transform</code> calls
this signature, enabling static detection of protocol mismatches at
compile time. <em>— end note</em> ]</p>
<h4 id="concept-io_awaitable_task-ioawait.concepts.task">12.2.2 Concept
<code>io_awaitable_task</code> [ioawait.concepts.task]</h4>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> io_awaitable_task <span class="op">=</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  io_awaitable<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span> <span class="op">{</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">;</span> <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span><span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">&amp;</span> p<span class="op">,</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>           <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span> <span class="at">const</span><span class="op">&amp;</span> cp<span class="op">,</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>           executor_ref ex<span class="op">,</span> stop_token st<span class="op">,</span> coroutine_handle<span class="op">&lt;&gt;</span> cont<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> p<span class="op">.</span>set_executor<span class="op">(</span>ex<span class="op">)</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> p<span class="op">.</span>set_stop_token<span class="op">(</span>st<span class="op">)</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> p<span class="op">.</span>set_continuation<span class="op">(</span>cont<span class="op">,</span> ex<span class="op">)</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> cp<span class="op">.</span>executor<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span>executor_ref<span class="op">&gt;;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> cp<span class="op">.</span>stop_token<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span>stop_token <span class="at">const</span><span class="op">&amp;&gt;;</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> cp<span class="op">.</span>complete<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span>coroutine_handle<span class="op">&lt;&gt;&gt;;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<p>1 A type <code>T</code> meets the <code>io_awaitable_task</code>
requirements if it satisfies <code>io_awaitable&lt;T&gt;</code>, has a
nested type <code>promise_type</code>, and the promise type satisfies
the semantic requirements below.</p>
<p>2 In Table 2, <code>p</code> denotes an lvalue of type
<code>typename T::promise_type</code>, <code>cp</code> denotes a const
lvalue of type <code>typename T::promise_type</code>, <code>ex</code>
denotes a value of type <code>executor_ref</code>,
<code>caller_ex</code> denotes a value of type <code>executor_ref</code>
representing the caller’s executor, <code>st</code> denotes a value of
type <code>stop_token</code>, and <code>cont</code> denotes a value of
type <code>coroutine_handle&lt;&gt;</code>.</p>
<p><strong>Table 2 — io_awaitable_task promise requirements</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 21%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-conditions</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p.set_executor(ex)</code></td>
<td><code>void</code></td>
<td><em>Effects:</em> Stores <code>ex</code> as the executor associated
with this coroutine. Shall not exit via an exception.
<em>Postconditions:</em> <code>p.executor() == ex</code>.</td>
</tr>
<tr>
<td><code>p.set_stop_token(st)</code></td>
<td><code>void</code></td>
<td><em>Effects:</em> Stores <code>st</code> as the stop token
associated with this coroutine. Shall not exit via an exception.
<em>Postconditions:</em> <code>p.stop_token()</code> returns a reference
to the stored token.</td>
</tr>
<tr>
<td><code>p.set_continuation(cont, caller_ex)</code></td>
<td><code>void</code></td>
<td><em>Effects:</em> Stores <code>cont</code> as the continuation to
resume when this coroutine completes, and <code>caller_ex</code> as the
executor on which to resume it. Shall not exit via an exception.</td>
</tr>
<tr>
<td><code>cp.executor()</code></td>
<td><code>executor_ref</code></td>
<td><em>Returns:</em> The executor previously set via
<code>set_executor</code>. Shall not exit via an exception.
<em>Preconditions:</em> <code>set_executor</code> has been called.</td>
</tr>
<tr>
<td><code>cp.stop_token()</code></td>
<td><code>stop_token const&amp;</code></td>
<td><em>Returns:</em> A reference to the stop token previously set via
<code>set_stop_token</code>. Shall not exit via an exception.
<em>Preconditions:</em> <code>set_stop_token</code> has been
called.</td>
</tr>
<tr>
<td><code>cp.complete()</code></td>
<td><code>coroutine_handle&lt;&gt;</code></td>
<td><em>Returns:</em> A coroutine handle for symmetric transfer at final
suspension. If no continuation was set, returns
<code>noop_coroutine()</code>. If
<code>cp.executor() == caller_ex</code>, returns <code>cont</code>
directly (same-executor optimization). Otherwise, dispatches
<code>cont</code> through <code>caller_ex</code> and returns the result.
Shall not exit via an exception.</td>
</tr>
</tbody>
</table>
<p>3 The promise’s <code>await_transform</code> shall intercept child
awaitables and inject the current executor and stop token via the
three-argument <code>await_suspend</code> signature.</p>
<p>4 [ <em>Note:</em> The <code>set_continuation</code> function
receives both the continuation handle and the caller’s executor to
enable the same-executor optimization: when executors match,
<code>complete()</code> returns the continuation directly for
zero-overhead symmetric transfer. <em>— end note</em> ]</p>
<h4 id="concept-io_launchable_task-ioawait.concepts.launch">12.2.3
Concept <code>io_launchable_task</code> [ioawait.concepts.launch]</h4>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> io_launchable_task <span class="op">=</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  io_awaitable_task<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span>T<span class="op">&amp;</span> t<span class="op">,</span> T <span class="at">const</span><span class="op">&amp;</span> ct<span class="op">,</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span> <span class="at">const</span><span class="op">&amp;</span> cp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> ct<span class="op">.</span>handle<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span>coroutine_handle<span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">&gt;&gt;;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> cp<span class="op">.</span>exception<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span>exception_ptr<span class="op">&gt;;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> t<span class="op">.</span>release<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">(</span>is_void_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>declval<span class="op">&lt;</span>T<span class="op">&amp;&gt;().</span>await_resume<span class="op">())&gt;</span> <span class="op">||</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">requires</span><span class="op">(</span><span class="kw">typename</span> T<span class="op">::</span><span class="dt">promise_type</span><span class="op">&amp;</span> p<span class="op">)</span> <span class="op">{</span> p<span class="op">.</span>result<span class="op">();</span> <span class="op">});</span></span></code></pre></div>
<p>1 A type <code>T</code> meets the <code>io_launchable_task</code>
requirements if it satisfies <code>io_awaitable_task&lt;T&gt;</code> and
the additional semantic requirements below.</p>
<p>2 In Table 3, <code>t</code> denotes an lvalue of type
<code>T</code>, <code>ct</code> denotes a const lvalue of type
<code>T</code>, <code>cp</code> denotes a const lvalue of type
<code>typename T::promise_type</code>, and <code>p</code> denotes an
lvalue of type <code>typename T::promise_type</code>.</p>
<p><strong>Table 3 — io_launchable_task requirements</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 21%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-conditions</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ct.handle()</code></td>
<td><code>coroutine_handle&lt;typename T::promise_type&gt;</code></td>
<td><em>Returns:</em> The typed coroutine handle for this task. Shall
not exit via an exception.</td>
</tr>
<tr>
<td><code>cp.exception()</code></td>
<td><code>exception_ptr</code></td>
<td><em>Returns:</em> The exception captured during coroutine execution,
or a null <code>exception_ptr</code> if no exception occurred. Shall not
exit via an exception.</td>
</tr>
<tr>
<td><code>t.release()</code></td>
<td><code>void</code></td>
<td><em>Effects:</em> Releases ownership of the coroutine frame. After
this call, the task object no longer destroys the frame upon
destruction. Shall not exit via an exception. <em>Postconditions:</em>
The task object is in a moved-from state.</td>
</tr>
<tr>
<td><code>p.result()</code></td>
<td><em>unspecified</em></td>
<td><em>Returns:</em> The result value stored in the promise.
<em>Preconditions:</em> The coroutine completed with a value (not an
exception). <em>Remarks:</em> This expression is only required when
<code>await_resume()</code> returns a non-void type.</td>
</tr>
</tbody>
</table>
<p>3 [ <em>Note:</em> The <code>handle()</code> and
<code>release()</code> methods enable launch functions to manage task
lifetime directly. After <code>release()</code>, the launch function
assumes responsibility for destroying the coroutine frame. <em>— end
note</em> ]</p>
<h4 id="concept-executor-ioawait.concepts.executor">12.2.4 Concept
<code>executor</code> [ioawait.concepts.executor]</h4>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E<span class="op">&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> executor <span class="op">=</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  copy_constructible<span class="op">&lt;</span>E<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  equality_comparable<span class="op">&lt;</span>E<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span>E<span class="op">&amp;</span> e<span class="op">,</span> E <span class="at">const</span><span class="op">&amp;</span> ce<span class="op">,</span> coroutine_handle<span class="op">&lt;&gt;</span> h<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> ce<span class="op">.</span>context<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> see<span class="op">-</span>below<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> ce<span class="op">.</span>on_work_started<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> ce<span class="op">.</span>on_work_finished<span class="op">()</span> <span class="op">}</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> ce<span class="op">.</span>dispatch<span class="op">(</span>h<span class="op">)</span> <span class="op">}</span> <span class="op">-&gt;</span> convertible_to<span class="op">&lt;</span>coroutine_handle<span class="op">&lt;&gt;&gt;;</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> ce<span class="op">.</span>post<span class="op">(</span>h<span class="op">)</span> <span class="op">};</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<p>1 A type <code>E</code> meets the <code>executor</code> requirements
if it satisfies <code>copy_constructible</code> and
<code>equality_comparable</code>, and the semantic requirements
below.</p>
<p>2 No comparison operator, copy operation, move operation, swap
operation, or member functions <code>context</code>,
<code>on_work_started</code>, and <code>on_work_finished</code> on these
types shall exit via an exception.</p>
<p>3 The executor copy constructor, comparison operators, and other
member functions defined in these requirements shall not introduce data
races as a result of concurrent calls to those functions from different
threads. The member function <code>dispatch</code> may be recursively
reentered.</p>
<p>4 Let <code>ctx</code> be the execution context returned by the
executor’s <code>context()</code> member function. An executor becomes
invalid when the first call to <code>ctx.shutdown()</code> returns. The
effect of calling <code>on_work_started</code>,
<code>on_work_finished</code>, <code>dispatch</code>, or
<code>post</code> on an invalid executor is undefined. [ <em>Note:</em>
The copy constructor, comparison operators, and <code>context()</code>
member function continue to remain valid until <code>ctx</code> is
destroyed. <em>— end note</em> ]</p>
<p>5 In Table 4, <code>x1</code> and <code>x2</code> denote (possibly
const) values of type <code>E</code>, <code>mx1</code> denotes an xvalue
of type <code>E</code>, <code>h</code> denotes a value of type
<code>coroutine_handle&lt;&gt;</code>, and <code>u</code> denotes an
identifier.</p>
<p><strong>Table 4 — executor requirements</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 21%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-conditions</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>E u(x1);</code></td>
<td></td>
<td>Shall not exit via an exception. <em>Postconditions:</em>
<code>u == x1</code> and
<code>addressof(u.context()) == addressof(x1.context())</code>.</td>
</tr>
<tr>
<td><code>E u(mx1);</code></td>
<td></td>
<td>Shall not exit via an exception. <em>Postconditions:</em>
<code>u</code> equals the prior value of <code>mx1</code> and
<code>addressof(u.context())</code> equals the prior value of
<code>addressof(mx1.context())</code>.</td>
</tr>
<tr>
<td><code>x1 == x2</code></td>
<td><code>bool</code></td>
<td><em>Returns:</em> <code>true</code> only if <code>x1</code> and
<code>x2</code> can be interchanged with identical effects in any of the
expressions defined in these type requirements. [ <em>Note:</em>
Returning <code>false</code> does not necessarily imply that the effects
are not identical. <em>— end note</em> ] <code>operator==</code> shall
be reflexive, symmetric, and transitive, and shall not exit via an
exception.</td>
</tr>
<tr>
<td><code>x1 != x2</code></td>
<td><code>bool</code></td>
<td>Same as <code>!(x1 == x2)</code>.</td>
</tr>
<tr>
<td><code>x1.context()</code></td>
<td><code>execution_context&amp;</code>, or <code>C&amp;</code> where
<code>C</code> is publicly derived from
<code>execution_context</code></td>
<td>Shall not exit via an exception. The comparison operators and member
functions defined in these requirements shall not alter the reference
returned by this function.</td>
</tr>
<tr>
<td><code>x1.on_work_started()</code></td>
<td><code>void</code></td>
<td>Shall not exit via an exception.</td>
</tr>
<tr>
<td><code>x1.on_work_finished()</code></td>
<td><code>void</code></td>
<td>Shall not exit via an exception. <em>Preconditions:</em> A preceding
call <code>x2.on_work_started()</code> where <code>x1 == x2</code>.</td>
</tr>
<tr>
<td><code>x1.dispatch(h)</code></td>
<td><code>coroutine_handle&lt;&gt;</code></td>
<td><em>Effects:</em> Schedules <code>h</code> for resumption. If the
caller is already in the executor’s context and inline execution is
safe, may resume <code>h</code> immediately. Otherwise, queues
<code>h</code> for later execution. <em>Returns:</em> A coroutine handle
suitable for symmetric transfer; either <code>h</code> (for inline
execution), <code>noop_coroutine()</code> (if queued), or another
handle. <em>Synchronization:</em> The invocation of
<code>dispatch</code> synchronizes with the resumption of
<code>h</code>.</td>
</tr>
<tr>
<td><code>x1.post(h)</code></td>
<td><code>void</code></td>
<td><em>Effects:</em> Queues <code>h</code> for later execution. The
executor shall not block forward progress of the caller pending
resumption of <code>h</code>. The executor shall not resume
<code>h</code> before the call to <code>post</code> returns.
<em>Synchronization:</em> The invocation of <code>post</code>
synchronizes with the resumption of <code>h</code>.</td>
</tr>
</tbody>
</table>
<p>6 [ <em>Note:</em> Unlike the Networking TS executor requirements,
this concept operates on <code>coroutine_handle&lt;&gt;</code> rather
than arbitrary function objects. This restriction enables
zero-allocation dispatch in the common case and leverages the structural
type erasure that coroutines already provide. <em>— end note</em> ]</p>
<h3 id="class-executor_ref-ioawait.execref">12.3 Class
<code>executor_ref</code> [ioawait.execref]</h3>
<p>1 Class <code>executor_ref</code> is a type-erasing wrapper for
executors satisfying the <code>executor</code> concept. It provides a
uniform, non-templated interface for executor operations.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> executor_ref <span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="at">const</span><span class="op">*</span> <span class="va">ex_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span>                    <span class="co">// exposition only</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    unspecified <span class="at">const</span><span class="op">*</span> <span class="va">vt_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span>             <span class="co">// exposition only</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    executor_ref<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    executor_ref<span class="op">(</span>executor_ref <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    executor_ref<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>executor_ref <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span>executor E<span class="op">&gt;</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>      executor_ref<span class="op">(</span>E <span class="at">const</span><span class="op">&amp;</span> e<span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>executor_ref <span class="at">const</span><span class="op">&amp;)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    execution_context<span class="op">&amp;</span> context<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> on_work_started<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> on_work_finished<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>    coroutine_handle<span class="op">&lt;&gt;</span> dispatch<span class="op">(</span>coroutine_handle<span class="op">&lt;&gt;</span> h<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> post<span class="op">(</span>coroutine_handle<span class="op">&lt;&gt;</span> h<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>2 The class <code>executor_ref</code> satisfies
<code>copy_constructible</code> and <code>equality_comparable</code>.
Copies of an <code>executor_ref</code> refer to the same underlying
executor.</p>
<p>3 [ <em>Note:</em> At two pointers in size, <code>executor_ref</code>
is designed for efficient propagation through coroutine chains. Equality
comparison reduces to pointer comparison, enabling the same-executor
optimization in <code>complete()</code>. <em>— end note</em> ]</p>
<h4 id="executor_ref-constructors-ioawait.execref.cons">12.3.1
<code>executor_ref</code> constructors [ioawait.execref.cons]</h4>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>executor_ref<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span></code></pre></div>
<p>1 <em>Postconditions:</em> <code>bool(*this) == false</code>.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>executor E<span class="op">&gt;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  executor_ref<span class="op">(</span>E <span class="at">const</span><span class="op">&amp;</span> e<span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>2 <em>Effects:</em> Constructs an <code>executor_ref</code> that
refers to <code>e</code>.</p>
<p>3 <em>Postconditions:</em> <code>bool(*this) == true</code>.
<code>addressof(context())</code> equals
<code>addressof(e.context())</code>.</p>
<p>4 <em>Remarks:</em> The behavior is undefined if <code>e</code> is
destroyed or becomes invalid while <code>*this</code> or any copy of
<code>*this</code> still exists. [ <em>Note:</em> In typical usage, the
referenced executor is stored in a launch function’s frame or a
coroutine promise, which outlives all <code>executor_ref</code> copies
propagated through the coroutine chain. <em>— end note</em> ]</p>
<h4 id="executor_ref-observers-ioawait.execref.obs">12.3.2
<code>executor_ref</code> observers [ioawait.execref.obs]</h4>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>1 <em>Returns:</em> <code>true</code> if <code>*this</code> refers to
an executor, otherwise <code>false</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>executor_ref <span class="at">const</span><span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>2 <em>Returns:</em> <code>true</code> if <code>*this</code> and
<code>other</code> were both constructed from the same executor object
(by address), or if both are empty. Otherwise <code>false</code>.</p>
<p>3 <em>Remarks:</em> Two <code>executor_ref</code> objects constructed
from different executor objects compare unequal even if those executors
would compare equal via their own <code>operator==</code>.</p>
<h4 id="executor_ref-operations-ioawait.execref.ops">12.3.3
<code>executor_ref</code> operations [ioawait.execref.ops]</h4>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>execution_context<span class="op">&amp;</span> context<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>1 <em>Preconditions:</em> <code>bool(*this) == true</code>.</p>
<p>2 <em>Returns:</em> A reference to the execution context of the
referenced executor, as if by calling <code>e.context()</code> where
<code>e</code> is the referenced executor.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> on_work_started<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>3 <em>Preconditions:</em> <code>bool(*this) == true</code>.</p>
<p>4 <em>Effects:</em> Equivalent to <code>e.on_work_started()</code>
where <code>e</code> is the referenced executor.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> on_work_finished<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>5 <em>Preconditions:</em> <code>bool(*this) == true</code>. A
preceding call to <code>on_work_started()</code> on <code>*this</code>
or on an <code>executor_ref</code> that compares equal to
<code>*this</code>.</p>
<p>6 <em>Effects:</em> Equivalent to <code>e.on_work_finished()</code>
where <code>e</code> is the referenced executor.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>coroutine_handle<span class="op">&lt;&gt;</span> dispatch<span class="op">(</span>coroutine_handle<span class="op">&lt;&gt;</span> h<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>7 <em>Preconditions:</em> <code>bool(*this) == true</code>.
<code>h</code> is a valid, suspended coroutine handle.</p>
<p>8 <em>Effects:</em> Equivalent to <code>e.dispatch(h)</code> where
<code>e</code> is the referenced executor.</p>
<p>9 <em>Returns:</em> A coroutine handle suitable for symmetric
transfer.</p>
<p>10 <em>Synchronization:</em> The invocation of <code>dispatch</code>
synchronizes with the resumption of <code>h</code>.</p>
<p>11 <em>Throws:</em> <code>bad_executor</code> if
<code>bool(*this) == false</code>.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> post<span class="op">(</span>coroutine_handle<span class="op">&lt;&gt;</span> h<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>12 <em>Preconditions:</em> <code>bool(*this) == true</code>.
<code>h</code> is a valid, suspended coroutine handle.</p>
<p>13 <em>Effects:</em> Equivalent to <code>e.post(h)</code> where
<code>e</code> is the referenced executor.</p>
<p>14 <em>Synchronization:</em> The invocation of <code>post</code>
synchronizes with the resumption of <code>h</code>.</p>
<p>15 <em>Throws:</em> <code>bad_executor</code> if
<code>bool(*this) == false</code>.</p>
<h3 id="class-execution_context-ioawait.execctx">12.4 Class
<code>execution_context</code> [ioawait.execctx]</h3>
<p>1 Class <code>execution_context</code> is the base class for objects
that manage a set of services and provide an execution environment for
I/O operations. Derived classes typically provide platform-specific
reactor integration (epoll, IOCP, io_uring, kqueue).</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> execution_context <span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> service<span class="op">;</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    execution_context<span class="op">();</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    execution_context<span class="op">(</span>execution_context <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    execution_context<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>execution_context <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>execution_context<span class="op">();</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="dt">bool</span> has_service<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> T<span class="op">*</span> find_service<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> T<span class="op">&amp;</span> use_service<span class="op">();</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span> T<span class="op">&amp;</span> make_service<span class="op">(</span>Args<span class="op">&amp;&amp;...</span> args<span class="op">);</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>    pmr<span class="op">::</span>memory_resource<span class="op">*</span> get_frame_allocator<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_frame_allocator<span class="op">(</span>pmr<span class="op">::</span>memory_resource<span class="op">*</span> mr<span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> shutdown<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> destroy<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> execution_context<span class="op">::</span>service <span class="op">{</span></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>service<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a>    service<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> shutdown<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>2 Access to the services of an <code>execution_context</code> is via
the function templates <code>use_service</code>,
<code>make_service</code>, <code>find_service</code>, and
<code>has_service</code>.</p>
<p>3 In a call to <code>use_service&lt;Service&gt;</code>, the type
argument chooses a service from the set in the
<code>execution_context</code>. If the service is not present, an object
of type <code>Service</code> is created and added. A program can check
if an <code>execution_context</code> contains a particular service with
<code>has_service&lt;Service&gt;</code>.</p>
<p>4 Service objects may be explicitly added using
<code>make_service&lt;Service&gt;</code>. If the service is already
present, <code>make_service</code> throws an exception.</p>
<p>5 Once a service reference is obtained from an
<code>execution_context</code> by calling <code>use_service</code> or
<code>make_service</code>, that reference remains usable until a call to
<code>destroy()</code>.</p>
<p>6 The functions <code>use_service</code>, <code>make_service</code>,
<code>find_service</code>, and <code>has_service</code> do not introduce
data races as a result of concurrent calls from different threads.</p>
<h4 id="execution_context-constructors-and-destructor-ioawait.execctx.cons">12.4.1
<code>execution_context</code> constructors and destructor
[ioawait.execctx.cons]</h4>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>execution_context<span class="op">();</span></span></code></pre></div>
<p>1 <em>Effects:</em> Creates an object of class
<code>execution_context</code> which contains no services. [
<em>Note:</em> An implementation may preload services of internal
service types for its own use. <em>— end note</em> ]</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="op">~</span>execution_context<span class="op">();</span></span></code></pre></div>
<p>2 <em>Effects:</em> Destroys an object of class
<code>execution_context</code>. Performs <code>shutdown()</code>
followed by <code>destroy()</code>.</p>
<h4 id="execution_context-protected-operations-ioawait.execctx.protected">12.4.2
<code>execution_context</code> protected operations
[ioawait.execctx.protected]</h4>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> shutdown<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>1 <em>Effects:</em> For each service object <code>svc</code> in the
<code>execution_context</code> set, in reverse order of addition to the
set, performs <code>svc-&gt;shutdown()</code>. For each service in the
set, <code>svc-&gt;shutdown()</code> is called only once irrespective of
the number of calls to <code>shutdown</code> on the
<code>execution_context</code>.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> destroy<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>2 <em>Effects:</em> Destroys each service object in the
<code>execution_context</code> set, and removes it from the set, in
reverse order of addition to the set.</p>
<h4 id="execution_context-service-access-ioawait.execctx.services">12.4.3
<code>execution_context</code> service access
[ioawait.execctx.services]</h4>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Service<span class="op">&gt;</span> <span class="dt">bool</span> has_service<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>1 <em>Returns:</em> <code>true</code> if an object of type
<code>Service</code> is present in <code>*this</code>, otherwise
<code>false</code>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Service<span class="op">&gt;</span> Service<span class="op">*</span> find_service<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>2 <em>Returns:</em> A pointer to the service of type
<code>Service</code> if present in <code>*this</code>, otherwise
<code>nullptr</code>.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Service<span class="op">&gt;</span> Service<span class="op">&amp;</span> use_service<span class="op">();</span></span></code></pre></div>
<p>3 <em>Effects:</em> If an object of type <code>Service</code> does
not already exist in the <code>execution_context</code> set, creates an
object of type <code>Service</code>, initialized as
<code>Service(*this)</code>, and adds it to the set.</p>
<p>4 <em>Returns:</em> A reference to the corresponding service of
<code>*this</code>.</p>
<p>5 <em>Remarks:</em> The reference returned remains valid until a call
to <code>destroy()</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Service<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span> Service<span class="op">&amp;</span> make_service<span class="op">(</span>Args<span class="op">&amp;&amp;...</span> args<span class="op">);</span></span></code></pre></div>
<p>6 <em>Preconditions:</em> An object of type <code>Service</code> does
not already exist in the <code>execution_context</code> set.</p>
<p>7 <em>Effects:</em> Creates an object of type <code>Service</code>,
initialized as
<code>Service(*this, forward&lt;Args&gt;(args)...)</code>, and adds it
to the <code>execution_context</code> set.</p>
<p>8 <em>Returns:</em> A reference to the new service.</p>
<p>9 <em>Throws:</em> <code>service_already_exists</code> if a
corresponding service object of type <code>Service</code> is already
present in the set.</p>
<p>10 <em>Remarks:</em> The reference returned remains valid until a
call to <code>destroy()</code>.</p>
<h4 id="execution_context-frame-allocator-ioawait.execctx.alloc">12.4.4
<code>execution_context</code> frame allocator
[ioawait.execctx.alloc]</h4>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>pmr<span class="op">::</span>memory_resource<span class="op">*</span> get_frame_allocator<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>1 <em>Returns:</em> The memory resource set via
<code>set_frame_allocator</code>, or
<code>pmr::get_default_resource()</code> if none was set.</p>
<p>2 <em>Remarks:</em> This function provides the default allocator for
coroutine frames launched with executors from this context when no
allocator is specified at the launch site.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> set_frame_allocator<span class="op">(</span>pmr<span class="op">::</span>memory_resource<span class="op">*</span> mr<span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>3 <em>Effects:</em> Sets the memory resource to be returned by
subsequent calls to <code>get_frame_allocator()</code>.</p>
<p>4 <em>Remarks:</em> This function does not affect coroutine frames
that have already been allocated.</p>
<p>5 [ <em>Note:</em> The frame allocator is a quality of implementation
concern. A conforming implementation may ignore the allocator parameter
entirely, and programs should still behave correctly. The allocator
mechanism is provided to enable performance optimizations such as
thread-local recycling pools or bounded allocation strategies, but
correct program behavior must not depend on a specific allocation
strategy being used. <em>— end note</em> ]</p>
<h4 id="class-execution_contextservice-ioawait.execctx.service">12.4.5
Class <code>execution_context::service</code>
[ioawait.execctx.service]</h4>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> execution_context<span class="op">::</span>service <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">virtual</span> <span class="op">~</span>service<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>  service<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">virtual</span> <span class="dt">void</span> shutdown<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>1 A class is a service if it is publicly and unambiguously derived
from <code>execution_context::service</code>.</p>
<p>2 A service’s <code>shutdown</code> member function shall destroy all
copies of function objects that are held by the service.</p>
<h3 id="launch-functions-ioawait.launch">12.5 Launch functions
[ioawait.launch]</h3>
<p>1 Launch functions bootstrap execution context into a coroutine
chain. They are the bridge between non-coroutine code and the
<code>io_awaitable</code> protocol.</p>
<h4 id="function-template-run_async-ioawait.launch.async">12.5.1
Function template <code>run_async</code> [ioawait.launch.async]</h4>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>executor Ex<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  unspecified run_async<span class="op">(</span>Ex <span class="at">const</span><span class="op">&amp;</span> ex<span class="op">,</span> Args<span class="op">&amp;&amp;...</span> args<span class="op">);</span></span></code></pre></div>
<p>1 <em>Returns:</em> A callable object <code>f</code> such that the
expression <code>f(task)</code> is valid when <code>task</code>
satisfies <code>io_launchable_task</code>.</p>
<p>2 <em>Effects:</em> When <code>f(task)</code> is invoked:</p>
<ul>
<li>(2.1) Sets the thread-local frame allocator to the allocator
specified in <code>Args</code>, or to
<code>ex.context().get_frame_allocator()</code> if no allocator is
specified.</li>
<li>(2.2) Evaluates <code>task</code> (which allocates the coroutine
frame using the thread-local allocator).</li>
<li>(2.3) Calls
<code>task.handle().promise().set_executor(ex)</code>.</li>
<li>(2.4) If a <code>stop_token</code> is specified in
<code>Args</code>, calls
<code>task.handle().promise().set_stop_token(token)</code>.</li>
<li>(2.5) Sets up completion handling: if completion handlers are
specified in <code>Args</code>, arranges for them to be invoked when
<code>task</code> completes.</li>
<li>(2.6) Calls <code>task.release()</code> to transfer ownership.</li>
<li>(2.7) Resumes the coroutine via the executor.</li>
</ul>
<p>3 <em>Remarks:</em> <code>Args</code> may include:</p>
<ul>
<li>A <code>stop_token</code> to propagate cancellation signals.</li>
<li>An allocator satisfying the <em>Allocator</em> requirements, or a
<code>pmr::memory_resource*</code>, used to allocate all coroutine
frames in the chain.</li>
<li>A completion handler invoked with the task’s result value upon
successful completion.</li>
<li>An error handler invoked with <code>exception_ptr</code> if the task
completes with an exception.</li>
</ul>
<p>4 <em>Synchronization:</em> The call to
<code>run_async(ex, args...)(task)</code> synchronizes with the
invocation of the completion handler (if any) and with the resumption of
the task coroutine.</p>
<p>5 [ <em>Note:</em> The two-call syntax
<code>run_async(ex)(task())</code> is required because of coroutine
allocation timing. The outer expression <code>run_async(ex)</code> must
complete—returning the callable and establishing the thread-local
allocator—before <code>task()</code> is evaluated. This ordering is
guaranteed by [expr.call] in C++17 and later: “The postfix-expression is
sequenced before each expression in the expression-list.” <em>— end
note</em> ]</p>
<p>6 [ <em>Example:</em></p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Basic launch</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span>ioc<span class="op">.</span>get_executor<span class="op">())(</span>my_task<span class="op">());</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="co">// With stop token and allocator</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span>ex<span class="op">,</span> source<span class="op">.</span>get_token<span class="op">(),</span> my_allocator<span class="op">)(</span>my_task<span class="op">());</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="co">// With completion handlers</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>run_async<span class="op">(</span>ex<span class="op">,</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">[](</span><span class="dt">int</span> result<span class="op">)</span> <span class="op">{</span> <span class="co">/* handle success */</span> <span class="op">},</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">[](</span>exception_ptr ep<span class="op">)</span> <span class="op">{</span> <span class="co">/* handle error */</span> <span class="op">}</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a><span class="op">)(</span>compute_value<span class="op">());</span></span></code></pre></div>
<p><em>— end example</em> ]</p>
<h4 id="function-template-run_on-ioawait.launch.on">12.5.2 Function
template <code>run_on</code> [ioawait.launch.on]</h4>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>executor Ex<span class="op">,</span> io_launchable_task Task<span class="op">&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  unspecified run_on<span class="op">(</span>Ex <span class="at">const</span><span class="op">&amp;</span> ex<span class="op">,</span> Task task<span class="op">);</span></span></code></pre></div>
<p>1 <em>Returns:</em> An awaitable object <code>a</code>.</p>
<p>2 <em>Effects:</em> When <code>a</code> is awaited via
<code>co_await a</code>:</p>
<ul>
<li>(2.1) The child task <code>task</code> is bound to executor
<code>ex</code> via
<code>task.handle().promise().set_executor(ex)</code>.</li>
<li>(2.2) The caller’s stop token is propagated to
<code>task</code>.</li>
<li>(2.3) The child task executes on <code>ex</code>.</li>
<li>(2.4) Upon completion, the caller resumes on its original executor
(via the same-executor optimization in <code>complete()</code>).</li>
<li>(2.5) The result of <code>co_await a</code> is the result of
<code>task</code>.</li>
</ul>
<p>3 <em>Preconditions:</em> The expression appears in a coroutine whose
promise type satisfies <code>io_awaitable_task</code>.</p>
<p>4 <em>Remarks:</em> The executor <code>ex</code> is stored by value
in the awaitable’s frame, ensuring it remains valid for the operation’s
duration.</p>
<p>5 <em>Synchronization:</em> The suspension of the caller synchronizes
with the resumption of <code>task</code>. The completion of
<code>task</code> synchronizes with the resumption of the caller.</p>
<p>6 [ <em>Example:</em></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> parent<span class="op">()</span> <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Child runs on worker_ex, but completion returns here</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="cf">co_await</span> run_on<span class="op">(</span>worker_ex<span class="op">,</span> compute_on_worker<span class="op">());</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">co_return</span> result <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>— end example</em> ]</p>
<h3 id="namespace-this_coro-ioawait.thiscoro">12.6 Namespace
<code>this_coro</code> [ioawait.thiscoro]</h3>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> <span class="bu">std::</span>this_coro <span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> executor_tag <span class="op">{};</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> stop_token_tag <span class="op">{};</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="kw">constexpr</span> executor_tag executor<span class="op">{};</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="kw">constexpr</span> stop_token_tag stop_token<span class="op">{};</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>1 The <code>this_coro</code> namespace provides tag objects that can
be awaited within a coroutine to retrieve execution context information
without suspension.</p>
<h4 id="this_coroexecutor-ioawait.thiscoro.executor">12.6.1
<code>this_coro::executor</code> [ioawait.thiscoro.executor]</h4>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> executor_tag executor<span class="op">;</span></span></code></pre></div>
<p>1 When awaited via <code>co_await this_coro::executor</code> inside a
coroutine whose promise type satisfies
<code>io_awaitable_task</code>:</p>
<p>2 <em>Returns:</em> The <code>executor_ref</code> bound to the
current coroutine, as would be returned by
<code>promise.executor()</code>.</p>
<p>3 <em>Remarks:</em> This operation never suspends. The promise’s
<code>await_transform</code> intercepts the <code>executor_tag</code>
type and returns an immediate awaiter where <code>await_ready()</code>
returns <code>true</code>.</p>
<p>4 <em>Preconditions:</em> <code>set_executor</code> has been called
on the promise.</p>
<h4 id="this_corostop_token-ioawait.thiscoro.token">12.6.2
<code>this_coro::stop_token</code> [ioawait.thiscoro.token]</h4>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> stop_token_tag stop_token<span class="op">;</span></span></code></pre></div>
<p>1 When awaited via <code>co_await this_coro::stop_token</code> inside
a coroutine whose promise type satisfies
<code>io_awaitable_task</code>:</p>
<p>2 <em>Returns:</em> The <code>std::stop_token</code> propagated to
the current coroutine, as would be returned by
<code>promise.stop_token()</code>.</p>
<p>3 <em>Remarks:</em> This operation never suspends. The promise’s
<code>await_transform</code> intercepts the <code>stop_token_tag</code>
type and returns an immediate awaiter where <code>await_ready()</code>
returns <code>true</code>.</p>
<p>4 <em>Preconditions:</em> <code>set_stop_token</code> has been called
on the promise.</p>
<p>5 [ <em>Example:</em></p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>task<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> cancellable_work<span class="op">()</span> <span class="op">{</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    executor_ref ex <span class="op">=</span> <span class="cf">co_await</span> this_coro<span class="op">::</span>executor<span class="op">;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    stop_token token <span class="op">=</span> <span class="cf">co_await</span> this_coro<span class="op">::</span>stop_token<span class="op">;</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">1000</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>stop_requested<span class="op">())</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">co_return</span><span class="op">;</span>  <span class="co">// Exit gracefully</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">co_await</span> process_chunk<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>— end example</em> ]</p>
<h3 id="threading-and-synchronization-ioawait.sync">12.7 Threading and
synchronization [ioawait.sync]</h3>
<p>1 Unless otherwise specified, it is safe to call <code>const</code>
member functions of the classes defined in this clause concurrently from
multiple threads.</p>
<p>2 The execution context, executor, and coroutine handle types do not
introduce data races when used according to their documented
requirements.</p>
<p>3 Synchronization between asynchronous operations follows the
“synchronizes with” relationship defined in [intro.multithread]:</p>
<ul>
<li>(3.1) A call to <code>executor::dispatch</code> or
<code>executor::post</code> synchronizes with the resumption of the
submitted coroutine handle.</li>
<li>(3.2) The suspension of a coroutine at a <code>co_await</code>
expression synchronizes with the resumption of that coroutine.</li>
<li>(3.3) The completion of a child coroutine (at final suspension)
synchronizes with the resumption of the parent coroutine.</li>
</ul>
<p>4 [ <em>Note:</em> These synchronization guarantees ensure that
modifications made by one coroutine before suspension are visible to the
code that resumes it. <em>— end note</em> ]</p>
<hr />
<h2 id="acknowledgements">Acknowledgements</h2>
<p>This paper builds on the foundational work of many contributors to
C++ asynchronous programming:</p>
<p><strong>Chris Kohlhoff</strong> for Boost.Asio, which has served the
C++ community for over two decades and established many of the patterns
we build upon—and some we consciously depart from. The executor model in
this paper honors his pioneering work.</p>
<p><strong>Lewis Baker</strong> for his work on C++ coroutines, the
Asymmetric Transfer blog series, and his contributions to <a href="https://wg21.link/p2300">P2300</a> and <a href="https://wg21.link/p3826">P3826</a>. His explanations of symmetric
transfer and coroutine optimization techniques directly informed our
design.</p>
<p><strong>Dietmar Kühl</strong> for <a href="https://wg21.link/p2762">P2762</a> and <a href="https://wg21.link/p3552">P3552</a>, which explore sender/receiver
networking and coroutine task types. His clear articulation of design
tradeoffs—including the late-binding problem and cancellation overhead
concerns—helped crystallize our understanding of where the sender model
introduces friction for networking.</p>
<p>The analysis in this paper is not a critique of these authors’
contributions, but rather an exploration of whether networking’s
specific requirements are best served by adapting to general-purpose
abstractions or by purpose-built designs.</p>
<hr />
<h2 id="references">References</h2>
<ol type="1">
<li><a href="https://wg21.link/n4242">N4242</a> — Executors and
Asynchronous Operations, Revision 1 (2014)</li>
<li><a href="https://wg21.link/n4482">N4482</a> — Some notes on
executors and the Networking Library Proposal (2015)</li>
<li><a href="https://wg21.link/p2300">P2300R10</a> — std::execution
(Michał Dominiak, Georgy Evtushenko, Lewis Baker, Lucian Radu
Teodorescu, Lee Howes, Kirk Shoop, Eric Niebler)</li>
<li><a href="https://wg21.link/p2762">P2762R2</a> — Sender/Receiver
Interface for Networking (Dietmar Kühl)</li>
<li><a href="https://wg21.link/p3552">P3552R3</a> — Add a Coroutine Task
Type (Dietmar Kühl, Maikel Nadolski)</li>
<li><a href="https://wg21.link/p3826">P3826R2</a> — Fix or Remove Sender
Algorithm Customization (Lewis Baker, Eric Niebler)</li>
<li><a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a>
— Asynchronous I/O library (Chris Kohlhoff)</li>
<li><a href="http://www.kegel.com/c10k.html">The C10K problem</a> —
Scalable network programming (Dan Kegel)</li>
<li><a href="https://github.com/cppalliance/capy">Capy</a> — IoAwaitable
protocol implementation (Vinnie Falco, Steve Gerbino)</li>
<li><a href="https://github.com/cppalliance/corosio">Corosio</a> —
Coroutine-first networking library (Vinnie Falco, Steve Gerbino)</li>
</ol>
</body>
</html>

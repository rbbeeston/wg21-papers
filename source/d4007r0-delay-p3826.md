::: {.document-info}
| Document  | D4007R0                                                                      |
|-----------|------------------------------------------------------------------------------|
| Date:     | 2026-02-02                                                                   |
| Reply-to: | Vinnie Falco \<vinnie.falco@gmail.com\><br>Mungo Gill \<mungo.gill@me.com\> |
| Audience: | SG1, LEWG                                                                    |
:::

# `std::execution` Needs More Time

## Revision History

- R0 - Initial revision.

---

## Abstract

`std::execution` brings valuable ideas to C++ - structured
concurrency, composable task graphs, and a clean separation of
work description from execution policy. However, a fundamental
timing gap prevents coroutine-based I/O from using stateful
allocators: `operator new` runs before the receiver exists, so
the allocator arrives too late. This gap is architectural, not
a missing feature - unlike the contracts MVP, it cannot be
extended stably without destabilising the API. We recommend
deferring `std::execution` to C++29, or alternatively
publishing it as a Technical Specification, so that the
allocator story can be resolved before the ABI is frozen.

---

## 1. Introduction

[P2300R10](https://wg21.link/p2300r10) ("std::execution")
represents years of careful work and genuine progress in
structured asynchronous programming for C++:

- **Structured concurrency** with well-defined lifetime
  guarantees for asynchronous operations
- **Composable sender/receiver pipelines** that separate work
  description from execution policy
- **Schedulers and execution contexts** that give callers
  control over where work runs
- **`run_loop`** and foundational primitives that enable
  deterministic testing of async code
- **A formal model** for reasoning about asynchronous
  completion signatures

These are real achievements, and the community of users and
implementers who have invested in sender/receiver architectures -
NVIDIA CCCL, stdexec, libunifex, Folly - has demonstrated
substantial value in CPU-bound parallelism and GPU dispatch.

The concern this paper raises is narrower than a general
objection: `std::execution` works well for its primary use
cases. The gap appears when the framework is extended to serve
coroutine-based I/O - a use case the committee has explicitly
placed in scope (see Section 6.4). For that use case, the
allocator must be available when the coroutine frame is
allocated, but the sender/receiver model provides it only after
the frame already exists.

This is not a missing feature that can be added later. Unlike
the contracts MVP - which was designed as a minimal but
extendable foundation - the allocator timing gap is
architectural: `operator new` runs before `connect()`, and no
library-level change can alter that sequencing without
destabilising the API. Discovering this before standardisation
is fortunate, not a failure. The feature's size and complexity
make thorough review genuinely difficult, and it is not
surprising that a gap visible only in the I/O use case was not
identified earlier. There is still time to address it.

---

## 2. The I/O Use Case

`std::execution` aspires to be a general-purpose asynchronous
framework, including for networked I/O. Here is what that use
case requires.

A typical networking application launches coroutines that
perform I/O:

```cpp
// User's coroutine - handles one client connection
task<void> handle_client(tcp_socket socket)
{
    char buf[1024];
    auto [ec, n] = co_await socket.async_read(buf);
    if (n > 0)
        process(buf, n);  // data may accompany eof
}

// Application launches the coroutine
int main()
{
    io_context ctx;
    tcp_socket sock = accept_connection(ctx);
    auto alloc = ctx.get_frame_allocator();

    run_async(ctx.get_executor(), alloc)(
        handle_client(std::move(sock))   // Frame allocated HERE
    );

    ctx.run();
}
```

The critical timing:

```cpp
run_async(executor, alloc)(handle_client(sock))
                                 |
                                 +-> promise_type::operator new runs HERE
                                     Allocator must already be known
```

When `handle_client(sock)` is evaluated, the compiler calls
`promise_type::operator new` to allocate the coroutine frame.
The allocator must be available at this moment - before the
coroutine body executes, before any `co_await`, before any
connection to a receiver.

---

## 3. The Problem

### 3.1 The Cost of Uncontrolled Allocation

High-performance I/O servers cannot tolerate uncontrolled heap
allocation. Realistic server code calls nested coroutines for
parsing, processing, and serialisation - each `task<T>` call
allocates a frame:

```cpp
task<void> handle_connection(tcp_socket socket)
{
    char buf[1024];
    while (socket.is_open()) {
        auto n = co_await socket.async_read(buf);  // I/O awaitable: no frame
        co_await process_request(socket, buf, n);   // task<void>: frame allocated
    }
}
// handle_connection itself: 1 frame per connection
// process_request (and coroutines it calls): frame(s) per request
// 10,000 connections x 1,000 requests/sec = 10 million+ frame allocations/sec
// Global heap contention becomes the bottleneck
```

The solution is **stateful allocators**:

- recycling allocators that cache recently-freed frames
- arena allocators tied to connection scope
- pool allocators optimised for common frame sizes
- `pmr::memory_resource` implementations that customise
  the upstream allocation strategy

Modern general-purpose allocators (jemalloc, mimalloc,
tcmalloc) achieve impressive throughput via per-thread
caching, but they solve a different problem. They reduce
contention on the global heap; they do not address the
allocation patterns that I/O servers produce. Coroutine
frames are short-lived, uniformly sized, and frequently
allocated on one thread but freed on another - a
cross-thread pattern that defeats per-thread caches.

More fundamentally, a general-purpose allocator has no
notion of application-level context. Different coroutine
chains may require different policies. A multi-tenant server
might enforce per-tenant memory limits, with each tenant's
connections using an allocator bounded to that tenant's
quota. A connection-scoped arena can reclaim all frames in
one operation when the connection closes. These policies
require the stateful allocators listed above - and that
state must be accessible when `operator new` executes.

### 3.2 HALO Cannot Help

HALO (Heap Allocation eLision Optimisation) allows compilers to
elide coroutine frame allocation when the frame's lifetime is
provably bounded by its caller. For I/O coroutines launched onto
an execution context, the frame outlives its caller - the caller
returns immediately after launching the operation, and the frame
persists until the OS signals completion. The compiler cannot
prove bounded lifetime when the lifetime depends on an external
event. HALO cannot apply in this common case, and allocation is
mandatory. See Appendix A.1 for the full analysis and code
example.

### 3.3 `operator new` Is the Only Interception Point

The standard provides exactly one mechanism to intercept
coroutine frame allocation:

```cpp
struct promise_type
{
    static void* operator new(std::size_t size)
    {
        // This is the ONLY place to intercept allocation
        // The allocator must be known RIGHT NOW

        std::pmr::memory_resource* mr = /* ??? */;
        return mr->allocate(size, alignof(std::max_align_t));
    }
};
```

The allocator - with its state - must be discoverable at this
exact moment. No mechanism that provides the allocator later
can help. The frame is already allocated by the time any later
mechanism executes.

### 3.4 The `allocator_arg` Workaround

[P3552R3](https://wg21.link/p3552r3) ("Add a Coroutine Task
Type") provides a mechanism for passing an allocator to a single
coroutine via `std::allocator_arg_t`. This solves the initial
allocation: the caller passes the allocator explicitly at the
call site. However, propagation through call chains is unsolved.
Every coroutine in the chain must accept variadic template
arguments, query the allocator from its environment, and forward
it to every child coroutine call. The allocator becomes viral -
function signatures no longer reflect algorithmic intent, and
forgetting to forward silently breaks the chain. See Appendix
A.2 for the full propagation example.

### 3.5 The Receiver Arrives Too Late

The sender/receiver model in `std::execution` flows context
backward from receiver to sender. This creates a timing gap for
coroutine frame allocation:

```cpp
task<int> my_coro();                      // Coroutine returning a sender

auto sndr = my_coro();                    // Step 1: operator new runs HERE
                                          //         Frame already allocated

auto op = connect(std::move(sndr), rcvr); // Step 2: Receiver connected HERE
                                          //         get_allocator(get_env(rcvr))
                                          //         available NOW - too late

start(op);                                // Step 3: Operation starts
```

[P2300R4](https://wg21.link/p2300r4) ("std::execution,"
2022-01-18) acknowledges this timing:

> "In the sender/receiver model... contextual information is
> associated with the receiver and is queried by the sender
> and/or operation state **after** the sender and the receiver
> are `connect`-ed."

[P3826R3](https://wg21.link/p3826r3) (2026-01-05) confirms the
consequence:

> "The receiver is not known during early customization.
> Therefore, early customization is irreparably broken."

The allocator is part of this contextual information. It becomes
available only after `connect()` - but the coroutine frame was
allocated in Step 1, before `connect()` was called.

**For coroutine-based I/O, the allocator arrives too late.**
This is not a flaw in the sender/receiver formalism itself - it
is a gap that emerges when that formalism meets the concrete
requirements of coroutine frame allocation.

---

## 4. Why It Can't Be Fixed Later

### 4.1 The Gap Is Structural

`operator new` runs before `connect()`. No library-level change
can alter this sequencing - it is determined by the C++ language
specification for coroutines interacting with the sender/receiver
protocol. The contracts MVP was explicitly designed as a minimal
but extendable foundation: the committee can add features in
future standards without breaking the C++26 API. The allocator
timing gap is different. There is no post-hoc extension point
between "coroutine frame is allocated" and "receiver is
connected." The only way to close the gap is to change the
sequencing - which means changing the API.

### 4.2 `await_transform` Cannot Help

A natural question is whether `promise_type::await_transform`
could inject the allocator into child coroutine calls,
eliminating explicit `allocator_arg` passing. It cannot. In
`co_await child_coro(args...)`, the function call
`child_coro(args...)` is evaluated first - the child's
`operator new` fires and the frame is allocated before
`co_await` processing begins. By the time `await_transform`
sees the returned `task<T>`, the child's frame has already been
allocated without the parent's allocator. See Appendix B.2 for
the full evaluation-order analysis.

### 4.3 The Two-Tier Design Cannot Propagate Allocators

[P3552R3](https://wg21.link/p3552r3) establishes a two-tier
model: the allocator is a creation-time concern passed at the
call site, while the scheduler and stop token are
connection-time concerns from the receiver. The promise's
`get_env()` exposes the stored allocator to child operations
via `get_allocator`. This solves allocating the *initial*
coroutine frame - a real contribution. But *propagating* the
allocator through a chain of nested coroutine calls is the
harder, unsolved problem.

With standard containers, the allocator type is part of the
type signature (`vector<T, Alloc>`), and `uses_allocator`
construction gives generic code a standard way to propagate
the allocator through nested construction. With coroutines,
the allocator is consumed inside `operator new` - which runs
before the receiver exists - and the coroutine's return type
(`task<T>`) does not carry the allocator type. There is no
`uses_allocator` equivalent for coroutine frame allocation.

The propagation burden is compounded by the calling convention:
every call site must pass both `std::allocator_arg` and the
allocator object as leading arguments. In practice, the majority
of the typing at each call site is dedicated to allocator
plumbing rather than application logic - creating strong
pressure to simply omit the allocator, defeating the purpose.

### 4.4 P3826R3's Solutions Target a Different Problem

[P3826R3](https://wg21.link/p3826r3) ("Fix Sender Algorithm
Customization," 2026-01-05) proposes important fixes for sender
algorithm customisation - a real problem prompted by NB comment
[US 207](https://github.com/cplusplus/nbballot/issues/903) and
resolved over three revisions. However, its five proposed
solutions all target algorithm dispatch: which implementation
of `then`, `let_value`, or `bulk` should run. Four of the five
do not change when the allocator becomes available. The fifth -
remove all `std::execution` - resolves the gap by deferral. See
Appendix B.1 for the full analysis of each solution.

### 4.5 ABI Lock-In Makes This Permanent

Once standardised, the relationship between `operator new` and
`connect()` becomes part of the ABI. Implementations will ship
headers and binaries encoding this sequencing. A post-C++26 fix
that changes the order in which allocation and connection occur
would break binary compatibility with code compiled against the
C++26 specification. The window for fixing this is now.

---

## 5. The Committee's Own Record

The committee's own proceedings confirm that the allocator story
is unresolved and the design is still actively evolving.

### 5.1 The Allocator Poll

[P3796R1](https://wg21.link/p3796r1) (Dietmar Kuhl, "Coroutine
Task Issues") was reviewed by LEWG in a September 2025 telecon.
The allocator question was polled directly:

> "We would like to use the allocator provided by the receivers
> env instead of the one from the coroutine frame"
>
> | SF | F | N | A | SA |
> |----|---|---|---|----|
> |  0 | 0 | 5 | 0 |  0 |
>
> Attendance: 14. Outcome: strictly neutral.

The entire room abstained to neutral. The author was directed to
explore preferred solutions with code examples.

Two US national body comments confirm the same concern. US 255
(LWG4335) states: "the used allocator type needs to be known when
the coroutine is created. At that time the receiver isn't known,
yet." LEWG polled at Kona (2025-11-06) and approved the
direction (SF:4 / F:7 / N:0 / A:1 / SA:0, attendance 17), but
wording remains outstanding. The sole A vote - from the task
paper's author - noted that using the receiver's allocator "goes
against the general behaviour of allocators." US 253 (LWG4333)
requests arbitrary allocator support for the coroutine frame;
wording is also still required.

LWG 4356 (`connect()` should use
`get_allocator(get_env(rcvr))`) confirms the gap has been filed
as a specification defect - not merely an external complaint, but
a committee-level acknowledgement of the timing problem.

### 5.2 Post-Approval Changes

The volume of papers written to fix, rework, or complete
`std::execution` after its approval for C++26 is extraordinary.
Mature designs do not require this level of post-approval
remediation.

| Period                          | Removals | Reworks | Wording | Missing Functionality |  LWG  | Total  |
|---------------------------------|:--------:|:-------:|:-------:|:---------------------:|:-----:|:------:|
| Pre-Wroclaw (Mar-Oct 2024)      |    1     |    5    |    -    |           1           |   -   |  **7** |
| Pre-Hagenberg (Nov 2024-Feb 25) |    1     |    -    |    2    |           2           |   3   |  **8** |
| Pre-Sofia (Mar-Jun 2025)        |    -     |    2    |    -    |           7           |   1   | **10** |
| Pre-Kona (Jul-Nov 2025)         |    -     |    3    |    3    |           1           |   7   | **14** |
| Pre-London (Dec 2025-Feb 2026)  |    -     |    1    |    1    |           -           |   -   |  **2** |
| **Total**                       |  **2**   | **11**  |  **6**  |        **11**         |**11** | **41** |

See Appendix D for the complete listing with dates, authors, and
current status.

Key observations:

- **The churn is accelerating, not slowing.** The pre-Kona
  period produced 14 items - the highest volume - including
  Priority 1 safety defects. Two more papers appeared in the
  pre-London mailing with the London meeting still weeks away.
- **The severity has not decreased.** The pre-Kona period
  includes Priority 1 LWG defects: a dangling-reference
  vulnerability in `transform_sender` (LWG 4368) and an
  unconstrained alias in `connect_result_t` (LWG 4206). Two
  outstanding NB comments on allocator support remain without
  wording.
- **Design reworks span the entire timeline.** From P2855R1
  (replacing `tag_invoke`, March 2024) through P3927R0 (fixing
  `task_scheduler` bulk execution, January 2026) - 11 rework
  papers over 22 months.

In total: **30 papers, 11 LWG defects, and 2 NB comments - 43
items modifying a single feature after its approval.**

### 5.3 The C++23 Precedent

This is not the first time maturity concerns have led to
deferral. P2300 failed to achieve consensus for C++23:

> LEWG 2022-01-12: "Produce a P2300R4, modified as described
> below, and then send the revised paper to LWG for C++23 with
> priority 1"
>
> SF:15 / F:9 / N:1 / A:3 / SA:6 (Attendance: 39)

Recorded SA reasons included "maturity/readiness" and "Feels
like ranges all over again. Needs maturity." The same pattern of
ongoing design changes - algorithm reworks, allocator timing
unresolved, multiple LWG issues opened during review - is
present again.

---

## 6. A Path Forward

### 6.1 What Deferral Means

Deferring `std::execution` from C++26 does not discard the work
done by the P2300 authors and implementers. Production-quality
implementations already exist and are in active use. Deferral
means the committee does not freeze the ABI until the remaining
architectural gaps - allocator timing, allocator propagation,
and the interaction with coroutine task types - are resolved.

### 6.2 Two Concrete Alternatives

We see two equally acceptable paths forward. Either avoids
ABI lock-in while the allocator story is resolved.

**Defer to C++29.** The committee's own forwarding poll for
the task type was unanimous for C++29 (SF:5 / F:7 / N:0 /
A:0 / SA:0); the C++26 recommendation achieved only weak
consensus with an "if possible" qualifier. Deferral to
C++29 gives the authors time to resolve the allocator timing
gap, the allocator propagation problem, and the outstanding
LWG defects. Users are not blocked in the meantime -
production-quality implementations (stdexec, NVIDIA CCCL,
libunifex, Folly) are available today and do not require
an IS specification to adopt.

**Publish as a Technical Specification.** A TS would:

- Preserve all the work done by the P2300 authors and
  implementers
- Allow implementations and users to gain real-world
  experience, especially with I/O workloads
- Give the committee freedom to fix the allocator timing gap
  before the ABI is frozen
- Follow established precedent (the Networking TS itself took
  this path)
- Avoid locking C++ into an API that cannot serve
  coroutine-based I/O without workarounds

Either path acknowledges the significant investment already
made while preserving the freedom to fix what remains. The
committee can move `std::execution` into the IS once the I/O
story is resolved.

### 6.3 Who Bears the Cost

The urgency question deserves an honest answer: who is harmed
by deferral, and who is harmed by premature standardisation?

Organisations building on `std::execution` today are not blocked
by the absence of an IS specification - they build against
concrete library implementations. Unlike language features,
non-standard library implementations are straightforward to
adopt; organisations can use Boost, stdexec, or other
implementations without compiler extensions. Whether the
committee defers to C++29 or publishes a TS, current users
are unaffected.

The networking use case - which arguably represents the largest
constituency for asynchronous C++ - is the community most
affected by shipping `std::execution` with an incomplete
allocator story. SG4 mandated that networking be built
exclusively on sender/receiver (see Section 6.4). If the
framework ships without a workable allocator propagation model
for coroutine-based I/O, the networking community faces a choice
between inefficient workarounds and non-standard alternatives.

This framing is not an accusation that the committee is
neglecting networking. It is an observation that the current
timeline favours constituencies that do not need allocator
propagation (GPU dispatch, CPU-bound parallelism) over the
constituency that does (I/O-bound networking). Deferral
preserves optionality for everyone; premature standardisation
imposes a concrete cost on the use case with the broadest
demonstrated demand.

### 6.4 I/O Is in Scope

A likely response is that `std::execution` is for structured
concurrency and parallelism, and networking is a separate paper
track. The committee's own record contradicts this.

SG4 polled at Kona (November 2023) on
[P2762R2](https://wg21.link/p2762r2) ("Sender/Receiver
Interface For Networking"):

> "Networking should support only a sender/receiver model for
> asynchronous operations; the Networking TS's executor model
> should be removed"
>
> SF:5 / F:5 / N:1 / A:0 / SA:1 - Consensus.

Networking must be built on `std::execution`'s sender/receiver
model. The task type
([P3552R3](https://wg21.link/p3552r3)) is the primary I/O
usability layer - it exists so that users can write
`co_await socket.async_read(buf)`. If the coroutine integration
cannot access the allocator, the I/O use case is effectively
unserved. See Appendix C.1-C.3 for the full committee record on
this question.

---

## 7. Conclusion

`std::execution` represents important progress in structured
asynchronous programming for C++. Its contributions -
structured concurrency, composable pipelines, and a formal model
for async completion - are valuable and worth building on.

However, for coroutine-based asynchronous I/O, a fundamental
timing gap remains:

1. **Allocation is mandatory** - HALO cannot optimise away
   frames that outlive their callers
2. **Stateful allocators are required** - 10 million+
   allocations/sec demands recycling, pooling, or arena
   strategies
3. **`operator new` is the only interception point** - the
   allocator must be known when the frame is allocated
4. **`std::execution` provides the allocator too late** -
   receiver environment is available only after `connect()`
5. **The gap cannot be fixed later** - `operator new` runs
   before `connect()`, and no library change can alter that
   sequencing without destabilising the API

[P2300R4](https://wg21.link/p2300r4) established the
sender/receiver context model in January 2022. Four years
later, the design continues to evolve:
[P3826R3](https://wg21.link/p3826r3) proposes significant
architectural changes to `transform_sender`, removes early
customization entirely, and restructures the relationship
between `continues_on` and `schedule_from`. This level of
active change is healthy for a maturing design, but it signals
that the work is not yet finished.

If `std::execution` ships with C++26 but cannot serve
coroutine-based I/O without workarounds, the result is
effectively two parallel frameworks - the standard one (which
works for CPU-bound parallelism and GPU dispatch) and
non-standard alternatives (which work for I/O). Standardising
one while leaving the other to ad-hoc solutions, when a unified
framework is achievable with more time, is an unforced error.

The goal is not to block `std::execution`. It is to ensure
that when it ships, it serves the full spectrum of its intended
use cases - so that the C++ community gets one async framework,
not two. Deferring gives the authors time to resolve the
allocator timing gap, stabilise the architecture, and deliver
an API with the quality and stability the C++ community expects
from the standard library.

**We recommend deferring `std::execution` to C++29 or,
alternatively, publishing it as a Technical Specification.
Either path gives the committee time to resolve the allocator
story before the ABI is frozen.**

---

## Appendix A - Code Examples

### A.1 Why HALO Cannot Help

HALO (Heap Allocation eLision Optimisation) allows compilers to
elide coroutine frame allocation when the frame's lifetime is
provably bounded by its caller. When an I/O coroutine is
launched onto an execution context, the frame must outlive the
launching function:

```cpp
task<size_t> read_data(socket& s, buffer& buf)
{
    co_return co_await s.async_read(buf);  // Suspends for network I/O
}

void start_read(executor ex)
{
    start_detached(ex, read_data(sock, buf)); // Frame must outlive this function
}                                             // Caller returns immediately
```

`start_detached` transfers the frame's lifetime to the execution
context. The caller returns, and the frame persists until the OS
signals I/O completion - which may take microseconds or seconds.
The compiler cannot prove bounded lifetime, so HALO cannot apply
and allocation is mandatory.

A note of precision: HALO cannot apply when the coroutine frame
outlives its caller, which is the common case for I/O coroutines
launched onto an execution context. In the nested case - where
coroutine A `co_await`s coroutine B - A's frame remains alive
while B executes, and B's frame lifetime is bounded by A's. In
principle, a sufficiently advanced compiler could elide B's
allocation into A's frame. No current compiler does this for
`task<T>` coroutines, and the optimisation becomes infeasible
once any frame in the chain is transferred to an execution
context. HALO cannot help when frames outlive their callers -
which is the case that matters for I/O.

### A.2 The `allocator_arg` Propagation Chain

[P3552R3](https://wg21.link/p3552r3) provides a mechanism for
passing an allocator to a single coroutine via
`std::allocator_arg_t`. Here is what propagation through a call
chain looks like in practice:

```cpp
namespace ex = std::execution;

template<class... Args>
task<void> level_three(Args&&...) { co_return; }

template<class... Args>
task<void> level_two(int x, Args&&...) {
    auto alloc = co_await ex::read_env(ex::get_allocator);    // Query
    co_await level_three(std::allocator_arg, alloc);           // Forward
}

template<class... Args>
task<int> level_one(int v, Args&&...) {
    auto alloc = co_await ex::read_env(ex::get_allocator);    // Query
    co_await level_two(42, std::allocator_arg, alloc);         // Forward
    co_return v;
}
```

Every coroutine requires variadic template arguments. Every
coroutine must query and forward the allocator. Function
signatures no longer reflect algorithmic intent. Forgetting to
forward silently breaks the chain. The allocator becomes viral -
polluting interfaces throughout the codebase.

### A.3 The `connect`/`start`/`operator new` Sequence

The full timing sequence showing the gap between frame
allocation and receiver connection:

```cpp
auto sndr = my_coro();                    // Step 1: operator new runs HERE
                                          //         Frame already allocated

auto op = connect(std::move(sndr), rcvr); // Step 2: Receiver connected HERE
                                          //         get_allocator(get_env(rcvr))
                                          //         available NOW - too late

start(op);                                // Step 3: Operation starts
```

[P2300R4](https://wg21.link/p2300r4) (2022-01-18) acknowledges
this timing:

> "In the sender/receiver model... contextual information is
> associated with the receiver and is queried by the sender
> and/or operation state **after** the sender and the receiver
> are `connect`-ed."

[P3826R3](https://wg21.link/p3826r3) (2026-01-05) confirms the
consequence for customisation:

> "The receiver is not known during early customization.
> Therefore, early customization is irreparably broken."

Note: the P3826R3 quote refers specifically to algorithm
dispatch customisation, not to allocator timing. But the
underlying cause is the same: the receiver - and its environment
including the allocator - is not available until `connect()`.

### A.4 Sender/Receiver vs Coroutine - Side by Side

The same `handle_connection` logic in both models illustrates
where the gap opens.

**Pure sender/receiver (no coroutines):**

```cpp
auto handle_connection(tcp_socket socket)
{
    return just(std::move(socket))
      | let_value([](tcp_socket& s) {
            return async_read(s)
              | let_value([&](auto data) {
                    return process(s, data);
                });
        });
}

// Usage:
auto op = connect(handle_connection(sock), rcvr);
//                                         ^^^^
// The receiver's allocator is available here.
// connect() can allocate the entire operation state
// tree using get_allocator(get_env(rcvr)).
start(op);
```

No allocation happens until `connect(sender, receiver)`. The
receiver's environment - including the allocator - is available
for the entire operation state tree. There is no timing gap.

**Coroutine model:**

```cpp
task<void> handle_connection(tcp_socket socket)
{
    // operator new has ALREADY run by this point.
    // The frame is allocated. The receiver does not exist yet.
    char buf[1024];
    auto n = co_await socket.async_read(buf);
    co_await process_request(socket, buf, n);
}
```

The coroutine frame is allocated during the function call -
before any receiver exists. This is the precise moment the gap
opens. The sender/receiver model's allocator story is
architecturally sound for non-coroutine use. The gap is
introduced specifically by the coroutine integration, and
`task<T>` - the usability layer that makes sender/receiver
practical for I/O - is where the timing mismatch lives.

---

## Appendix B - Counterarguments Examined

### B.1 P3826R3 and Algorithm Dispatch

[P3826R3](https://wg21.link/p3826r3) proposes important fixes
for sender algorithm customisation, prompted by NB comment
[US 207](https://github.com/cplusplus/nbballot/issues/903). The
resolution went through three revisions before acceptance in
January 2026 - evidence of ongoing design evolution, but not
itself an indictment.

P3826 offers five solutions. All target algorithm dispatch -
which implementation of `then`, `let_value`, or `bulk` should
run. None address the allocator timing gap:

**Solution 4.1: Remove all `std::execution`.** This would
resolve the timing gap by deferral.

**Solution 4.2: Remove customisable sender algorithms.** This
removes `then`, `let_value`, `bulk`, etc. It does not change
when the allocator becomes available.

**Solution 4.3: Remove sender algorithm customisation.** This
removes the ability to customise algorithms. It does not change
when the allocator becomes available.

**Solution 4.4: Ship as-is, fix via DR.** This defers the fix.
It does not change when the allocator becomes available.

**Solution 4.5: Fix algorithm customisation now.** P3826's
recommended fix restructures `transform_sender` to take the
receiver's environment, changing information flow at `connect()`
time:

```cpp
get_completion_domain<set_value_t>(get_env(sndr), get_env(rcvr))
```

This tells senders where they will start, enabling correct
algorithm dispatch. It does not change when the allocator
becomes available - the receiver's environment is still only
queryable after `connect()`.

The Kona discussion also revealed that removing sender algorithm
customisation could preclude shipping the task type entirely,
since the task type's utility depends on the ability to
customise algorithms. The allocator timing issue, the algorithm
customisation issue, and the task type are architecturally
intertwined.

### B.2 Why `await_transform` Cannot Close the Gap

A reader familiar with C++ coroutine machinery may ask whether
`promise_type::await_transform` could inject the allocator into
child coroutine calls, eliminating explicit `allocator_arg`
passing.

The issue is evaluation order. In the expression:

```cpp
co_await child_coro(args...)
```

The function call `child_coro(args...)` is evaluated *first*.
The child's `operator new` fires, the coroutine frame is
allocated, the promise is constructed, and `get_return_object()`
runs - all during the function call expression. Only then does
`co_await` processing begin, at which point `await_transform`
sees the returned `task<T>`.

By the time `await_transform` executes, the child's frame has
already been allocated without the parent's allocator. There is
no customisation point in the C++ coroutine specification that
allows a caller to inject context into a callee's allocation.
`operator new`, `get_return_object`, and `initial_suspend` all
execute during the function call expression, before `co_await`
processing begins.

`await_transform` *can* inject context into a child's
*execution* phase - this is how P3552's `task` propagates the
scheduler and stop token via the receiver environment at
`connect()`/`start()` time. But allocation and execution are
different phases: allocation happens at call time, execution
happens at start time. The sender/receiver model's backward-flow
context is designed for the execution phase. It has no mechanism
to influence the allocation phase, because allocation precedes
the existence of the receiver.

### B.3 The Two-Tier Design and Allocator Propagation

[P3552R3](https://wg21.link/p3552r3) establishes a two-tier
model:

- **Creation-time concerns:** The allocator is passed at the
  call site via `std::allocator_arg_t`. The promise stores it
  and exposes it through `get_env()`.
- **Connection-time concerns:** The scheduler and stop token
  come from the receiver's environment, available after
  `connect()`.

This is a thoughtful design that correctly separates two
categories of concern. It solves allocating the *initial*
coroutine frame with a custom allocator - a real contribution.

The unsolved problem is *propagation*. When `level_one` calls
`level_two` which calls `level_three`, each child coroutine
needs the allocator at its call site - before it has any
connection to a receiver. The parent must query its own
environment, extract the allocator, and pass it explicitly.

A likely counterargument is that this is analogous to how
allocators work for standard containers: you pass the allocator
at construction time, and the container propagates it
internally. But coroutines are fundamentally different:

- With containers, the allocator type is part of the type
  signature (`vector<T, Alloc>`). With coroutines, the return
  type is `task<T>` - it does not carry the allocator type.
- With containers, `uses_allocator` construction gives generic
  code a standard way to propagate the allocator. With
  coroutines, there is no equivalent mechanism.
- With containers, the allocator is passed once at construction
  and the container handles propagation internally. With
  coroutines, every call site in the chain must manually query
  and forward.

Until a propagation mechanism comparable to `uses_allocator`
exists for coroutine frame allocation, the two-tier design
solves only the first call in the chain. Production I/O code
involves deep call chains, and the manual forwarding burden
makes it impractical to maintain allocator discipline
throughout.

---

## Appendix C - Committee Record

### C.1 The Single Async Model Debate

On 2021-09-28 (attendance: 49), the committee debated whether
`std::execution` should be the single async model for C++:

> "We must have a single async model for the C++ Standard
> Library"
>
> | SF | F  | N  | A  | SA |
> |----|----|----|----|----|
> |  5 |  9 | 10 | 11 |  4 |
>
> No consensus.

The committee could not agree on a single model, but the
question itself reveals the ambition: `std::execution` was being
positioned to serve all async use cases including I/O.

### C.2 The C++23 Deferral

LEWG 2022-01-12:

> "Produce a P2300R4 (std::execution), modified as described
> below, and then send the revised paper to LWG for C++23 with
> priority 1"
>
> | SF | F | N | A | SA |
> |----|---|---|---|----|
> | 15 | 9 | 1 | 3 |  6 |
>
> Attendance: 39. Weak consensus.

Recorded SA reasons included:
"maturity/readiness/tag_invoke and the numerous change in the
last few meetings," "Feels like ranges all over again. Needs
maturity," and "Too few reviews from embedded people."

The C++23 deferral happened because of maturity concerns. The
same pattern of ongoing design changes is present again.

### C.3 SG4 Networking Mandate

SG4 polled at Kona (November 2023) on
[P2762R2](https://wg21.link/p2762r2):

> "Networking should support only a sender/receiver model for
> asynchronous operations; the Networking TS's executor model
> should be removed"
>
> | SF | F | N | A | SA |
> |----|---|---|---|----|
> |  5 | 5 | 1 | 0 |  1 |
>
> Consensus.

SG4's feature requirements for networking (Kona 2023):

| Feature                | Yes | No |
|------------------------|:---:|:--:|
| `async_read`           |  8  |  2 |
| `async_write`          |  7  |  2 |
| `timeout`              |  8  |  2 |
| `connect(context, name)` |  8  |  1 |

These are the I/O primitives that will be built on
`std::execution`.

### C.4 P3552 Design Approval and Forwarding

The P3552R1 design approval poll (LEWG, 2025-04-22):

> | SF | F | N | A | SA |
> |----|---|---|---|----|
> |  5 | 6 | 6 | 1 |  0 |
>
> Attendance: 23.

Six neutral votes matching the number of favourable votes is a
notably soft result for a design approval poll.

The forwarding poll (LEWG, 2025-05-06):

> "Forward P3552R1 with the action items discussed to LWG for
> C++29"
>
> SF:5 / F:7 / N:0 / A:0 / SA:0 - unanimous.
>
> "Forward P3552R1 to LWG with the action items discussed with
> a recommendation to apply for C++26 (if possible)."
>
> SF:5 / F:3 / N:4 / A:1 / SA:0 - weak consensus, with "if
> possible" qualifier.

C++29 was unanimous; C++26 was conditional and weak.

### C.5 Hagenberg Design Reworks

At Hagenberg (February 2025), SG1 forwarded P3552R0 with
required architectural changes: replacing `continues_on` with
a new `affine_on` mechanism, adding a cancellation channel,
supporting errors without exceptions, and implementing
scheduler affinity (SF:7 / F:0 / N:0 / A:1 / SA:0). The sole A
voter specifically wanted "a more general concept for scheduler
affinity to come to SG1 before we ship something in the
standard."

LEWG then polled on `affine_on` replacing `continue_on`
(SF:9 / F:6 / N:2 / A:1 / SA:0) and on error-without-exceptions
support (SF:6 / F:6 / N:4 / A:1 / SA:1). These are fundamental
design changes - not editorial fixes - made in the same year as
the C++26 deadline.

### C.6 P3796R1 and the Allocator Polls

See Section 5.1 for the LEWG allocator poll. The full context:

[P3796R1](https://wg21.link/p3796r1) (Dietmar Kuhl, "Coroutine
Task Issues") was reviewed in LEWG telecons during
August-September 2025. Some sections achieved consensus; others
remain pending. Multiple LWG issues were opened (4329-4332,
4344).

US 255 ([cplusplus/nbballot#959](https://github.com/cplusplus/nbballot/issues/959),
LWG4335): "Use allocator from receiver's environment." The NB
comment states: "Normally, the get_allocator query forwards the
allocator from the receiver's environment. For task the
get_allocator query used for co_awaited senders uses the
allocator passed when creating the coroutine or the default if
there was none. It should use the receiver's environment, at
least, if the receiver's environment supports a get_allocator
query. Supporting the receiver's allocator isn't always possible:
the used allocator type needs to be known when the coroutine is
created. At that time the receiver isn't known, yet."

This is D4007's thesis stated as a US national body comment.

US 253 ([cplusplus/nbballot#961](https://github.com/cplusplus/nbballot/issues/961),
LWG4333): "Allow use of arbitrary allocators for coroutine
frame." Status: needs wording.

### C.7 Kona Algorithm Customisation Straw Poll

At Kona (November 2025), LEWG reviewed P3826's proposed fix for
algorithm customisation:

| Option | Description                                                |  F |  A |
|--------|--------------------------------------------------------------|---:|---:|
| 1      | Remove all of the C++26 `std::execution`                     |  3 | 30 |
| 2      | Remove all of the customisable sender algorithms for C++26   | 12 | 14 |
| 3      | Remove sender algorithm customisation (early & late)         | 17 |  5 |
| 4      | Fix customisations now (only late CPs)                       | 21 |  7 |
| 5      | Ship as-is and fix algorithm customisation in a DR           |  6 | 21 |

Attendance: 44.

Option 4 (fix now) won the most support. The resolution went
through three revisions before eventual acceptance in January
2026.

### C.8 Outstanding LWG Defects

Two Priority 1 defects remain open as of the Kona meeting:

- **LWG 4206:** `connect_result_t` unconstrained, causing hard
  errors instead of SFINAE-friendly failures.
- **LWG 4368:** Dangling-reference vulnerability in
  `transform_sender` (stack-use-after-scope) - returns xvalue
  to a dead temporary, potential undefined behaviour.

Additional open defects:

- **LWG 4190:** `completion-signatures-for` specification is
  recursive - a circular dependency that cannot be satisfied.
- **LWG 4215:** `run_loop::finish` should be `noexcept` -
  throwing causes `sync_wait` to hang forever.
- **LWG 4355:** `connect-awaitable()` should mandate receiver
  completion-signals.
- **LWG 4356:** `connect()` should use
  `get_allocator(get_env(rcvr))` - directly relevant to the
  allocator timing issue.

Priority 1 issues in an approved feature are a concrete signal
that the specification has not yet stabilised. These are not
obscure corner cases but defects in core mechanisms (`connect`
and `transform_sender`) that every sender/receiver program
exercises.

---

## Appendix D - Post-Approval Modification Catalogue

The following tables list all WG21 papers identified as fixing,
reworking, removing, or completing missing functionality in
`std::execution` (P2300) after its approval for C++26. Papers
that extend the framework into new domains (e.g., networking)
are excluded.

### Removals

| Paper   | Title                                                   | Author(s)                 | Date       | Status          | Change                                                                                                              |
|---------|---------------------------------------------------------|---------------------------|------------|-----------------|---------------------------------------------------------------------------------------------------------------------|
| P3187R1 | Remove `ensure_started` and `start_detached` from P2300 | Lewis Baker, Eric Niebler | 2024-10-15 | Adopted         | Removes two algorithms that dynamically allocate with no allocator customization and break structured concurrency.   |
| P3682R0 | Remove `std::execution::split`                          | Eric Niebler              | 2025-02-04 | Adopted (Sofia) | Removes `split` due to incorrect description of its purpose and problematic semantics.                              |

### Major Design Reworks

| Paper   | Title                                                     | Author(s)         | Date       | Status                                                                                                                                                                                       | Change                                                                                                                                                           |
|---------|-----------------------------------------------------------|-------------------|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| P2855R1 | Member customization points for Senders and Receivers     | Ville Voutilainen | 2024-03-18 | Adopted                                                                                                                                                                                      | Replaces `tag_invoke`-based ADL customization with member functions - a breaking change.                                                                         |
| P2999R3 | Sender Algorithm Customization                            | Eric Niebler      | 2024-04-16 | Adopted                                                                                                                                                                                      | Removes ADL-based customization of sender algorithms in favour of member-function customization on a domain object.                                              |
| P3303R1 | Fixing Lazy Sender Algorithm Customization                | Eric Niebler      | 2024-10-15 | Adopted                                                                                                                                                                                      | Fixes gross oversight in P2999 where wording changes that implement the approved design were missing.                                                            |
| P3175R3 | Reconsidering the `std::execution::on` algorithm          | Eric Niebler      | 2024-10-15 | Adopted                                                                                                                                                                                      | Renames `on` to `starts_on` and `transfer` to `continues_on` because usage revealed a gap between users' expectations and actual behaviour. Also fixes a bug in `get_scheduler`. |
| P3557R3 | High-Quality Sender Diagnostics with Constexpr Exceptions | Eric Niebler      | 2025-06-10 | Adopted (Sofia)                                                                                                                                                                              | Reworks `get_completion_signatures` from member function to static constexpr function template. Adds `dependent_sender` concept.                                 |
| P3570R2 | Optional variants in sender/receiver                      | Lewis Baker       | 2025-06-14 | Adopted - forwarded to LWG for C++26.                                                                                                                                                        | Adds `get_await_completion_adapter` for coroutine users.                                                                                                         |
| P3718R0 | Fixing Lazy Sender Algorithm Customization, Again         | Eric Niebler      | 2025-07-24 | In Progress - open, bumped from 2025-telecon to 2026-telecon milestone. Third paper attempting to fix lazy customization (after P2999, P3303). Linked to NB comment.                         | Further fixes to the lazy customization mechanism after P3303.                                                                                                   |
| P3826R3 | Fix Sender Algorithm Customization                        | Eric Niebler      | 2025-11-14 | In Progress - open, 2026-telecon milestone. Title evolved from "Defer...to C++29" (R0) to "Fix or Remove..." (R1) to "Fix..." (R3). Linked to 5 NB comments. Under active LEWG review.     | Proposes deferring algorithm customization features that cannot be fixed in time for C++26.                                                                      |
| P3927R0 | `task_scheduler` Support for Parallel Bulk Execution      | Eric Niebler      | 2026-01-17 | In Progress - open, 2026-telecon milestone. January 2026 mailing. Not yet reviewed in telecon. Implemented in NVIDIA CCCL.                                                                  | Fixes `task_scheduler` not parallelizing bulk work when wrapping a `parallel_scheduler`.                                                                         |

### Wording Fixes and Corrections

| Paper   | Title                                                      | Author(s)                | Date       | Status                                                                                                                                               | Change                                                                                                                                 |
|---------|------------------------------------------------------------|--------------------------|-----------|-------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| P3396R1 | `std::execution` wording fixes                             | Eric Niebler             | 2024-11-22 | Adopted                                                                                                                                               | Omnibus paper addressing multiple wording issues: `run_loop` preconditions, environment ownership, scheduler concept inconsistencies.  |
| P3388R3 | When Do You Know `connect` Doesn't Throw?                  | Ville Voutilainen        | 2025-02-14 | Adopted                                                                                                                                               | Fixes incorrect `noexcept` clause of the constructor of `basic-state`.                                                                 |
| P3914R0 | Assorted NB comment resolutions for Kona 2025              | Various                  | 2025-11-07 | In Progress - omnibus NB comment resolution paper. Sections 2.2-2.5 address `std::execution`. Individual resolutions adopted piecemeal.              | Addresses national body comments on the C++26 CD related to `std::execution`.                                                          |
| P3887R1 | Make `when_all` a Ronseal Algorithm                        | Robert Leahy             | 2025-11-07 | Adopted - forwarded at Kona (SF:10/F:5/N:0/A:0/SA:0), wording merged into draft (Dec 2025).                                                         | Fixes `when_all` stop-request handling - removes unnecessary stop-detection complexity that made the algorithm's behaviour surprising.  |
| P3940R0 | Rename concept tags for C++26: `sender_t` to `sender_tag` | Arthur O'Dwyer, Yi'an Ye | 2025-12-15 | In Progress - open, 2026-telecon milestone. Post-Kona mailing. Not yet reviewed in telecon.                                                          | Renames concept tag types (`sender_t` to `sender_tag`, etc.) for naming consistency - another post-approval naming correction.         |

### Missing Functionality

| Paper    | Title                                                        | Author(s)                                      | Date       | Status                                                                          | Change                                                                                                                                                              |
|----------|--------------------------------------------------------------|-------------------------------------------------|------------|---------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| P3425R1  | Reducing operation-state sizes for subobject child operations | Eric Niebler                                   | 2024-11-19 | Design approved - LEWG Wroclaw (Nov 2024) strong consensus. C++26-targeted.     | Optimisation saving 8 bytes per nesting level - performance fix for deeply nested sender expressions.                                                               |
| P3284R4  | `write_env` and `unstoppable` Sender Adaptors                | Eric Niebler                                   | 2025-02-14 | Adopted (Sofia)                                                                 | Adds missing sender adaptors for modifying execution environments.                                                                                                  |
| P3685R0  | Rename `async_scope_token`                                   | Ian Petersen, Jessica Wong                     | 2025-04-09 | Adopted                                                                         | Renames `async_scope_token` to `scope_token` for clarity.                                                                                                           |
| P3706R0  | Rename `join` and `nest` in async scope proposal             | Ian Petersen, Jessica Wong                     | 2025-04-09 | Adopted                                                                         | Renames `nest` to `associate` because original names were misleading.                                                                                               |
| P3325R5  | A Utility for Creating Execution Environments                | Eric Niebler                                   | 2025-05-22 | Adopted                                                                         | Adds `prop` and `env` class templates for creating and manipulating environments - fundamental infrastructure that was absent.                                       |
| P2079R10 | Parallel scheduler                                           | Lee Howes                                      | 2025-06-02 | Adopted (Sofia)                                                                 | Provides `system_context` and `system_scheduler` - a basic execution context needed to actually run code.                                                           |
| P3149R11 | `async_scope`                                                | Ian Petersen, Jessica Wong, Kirk Shoop, et al. | 2025-06-02 | Adopted (Sofia)                                                                 | Provides the async scope abstraction needed for safe non-sequential concurrency - replacing the removed `ensure_started`/`start_detached`.                          |
| P3164R4  | Early Diagnostics for Sender Expressions                     | Eric Niebler                                   | 2025-06-02 | Adopted                                                                         | Moves diagnosis of invalid sender expressions to construction time rather than connection time.                                                                     |
| P3552R3  | Add a Coroutine Task Type                                    | Dietmar Kuhl, Maikel Nadolski                  | 2025-06-20 | Adopted (Sofia)                                                                 | Adds `std::execution::task` - the coroutine type that users need to use the framework. Adopted at Sofia with 29 abstentions and 11 against (77-11-29).             |
| P3815R1  | Add `scope_association` concept to P3149                     | Jessica Wong, Ian Petersen                     | 2025-09-12 | Adopted - closed Dec 2025. NB comment resolution.                               | Adds missing `scope_association` concept needed by the async scope facility.                                                                                        |

### Post-Adoption Issues

| Paper   | Title                                               | Author(s)                                              | Date       | Status                                                                                                                                                                                                                                | Change                                                                                                                                                               |
|---------|-----------------------------------------------------|--------------------------------------------------------|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| P3433R1 | Allocator Support for Operation States              | Dietmar Kuhl                                           | 2024-10-17 | Plenary-approved - closed. LEWG Wroclaw (Nov 2024) approved design with strong consensus (SF:4/F:6/N:0/A:0/SA:0). Wording merged into draft.                                                                                        | Identifies allocator gaps in `ensure_started`, `split`, and `start_detached` operation states - confirming allocator support was missing from the original design.   |
| P3481R5 | `std::execution::bulk()` issues                     | Lucian Radu Teodorescu, Lewis Baker, Ruslan Arutyunyan | 2024-10-17 | Plenary-approved - closed. Five revisions. SG1 Wroclaw (Nov 2024) achieved unanimous consent on splitting bulk into `bulk`, `bulk_chunked`, and `bulk_unchunked`. Wording merged into draft.                                         | Addresses outstanding issues with the bulk algorithm; required five revisions and addition of two new API variants (`bulk_chunked`, `bulk_unchunked`).               |
| P3796R1 | Coroutine Task Issues                               | Dietmar Kuhl                                           | 2025-07-24 | In Progress - open, 2026-telecon milestone. Under active LEWG telecon review (Aug-Sep 2025); some sections achieved consensus, others still pending. Multiple LWG issues opened (4329-4332, 4344). Linked to NB comments.            | Collects issues discovered after the task type was forwarded, including `unhandled_stopped` missing `noexcept`, wording issues, and performance concerns.            |
| P3801R0 | Concerns about the design of `std::execution::task` | Jonathan Wakely                                        | 2025-07-24 | In Progress - open, 2026-telecon milestone. LEWG telecon review (2025-08-26) reached "no consensus" on the core stack overflow issue; "consensus against" treating dangling reference concern as C++26 blocker. Linked to NB comment. | Documents significant concerns including stack overflow risk due to lack of symmetric transfer support.                                                              |

### LWG Issues

| Issue    | Title                                                              | Date       | Status                                                       | Change                                                                                                                          |
|----------|--------------------------------------------------------------------|------------|--------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|
| LWG 4190 | `completion-signatures-for` specification is recursive             | 2025-01-02 | Open - circular dependency in spec.                          | Specification defect: recursive definition makes the requirement impossible to implement.                                       |
| LWG 4206 | `connect_result_t` should be constrained with `sender_to`          | 2025-02-04 | Open - Priority 1.                                           | Unconstrained alias causes hard errors instead of SFINAE-friendly failures.                                                     |
| LWG 4215 | `run_loop::finish` should be `noexcept`                            | 2025-02-13 | Open - correctness bug.                                      | Throwing `finish()` causes `sync_wait` to hang forever.                                                                         |
| LWG 4260 | Query objects must be default constructible                        | 2025-05-07 | Resolved (Kona 2025)                                         | CPO constructors were not mandated `noexcept`.                                                                                  |
| LWG 4355 | `connect-awaitable()` should mandate receiver completion-signals   | 2025-08-27 | Open                                                         | Redundant `requires`-clause should defer to parent `Mandates`.                                                                  |
| LWG 4356 | `connect()` should use `get_allocator(get_env(rcvr))`              | 2025-08-27 | Open - directly relevant to allocator timing issue.          | `connect-awaitable` should respect the receiver's allocator.                                                                    |
| LWG 4358 | `[exec.as.awaitable]` uses Preconditions when should be constraint | 2025-08-27 | Resolved (Kona 2025)                                         | Incorrectly-written preconditions should be `Mandates`.                                                                         |
| LWG 4360 | `awaitable-sender` concept should qualify `awaitable-receiver`     | 2025-08-27 | Resolved (Kona 2025)                                         | Ambiguous type reference in the `awaitable-sender` concept.                                                                     |
| LWG 4368 | Potential dangling reference from `transform_sender`               | 2025-08-31 | Open - Priority 1. Stack-use-after-scope vulnerability.      | Returns xvalue to a dead temporary - potential undefined behaviour.                                                             |
| LWG 4369 | `check-types` for `upon_error` and `upon_stopped` is wrong         | 2025-08-31 | Resolved (Kona 2025)                                         | Uses `set_value_t` where `set_error_t`/`set_stopped_t` should be used.                                                         |
| LWG 4336 | `bulk` vs. `task_scheduler`                                        | 2025-10-23 | Open - NB comment. C++26-targeted.                           | `task_scheduler` does not parallelise bulk work - dispatching `bulk` via a `task_scheduler` wrapping `parallel_scheduler` serialises execution. P3927R0 proposes the fix. |

### Allocator-Related NB Comments (Kona 2025)

| NB Comment                                                                  | Title                                                | Status        |
|-----------------------------------------------------------------------------|------------------------------------------------------|---------------|
| [US 255](https://github.com/cplusplus/nbballot/issues/959) (LWG4335)       | Use allocator from receiver's environment            | Needs wording |
| [US 253](https://github.com/cplusplus/nbballot/issues/961) (LWG4333)       | Allow use of arbitrary allocators for coroutine frame | Needs wording |

**Total: 30 papers, 11 LWG issues, and 2 NB comments - 43 items
modifying a single feature after its approval.**

---

## References

- [P2079R10](https://wg21.link/p2079r10) Lee Howes.
  "Parallel scheduler." 2025-06-02.
- [P2300R4](https://wg21.link/p2300r4) Michal Dominiak,
  et al. "std::execution." 2022-01-18.
- [P2300R10](https://wg21.link/p2300r10) Michal Dominiak,
  et al. "std::execution." 2024-07-16.
- [P2762R2](https://wg21.link/p2762r2) Dietmar Kuhl.
  "Sender/Receiver Interface For Networking." 2023-10-15.
- [P2855R1](https://wg21.link/p2855r1) Ville Voutilainen.
  "Member customization points for Senders and Receivers."
  2024-03-18.
- [P2999R3](https://wg21.link/p2999r3) Eric Niebler.
  "Sender Algorithm Customization." 2024-04-16.
- [P3149R11](https://wg21.link/p3149r11) Ian Petersen,
  Jessica Wong, Kirk Shoop, et al. "async_scope."
  2025-06-02.
- [P3175R3](https://wg21.link/p3175r3) Eric Niebler.
  "Reconsidering the std::execution::on algorithm."
  2024-10-15.
- [P3187R1](https://wg21.link/p3187r1) Lewis Baker, Eric
  Niebler. "Remove ensure_started and start_detached from
  P2300." 2024-10-15.
- [P3433R1](https://wg21.link/p3433r1) Dietmar Kuhl.
  "Allocator Support for Operation States." 2025-06-18.
- [P3552R3](https://wg21.link/p3552r3) Dietmar Kuhl, Maikel
  Nadolski. "Add a Coroutine Task Type." 2025-06-20.
- [P3557R3](https://wg21.link/p3557r3) Eric Niebler.
  "High-Quality Sender Diagnostics with Constexpr
  Exceptions." 2025-06-10.
- [P3796R1](https://wg21.link/p3796r1) Dietmar Kuhl.
  "Coroutine Task Issues." 2025-07-24.
- [P3801R0](https://wg21.link/p3801r0) Jonathan Wakely.
  "Concerns about the design of std::execution::task."
  2025-07-24.
- [P3826R3](https://wg21.link/p3826r3) Eric Niebler. "Fix
  Sender Algorithm Customization." 2026-01-05.
- [P3927R0](https://wg21.link/p3927r0) Eric Niebler.
  "task_scheduler Support for Parallel Bulk Execution."
  2026-01-17.
- [P4003R0](https://wg21.link/p4003r0) Vinnie Falco.
  "IoAwaitables: A Coroutines-First Execution Model."
  2026-01-21.
